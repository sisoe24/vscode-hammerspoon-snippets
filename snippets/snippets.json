{
    "Checks the Accessibility Permissions for Hammerspoon, and optionally allows you to prompt for permissions.": {
        "prefix": "hs.accessibilityState(shouldPrompt) -> isEnabled",
        "body": "hs.accessibilityState(${1:shouldPrompt})",
        "description": "Checks the Accessibility Permissions for Hammerspoon, and optionally allows you to prompt for permissions.\n\nParameters:\n * shouldPrompt - an optional boolean value indicating if the dialog box asking if the System Preferences application should be opened should be presented when Accessibility is not currently enabled for Hammerspoon.  Defaults to false.\n\nReturns:\n * True or False indicating whether or not Accessibility is enabled for Hammerspoon.\n\nNotes:\n * Since this check is done automatically when Hammerspoon loads, it is probably of limited use except for skipping things that are known to fail when Accessibility is not enabled.  Evettaps which try to capture keyUp and keyDown events, for example, will fail until Accessibility is enabled and the Hammerspoon application is relaunched."
    },
    "An optional function that will be called when the Accessibility State is changed.": {
        "prefix": "hs.accessibilityStateCallback",
        "body": "hs.accessibilityStateCallback",
        "description": "An optional function that will be called when the Accessibility State is changed.\n\nNotes:\n * The function will not receive any arguments when called.  To check what the accessibility state has been changed to, you should call [hs.accessibilityState](#accessibilityState) from within your function."
    },
    "Set or display whether or not external Hammerspoon AppleScript commands are allowed.": {
        "prefix": "hs.allowAppleScript([state]) -> bool",
        "body": "hs.allowAppleScript(${1:[state]})",
        "description": "Set or display whether or not external Hammerspoon AppleScript commands are allowed.\n\nParameters:\n * state - an optional boolean which will set whether or not external Hammerspoon's AppleScript commands are allowed.\n\nReturns:\n * A boolean, `true` if Hammerspoon's AppleScript commands are (or has just been) allowed, otherwise `false`.\n\nNotes:\n * AppleScript access is disallowed by default.\n * However due to the way AppleScript support works, Hammerspoon will always allow AppleScript commands that are part of the \"Standard Suite\", such as `name`, `quit`, `version`, etc. However, Hammerspoon will only allow commands from the \"Hammerspoon Suite\" if `hs.allowAppleScript()` is set to `true`.\n * For a full list of AppleScript Commands:\n     - Open `/Applications/Utilities/Script Editor.app`\n     - Click `File > Open Dictionary...`\n     - Select Hammerspoon from the list of Applications\n     - This will now open a Dictionary containing all of the availible Hammerspoon AppleScript commands.\n * Note that strings within the Lua code you pass from AppleScript can be delimited by `[[` and `]]` rather than normal quotes\n * Example:\n\n   ```lua\n   tell application \"Hammerspoon\"\n     execute lua code \"hs.alert([[Hello from AppleScript]])\"\n   end tell```"
    },
    "Set or display the \"Launch on Login\" status for Hammerspoon.": {
        "prefix": "hs.autoLaunch([state]) -> bool",
        "body": "hs.autoLaunch(${1:[state]})",
        "description": "Set or display the \"Launch on Login\" status for Hammerspoon.\n\nParameters:\n * state - an optional boolean which will set whether or not Hammerspoon should be launched automatically when you log into your computer.\n\nReturns:\n * True if Hammerspoon is currently (or has just been) set to launch on login or False if Hammerspoon is not."
    },
    "Gets and optionally sets the Hammerspoon option to automatically check for updates.": {
        "prefix": "hs.automaticallyCheckForUpdates([setting]) -> bool",
        "body": "hs.automaticallyCheckForUpdates(${1:[setting]})",
        "description": "Gets and optionally sets the Hammerspoon option to automatically check for updates.\n\nParameters:\n * setting - an optional boolean variable indicating if Hammerspoon should (true) or should not (false) check for updates.\n\nReturns:\n * The current (or newly set) value indicating whether or not automatic update checks should occur for Hammerspoon.\n\nNotes:\n * If you are running a non-release or locally compiled version of Hammerspoon then the results of this function are unspecified."
    },
    "Checks the Camera Permissions for Hammerspoon, and optionally allows you to prompt for permissions.": {
        "prefix": "hs.cameraState(shouldPrompt) -> boolean",
        "body": "hs.cameraState(${1:shouldPrompt})",
        "description": "Checks the Camera Permissions for Hammerspoon, and optionally allows you to prompt for permissions.\n\nParameters:\n * shouldPrompt - an optional boolean value indicating if we should request camear access. Defaults to false.\n\nReturns:\n * `true` or `false` indicating whether or not Camera access is enabled for Hammerspoon.\n\nNotes:\n * Will always return `true` on macOS 10.13 or earlier."
    },
    "Returns a boolean indicating whether or not the Sparkle framework is available to check for Hammerspoon updates.": {
        "prefix": "hs.canCheckForUpdates() -> boolean",
        "body": "hs.canCheckForUpdates()",
        "description": "Returns a boolean indicating whether or not the Sparkle framework is available to check for Hammerspoon updates.\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the Sparkle framework is available to check for Hammerspoon updates\n\nNotes:\n * The Sparkle framework is included in all regular releases of Hammerspoon but not included if you are running a non-release or locally compiled version of Hammerspoon, so this function can be used as a simple test to determine whether or not you are running a formal release Hammerspoon or not."
    },
    "Check for an update now, and if one is available, prompt the user to continue the update process.": {
        "prefix": "hs.checkForUpdates([silent]) -> none",
        "body": "hs.checkForUpdates(${1:[silent]})",
        "description": "Check for an update now, and if one is available, prompt the user to continue the update process.\n\nParameters:\n * silent - An optional boolean. If true, no UI will be displayed if an update is available. Defaults to false.\n\nReturns:\n * None\n\nNotes:\n * If you are running a non-release or locally compiled version of Hammerspoon then the results of this function are unspecified."
    },
    "Returns a copy of the incoming string that can be displayed in the Hammerspoon console.  Invalid UTF8 sequences are converted to the Unicode Replacement Character and NULL (0x00) is converted to the Unicode Empty Set character.": {
        "prefix": "hs.cleanUTF8forConsole(inString) -> outString",
        "body": "hs.cleanUTF8forConsole(${1:inString})",
        "description": "Returns a copy of the incoming string that can be displayed in the Hammerspoon console.  Invalid UTF8 sequences are converted to the Unicode Replacement Character and NULL (0x00) is converted to the Unicode Empty Set character.\n\nParameters:\n * inString - the string to be cleaned up\n\nReturns:\n * outString - the cleaned up version of the input string.\n\nNotes:\n * This function is applied automatically to all output which appears in the Hammerspoon console, but not to the output provided by the `hs` command line tool.\n * This function does not modify the original string - to actually replace it, assign the result of this function to the original string.\n * This function is a more specifically targeted version of the `hs.utf8.fixUTF8(...)` function."
    },
    "Closes the Hammerspoon Console window": {
        "prefix": "hs.closeConsole()",
        "body": "hs.closeConsole()",
        "description": "Closes the Hammerspoon Console window\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Closes the Hammerspoon Preferences window": {
        "prefix": "hs.closePreferences()",
        "body": "hs.closePreferences()",
        "description": "Closes the Hammerspoon Preferences window\n\nParamters:\n * None\n\nReturns:\n * None"
    },
    "Gathers tab completion options for the Console window": {
        "prefix": "hs.completionsForInputString(completionWord) -> table of strings",
        "body": "hs.completionsForInputString(${1:completionWord})",
        "description": "Gathers tab completion options for the Console window\n\nParameters:\n * completionWord - A string from the Console window's input field that completions are needed for\n\nReturns:\n * A table of strings, each of which will be shown as a possible completion option to the user\n\nNotes:\n * Hammerspoon provides a default implementation of this function, which can complete against the global Lua namespace, the 'hs' (i.e. extension) namespace, and object metatables. You can assign a new function to the variable to replace it with your own variant."
    },
    "A string containing Hammerspoon's configuration directory. Typically `~/.hammerspoon/`": {
        "prefix": "hs.configdir",
        "body": "hs.configdir",
        "description": "A string containing Hammerspoon's configuration directory. Typically `~/.hammerspoon/`"
    },
    "Set or display whether or not the Hammerspoon console is always on top when visible.": {
        "prefix": "hs.consoleOnTop([state]) -> bool",
        "body": "hs.consoleOnTop(${1:[state]})",
        "description": "Set or display whether or not the Hammerspoon console is always on top when visible.\n\nParameters:\n * state - an optional boolean which will set whether or not the Hammerspoon console is always on top when visible.\n\nReturns:\n * True if the console is currently set (or has just been) to be always on top when visible or False if it is not."
    },
    "Yield coroutine to allow the Hammerspoon application to process other scheduled events and schedule a resume in the event application queue.": {
        "prefix": "hs.coroutineApplicationYield([delay])",
        "body": "hs.coroutineApplicationYield(${1:[delay]})",
        "description": "Yield coroutine to allow the Hammerspoon application to process other scheduled events and schedule a resume in the event application queue.\n\nParameters:\n * `delay` - an optional number, default `hs.math.minFloat`, specifying the number of seconds from when this function is executed that the `coroutine.resume` should be scheduled for.\n\nReturns:\n * None\n\nNotes:\n * this function will return an error if invoked outside of a coroutine.\n * unlike `coroutine.yield`, this function does not allow the passing of (new) information to or from the coroutine while it is running; this function is to allow long running tasks to yield time to the Hammerspoon application so other timers and scheduled events can occur without requiring the programmer to add code for an explicit resume.\n\n * this function is added to the lua `coroutine` library as `coroutine.applicationYield` as an alternative name."
    },
    "Set or display whether or not the Hammerspoon dock icon is visible.": {
        "prefix": "hs.dockIcon([state]) -> bool",
        "body": "hs.dockIcon(${1:[state]})",
        "description": "Set or display whether or not the Hammerspoon dock icon is visible.\n\nParameters:\n * state - an optional boolean which will set whether or not the Hammerspoon dock icon should be visible.\n\nReturns:\n * True if the icon is currently set (or has just been) to be visible or False if it is not.\n\nNotes:\n * This function is a wrapper to functions found in the `hs.dockicon` module, but is provided here to provide an interface consistent with other selectable preference items."
    },
    "An optional function that will be called when the Hammerspoon Dock Icon is clicked while the app is running": {
        "prefix": "hs.dockIconClickCallback",
        "body": "hs.dockIconClickCallback",
        "description": "An optional function that will be called when the Hammerspoon Dock Icon is clicked while the app is running\n\nNotes:\n * If set, this callback will be called regardless of whether or not Hammerspoon shows its console window in response to a click (which can be enabled/disabled via `hs.openConsoleOnDockClick()`"
    },
    "A string containing the full path to the `docs.json` file inside Hammerspoon's app bundle. This contains the full Hammerspoon API documentation and can be accessed in the Console using `help(\"someAPI\")`. It can also be loaded and processed by the `hs.doc` extension": {
        "prefix": "hs.docstrings_json_file",
        "body": "hs.docstrings_json_file",
        "description": "A string containing the full path to the `docs.json` file inside Hammerspoon's app bundle. This contains the full Hammerspoon API documentation and can be accessed in the Console using `help(\"someAPI\")`. It can also be loaded and processed by the `hs.doc` extension"
    },
    "Runs a shell command, optionally loading the users shell environment first, and returns stdout as a string, followed by the same result codes as `os.execute` would return.": {
        "prefix": "hs.execute(command[, with_user_env]) -> output, status, type, rc",
        "body": "hs.execute(${1:command[}, ${2:with_user_env]})",
        "description": "Runs a shell command, optionally loading the users shell environment first, and returns stdout as a string, followed by the same result codes as `os.execute` would return.\n\nParameters:\n * command - a string containing the shell command to execute\n * with_user_env - optional boolean argument which if provided and is true, executes the command in the users login shell as an \"interactive\" login shell causing the user's local profile (or other login scripts) to be loaded first.\n\nReturns:\n * output -- the stdout of the command as a string.  May contain an extra terminating new-line (\\n).\n * status -- `true` if the command terminated successfully or nil otherwise.\n * type   -- a string value of \"exit\" or \"signal\" indicating whether the command terminated of its own accord or if it was terminated by a signal (killed, segfault, etc.)\n * rc     -- if the command exited of its own accord, then this number will represent the exit code (usually 0 for success, not 0 for an error, though this is very command specific, so check man pages when there is a question).  If the command was killed by a signal, then this number corresponds to the signal type that caused the command to terminate.\n\nNotes:\n * Setting `with_user_env` to true does incur noticeable overhead, so it should only be used if necessary (to set the path or other environment variables).\n * Because this function returns the stdout as it's first return value, it is not quite a drop-in replacement for `os.execute`.  In most cases, it is probable that `stdout` will be the empty string when `status` is nil, but this is not guaranteed, so this trade off of shifting os.execute's results was deemed acceptable.\n * This particular function is most useful when you're more interested in the command's output then a simple check for completion and result codes.  If you only require the result codes or verification of command completion, then `os.execute` will be slightly more efficient.\n * If you need to execute commands that have spaces in their paths, use a form like: `hs.execute [[\"/Some/Path To/An/Executable\" \"--first-arg\" \"second-arg\"]]`"
    },
    "An optional function that will be called when a files are dragged to the Hammerspoon Dock Icon or sent via the Services menu": {
        "prefix": "hs.fileDroppedToDockIconCallback",
        "body": "hs.fileDroppedToDockIconCallback",
        "description": "An optional function that will be called when a files are dragged to the Hammerspoon Dock Icon or sent via the Services menu\n\nNotes:\n * The function should accept a single parameter, which will be a string containing the full path to the file that was dragged to the dock icon\n * If multiple files are sent, this callback will be called once for each file\n * This callback will be triggered when ANY file type is dragged onto the Hammerspoon Dock Icon, however certain filetypes are also processed seperately by Hammerspoon. For example, `hs.urlevent` will be triggered when the following filetypes are dropped onto the Dock Icon: HTML Documents (.html, .htm, .shtml, .jhtml), Plain text documents (.txt, .text), Web site locations (.url), XHTML documents (.xhtml, .xht, .xhtm, .xht)."
    },
    "Makes Hammerspoon the foreground app.": {
        "prefix": "hs.focus()",
        "body": "hs.focus()",
        "description": "Makes Hammerspoon the foreground app."
    },
    "Fetches the Lua metatable for objects produced by an extension": {
        "prefix": "hs.getObjectMetatable(name) -> table or nil",
        "body": "hs.getObjectMetatable(${1:name})",
        "description": "Fetches the Lua metatable for objects produced by an extension\n\nParameters:\n * name - A string containing the name of a module to fetch object metadata for (e.g. `\"hs.screen\"`)\n\nReturns:\n * The extension's object metatable, or nil if an error occurred"
    },
    "Prints the documentation for some part of Hammerspoon's API and Lua 5.3.  This function is actually sourced from hs.doc.help.": {
        "prefix": "hs.help(identifier)",
        "body": "hs.help(${1:identifier})",
        "description": "Prints the documentation for some part of Hammerspoon's API and Lua 5.3.  This function is actually sourced from hs.doc.help.\n\nParameters:\n * identifier - A string containing the signature of some part of Hammerspoon's API (e.g. `\"hs.reload\"`)\n\nReturns:\n * None\n\nNotes:\n * This function is mainly for runtime API help while using Hammerspoon's Console\n * You can also access the results of this function by the following methods from the console:\n   * help(\"identifier\") -- quotes are required, e.g. `help(\"hs.reload\")`\n   * help.identifier.path -- no quotes are required, e.g. `help.hs.reload`\n * Lua information can be accessed by using the `lua` prefix, rather than `hs`.\n   * the identifier `lua._man` provides the table of contents for the Lua 5.3 manual.  You can pull up a specific section of the lua manual by including the chapter (and subsection) like this: `lua._man._3_4_8`.\n   * the identifier `lua._C` will provide information specifically about the Lua C API for use when developing modules which require external libraries."
    },
    "Display's Hammerspoon API documentation in a webview browser.": {
        "prefix": "hs.hsdocs([identifier])",
        "body": "hs.hsdocs(${1:[identifier]})",
        "description": "Display's Hammerspoon API documentation in a webview browser.\n\nParameters:\n * identifier - An optional string containing the signature of some part of Hammerspoon's API (e.g. `\"hs.reload\"`).  If no string is provided, then the table of contents for the Hammerspoon documentation is displayed.\n\nReturns:\n * None\n\nNotes:\n * You can also access the results of this function by the following methods from the console:\n   * hs.hsdocs.identifier.path -- no quotes are required, e.g. `hs.hsdocs.hs.reload`\n * See `hs.doc.hsdocs` for more information about the available settings for the documentation browser.\n * This function provides documentation for Hammerspoon modules, functions, and methods similar to the Hammerspoon Dash docset, but does not require any additional software.\n * This currently only provides documentation for the built in Hammerspoon modules, functions, and methods.  The Lua documentation and third-party modules are not presently supported, but may be added in a future release."
    },
    "Loads a Spoon": {
        "prefix": "hs.loadSpoon(name[, global]) -> Spoon object",
        "body": "hs.loadSpoon(${1:name[}, ${2:global]})",
        "description": "Loads a Spoon\n\nParameters:\n * name - The name of a Spoon (without the trailing `.spoon`)\n * global - An optional boolean. If true, this function will insert the spoon into Lua's global namespace as `spoon.NAME`. Defaults to true.\n\nReturns:\n * The object provided by the Spoon (which can be ignored if you chose to make the Spoon global)\n\nNotes:\n * Spoons are a way of distributing self-contained units of Lua functionality, for Hammerspoon. For more information, see https://github.com/Hammerspoon/hammerspoon/blob/master/SPOON.md\n * This function will load the Spoon and call its `:init()` method if it has one. If you do not wish this to happen, or wish to use a Spoon that somehow doesn't fit with the behaviours of this function, you can also simply `require('name')` to load the Spoon\n * If the Spoon has a `:start()` method you are responsible for calling it before using the functionality of the Spoon.\n * If the Spoon provides documentation, it will be loaded by made available in hs.docs\n * To learn how to distribute your own code as a Spoon, see https://github.com/Hammerspoon/hammerspoon/blob/master/SPOON.md"
    },
    "Set or display whether or not the Hammerspoon menu icon is visible.": {
        "prefix": "hs.menuIcon([state]) -> bool",
        "body": "hs.menuIcon(${1:[state]})",
        "description": "Set or display whether or not the Hammerspoon menu icon is visible.\n\nParameters:\n * state - an optional boolean which will set whether or not the Hammerspoon menu icon should be visible.\n\nReturns:\n * True if the icon is currently set (or has just been) to be visible or False if it is not."
    },
    "Checks the Microphone Permissions for Hammerspoon, and optionally allows you to prompt for permissions.": {
        "prefix": "hs.microphoneState(shouldPrompt) -> boolean",
        "body": "hs.microphoneState(${1:shouldPrompt})",
        "description": "Checks the Microphone Permissions for Hammerspoon, and optionally allows you to prompt for permissions.\n\nParameters:\n * shouldPrompt - an optional boolean value indicating if we should request microphone access. Defaults to false.\n\nReturns:\n * `true` or `false` indicating whether or not Microphone access is enabled for Hammerspoon.\n\nNotes:\n * Will always return `true` on macOS 10.13 or earlier."
    },
    "Opens a file as if it were opened with /usr/bin/open": {
        "prefix": "hs.open(filePath)",
        "body": "hs.open(${1:filePath})",
        "description": "Opens a file as if it were opened with /usr/bin/open\n\nParameters:\n * filePath - A string containing the path to a file/bundle to open\n\nReturns:\n * A boolean, true if the file was opened successfully, otherwise false"
    },
    "Displays the OS X About panel for Hammerspoon; implicitly focuses Hammerspoon.": {
        "prefix": "hs.openAbout()",
        "body": "hs.openAbout()",
        "description": "Displays the OS X About panel for Hammerspoon; implicitly focuses Hammerspoon."
    },
    "Opens the Hammerspoon Console window and optionally focuses it.": {
        "prefix": "hs.openConsole([bringToFront])",
        "body": "hs.openConsole(${1:[bringToFront]})",
        "description": "Opens the Hammerspoon Console window and optionally focuses it.\n\nParameters:\n * bringToFront - if true (default), the console will be focused as well as opened.\n\nReturns:\n * None"
    },
    "Set or display whether or not the Console window will open when the Hammerspoon dock icon is clicked": {
        "prefix": "hs.openConsoleOnDockClick([state]) -> bool",
        "body": "hs.openConsoleOnDockClick(${1:[state]})",
        "description": "Set or display whether or not the Console window will open when the Hammerspoon dock icon is clicked\n\nParameters:\n * state - An optional boolean, true if the console window should open, false if not\n\nReturns:\n * A boolean, true if the console window will open when the dock icon\n\nNotes:\n * This only refers to dock icon clicks while Hammerspoon is already running. The console window is not opened by launching the app"
    },
    "Displays the Hammerspoon Preferences panel; implicitly focuses Hammerspoon.": {
        "prefix": "hs.openPreferences()",
        "body": "hs.openPreferences()",
        "description": "Displays the Hammerspoon Preferences panel; implicitly focuses Hammerspoon."
    },
    "Set or display whether or not the Preferences panel should display in dark mode.": {
        "prefix": "hs.preferencesDarkMode([state]) -> bool",
        "body": "hs.preferencesDarkMode(${1:[state]})",
        "description": "Set or display whether or not the Preferences panel should display in dark mode.\n\nParameters:\n * state - an optional boolean which will set whether or not the Preferences panel should display in dark mode.\n\nReturns:\n * A boolean, true if dark mode is enabled otherwise false."
    },
    "Prints formatted strings to the Console": {
        "prefix": "hs.printf(format, ...)",
        "body": "hs.printf(${1:format}, ${2:...})",
        "description": "Prints formatted strings to the Console\n\nParameters:\n * format - A format string\n * ... - Zero or more arguments to fill the placeholders in the format string\n\nReturns:\n * None\n\nNotes:\n * This is a simple wrapper around the Lua code `print(string.format(...))`."
    },
    "A table containing read-only information about the Hammerspoon application instance currently running.": {
        "prefix": "hs.processInfo",
        "body": "hs.processInfo",
        "description": "A table containing read-only information about the Hammerspoon application instance currently running."
    },
    "The original Lua print() function": {
        "prefix": "hs.rawprint(aString)",
        "body": "hs.rawprint(${1:aString})",
        "description": "The original Lua print() function\n\nParameters:\n * aString - A string to be printed\n\nReturns:\n * None\n\nNotes:\n * Hammerspoon overrides Lua's print() function, but this is a reference we retain to is, should you need it for any reason"
    },
    "Quits and relaunches Hammerspoon.": {
        "prefix": "hs.relaunch()",
        "body": "hs.relaunch()",
        "description": "Quits and relaunches Hammerspoon.\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Reloads your init-file in a fresh Lua environment.": {
        "prefix": "hs.reload()",
        "body": "hs.reload()",
        "description": "Reloads your init-file in a fresh Lua environment."
    },
    "Checks the Screen Recording Permissions for Hammerspoon, and optionally allows you to prompt for permissions.": {
        "prefix": "hs.screenRecordingState(shouldPrompt) -> isEnabled",
        "body": "hs.screenRecordingState(${1:shouldPrompt})",
        "description": "Checks the Screen Recording Permissions for Hammerspoon, and optionally allows you to prompt for permissions.\n\nParameters:\n * shouldPrompt - an optional boolean value indicating if the dialog box asking if the System Preferences application should be opened should be presented when Screen Recording is not currently enabled for Hammerspoon.  Defaults to false.\n\nReturns:\n * True or False indicating whether or not Screen Recording is enabled for Hammerspoon.\n\nNotes:\n * If you trigger the prompt and the user denies it, you cannot bring up the prompt again - the user must manually enable it in System Preferences."
    },
    "Shows an error to the user, using Hammerspoon's Console": {
        "prefix": "hs.showError(err)",
        "body": "hs.showError(${1:err})",
        "description": "Shows an error to the user, using Hammerspoon's Console\n\nParameters:\n * err - A string containing an error message\n\nReturns:\n * None\n\nNotes:\n * This function is called whenever an (uncaught) error occurs or is thrown (via `error()`)\n * The default implementation shows a notification, opens the Console, and prints the error message and stacktrace\n * You can override this function if you wish to route errors differently (e.g. for remote systems)"
    },
    "An optional function that will be called when the Lua environment is being destroyed (either because Hammerspoon is exiting or reloading its config)": {
        "prefix": "hs.shutdownCallback",
        "body": "hs.shutdownCallback",
        "description": "An optional function that will be called when the Lua environment is being destroyed (either because Hammerspoon is exiting or reloading its config)\n\nNotes:\n * This function should not perform any asynchronous tasks\n * You do not need to fastidiously destroy objects you have created, this callback exists purely for utility reasons (e.g. serialising state, destroying system resources that will not be released by normal Lua garbage collection processes, etc)"
    },
    "An optional function that will be called when text is dragged to the Hammerspoon Dock Icon or sent via the Services menu": {
        "prefix": "hs.textDroppedToDockIconCallback",
        "body": "hs.textDroppedToDockIconCallback",
        "description": "An optional function that will be called when text is dragged to the Hammerspoon Dock Icon or sent via the Services menu\n\nNotes:\n * The function should accept a single parameter, which will be a string containing the text that was dragged to the dock icon"
    },
    "Toggles the visibility of the console": {
        "prefix": "hs.toggleConsole()",
        "body": "hs.toggleConsole()",
        "description": "Toggles the visibility of the console\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * If the console is not currently open, it will be opened. If it is open and not the focused window, it will be brought forward and focused.\n * If the console is focused, it will be closed."
    },
    "Gets the version & build number of an available update": {
        "prefix": "hs.updateAvailable() -> string or false, string",
        "body": "hs.updateAvailable()",
        "description": "Gets the version & build number of an available update\n\nParameters:\n * None\n\nReturns:\n * A string containing the display version of the latest release, or a boolean false if no update is available\n * A string containing the build number of the latest release, or `nil` if no update is available\n\nNotes:\n * This is not a live check, it is a cached result of whatever the previous update check found. By default Hammerspoon checks for updates every few hours, but you can also add your own timer to check for updates more frequently with `hs.checkForUpdates()`"
    },
    "Get or set the \"Upload Crash Data\" preference for Hammerspoon": {
        "prefix": "hs.uploadCrashData([state]) -> bool",
        "body": "hs.uploadCrashData(${1:[state]})",
        "description": "Get or set the \"Upload Crash Data\" preference for Hammerspoon\n\nParameters:\n * state - An optional boolean, true to upload crash reports, false to not\n\nReturns:\n * True if Hammerspoon is currently (or has just been) set to upload crash data or False otherwise\n\nNotes:\n * If at all possible, please do allow Hammerspoon to upload crash reports to us, it helps a great deal in keeping Hammerspoon stable\n * Our Privacy Policy can be found here: [https://www.hammerspoon.org/privacy.html](https://www.hammerspoon.org/privacy.html)"
    },
    "Closes all alerts currently open on the screen": {
        "prefix": "hs.alert.closeAll([seconds])",
        "body": "hs.alert.closeAll(${1:[seconds]})",
        "description": "Closes all alerts currently open on the screen\n\nParameters:\n * seconds - Optional number specifying the fade out duration. Defaults to `fadeOutDuration` value currently defined in the [hs.alert.defaultStyle](#defaultStyle)\n\nReturns:\n * None"
    },
    "Closes the alert with the specified identifier": {
        "prefix": "hs.alert.closeSpecific(uuid, [seconds])",
        "body": "hs.alert.closeSpecific(${1:uuid}, ${2:[seconds]})",
        "description": "Closes the alert with the specified identifier\n\nParameters:\n * uuid    - the identifier of the alert to close\n * seconds - Optional number specifying the fade out duration. Defaults to `fadeOutDuration` value currently defined in the [hs.alert.defaultStyle](#defaultStyle)\n\nReturns:\n * None\n\nNotes:\n * Use this function to close an alert which is indefinate or close an alert with a long duration early."
    },
    "A table defining the default visual style for the alerts generated by this module.": {
        "prefix": "hs.alert.defaultStyle[]",
        "body": "hs.alert.defaultStyle",
        "description": "A table defining the default visual style for the alerts generated by this module.\n\nThe following may be specified in this table (any other key is ignored):\n * Keys which affect the alert rectangle:\n   * fillColor   - a table as defined by the `hs.drawing.color` module to specify the background color for the alert, defaults to { white = 0, alpha = 0.75 }.\n   * strokeColor - a table as defined by the `hs.drawing.color` module to specify the outline color for the alert, defaults to { white = 1, alpha = 1 }.\n   * strokeWidth - a number specifying the width of the outline for the alert, defaults to 2\n   * radius      - a number specifying the radius used for the rounded corners of the alert box, defaults to 27\n\n * Keys which affect the text of the alert when the message is a string (note that these keys will be ignored if the message being displayed is already an `hs.styledtext` object):\n   * textColor   - a table as defined by the `hs.drawing.color` module to specify the message text color for the alert, defaults to { white = 1, alpha = 1 }.\n   * textFont    - a string specifying the font to be used for the alert text, defaults to \".AppleSystemUIFont\" which is a symbolic name representing the systems default user interface font.\n   * textSize    - a number specifying the font size to be used for the alert text, defaults to 27.\n   * textStyle   - an optional table, defaults to `nil`, specifying that a string message should be converted to an `hs.styledtext` object using the style elements specified in this table.  This table should conform to the key-value pairs as described in the documentation for the `hs.styledtext` module.  If this table does not contain a `font` key-value pair, one will be constructed from the `textFont` and `textSize` keys (or their defaults); likewise, if this table does not contain a `color` key-value pair, one will be constructed from the `textColor` key (or its default).\n   * atScreenEdge   - 0: screen center (default); 1: top edge; 2: bottom edge . Note when atScreenEdge>0, the latest alert will overlay above the previous ones if multiple alerts visible on same edge; and when atScreenEdge=0, latest alert will show below previous visible ones without overlap.\n   * fadeInDuration  - a number in seconds specifying the fade in duration of the alert, defaults to 0.15\n   * fadeOutDuration - a number in seconds specifying the fade out duration of the alert, defaults to 0.15\n\nIf you modify these values directly, it will affect all future alerts generated by this module.  To adjust one of these properties for a single alert, use the optional `style` argument to the [hs.alert.show](#show) function."
    },
    "Shows a message in large words briefly in the middle of the screen; does tostring() on its argument for convenience.": {
        "prefix": "hs.alert.show(str, [style], [screen], [seconds]) -> uuid",
        "body": "hs.alert.show(${1:str}, ${2:[style]}, ${3:[screen]}, ${4:[seconds]})",
        "description": "Shows a message in large words briefly in the middle of the screen; does tostring() on its argument for convenience.\n\nNOTE: For convenience, you can call this function as `hs.alert(...)`\n\nParameters:\n * str     - The string or `hs.styledtext` object to display in the alert\n * style   - an optional table containing one or more of the keys specified in [hs.alert.defaultStyle](#defaultStyle).  If `str` is already an `hs.styledtext` object, this argument is ignored.\n * screen  - an optional `hs.screen` userdata object specifying the screen (monitor) to display the alert on.  Defaults to `hs.screen.mainScreen()` which corresponds to the screen with the currently focused window.\n * seconds - The number of seconds to display the alert. Defaults to 2.  If seconds is specified and is not a number, displays the alert indefinately.\n\nReturns:\n * a string identifier for the alert.\n\nNotes:\n * The optional parameters are parsed in the order presented as follows:\n   * if the argument is a table and `style` has not previously been set, then the table is assigned to `style`\n   * if the argument is a userdata and `screen` has not previously been set, then the userdata is assigned to `screen`\n   * if `duration` has not been set, then it is assigned the value of the argument\n   * if all of these conditions fail for a given argument, then an error is returned\n * The reason for this logic is to support the creation of persistent alerts as was previously handled by the module: If you specify a non-number value for `seconds` you will need to store the string identifier returned by this function so that you can close it manually with `hs.alert.closeSpecific` when the alert should be removed.\n * Any style element which is not specified in the `style` argument table will use the value currently defined in the [hs.alert.defaultStyle](#defaultStyle) table."
    },
    "Tries to activate the app (make its key window focused) and returns whether it succeeded; if allWindows is true, all windows of the application are brought forward as well.": {
        "prefix": "hs.application:activate([allWindows]) -> bool",
        "body": "hs.application:activate(${1:[allWindows]})",
        "description": "Tries to activate the app (make its key window focused) and returns whether it succeeded; if allWindows is true, all windows of the application are brought forward as well.\n\nParameters:\n * allWindows - If true, all windows of the application will be brought to the front. Otherwise, only the application's key window will. Defaults to false.\n\nReturns:\n * A boolean value indicating whether or not the application could be activated"
    },
    "Returns all open windows owned by the given app.": {
        "prefix": "hs.application:allWindows() -> list of hs.window objects",
        "body": "hs.application:allWindows()",
        "description": "Returns all open windows owned by the given app.\n\nParameters:\n * None\n\nReturns:\n * A table of zero or more hs.window objects owned by the application\n\nNotes:\n * This function can only return windows in the current Mission Control Space; if you need to address windows across\n   different Spaces you can use the `hs.window.filter` module\n   - if `Displays have separate Spaces` is *on* (in System Preferences>Mission Control) the current Space is defined\n     as the union of all currently visible Spaces\n   - minimized windows and hidden windows (i.e. belonging to hidden apps, e.g. via cmd-h) are always considered\n     to be in the current Space"
    },
    "Returns the running app for the given pid, if it exists.": {
        "prefix": "hs.application.applicationForPID(pid) -> hs.application object or nil",
        "body": "hs.application.applicationForPID(${1:pid})",
        "description": "Returns the running app for the given pid, if it exists.\n\nParameters:\n * pid - a UNIX process id (i.e. a number)\n\nReturns:\n * An hs.application object if one can be found, otherwise nil"
    },
    "Returns any running apps that have the given bundleID.": {
        "prefix": "hs.application.applicationsForBundleID(bundleID) -> list of hs.application objects",
        "body": "hs.application.applicationsForBundleID(${1:bundleID})",
        "description": "Returns any running apps that have the given bundleID.\n\nParameters:\n * bundleID - An OSX application bundle indentifier\n\nReturns:\n * A table of zero or more hs.application objects that match the given identifier"
    },
    "Returns the bundle identifier of the app.": {
        "prefix": "hs.application:bundleID() -> string",
        "body": "hs.application:bundleID()",
        "description": "Returns the bundle identifier of the app.\n\nParameters:\n * None\n\nReturns:\n * A string containing the bundle identifier of the application"
    },
    "Returns the bundle ID of the default application for a given UTI": {
        "prefix": "hs.application.defaultAppForUTI(uti) -> string or nil",
        "body": "hs.application.defaultAppForUTI(${1:uti})",
        "description": "Returns the bundle ID of the default application for a given UTI\n\nParameters:\n * uti - A string containing a UTI\n\nReturns:\n * A string containing a bundle ID, or nil if none could be found"
    },
    "Get or set whether Spotlight should be used to find alternate names for applications.": {
        "prefix": "hs.application.enableSpotlightForNameSearches([state]) -> boolean",
        "body": "hs.application.enableSpotlightForNameSearches(${1:[state]})",
        "description": "Get or set whether Spotlight should be used to find alternate names for applications.\n\nParameters:\n * `state` - an optional boolean specifying whether or not Spotlight should be used to try and determine alternate application names for `hs.application.find` and similar functions.\n\nReturns:\n * the current, possibly changed, state\n\nNotes:\n * This setting is persistent across reloading and restarting Hammerspoon.\n * If this was set to true and you set it to true again, it will purge the alternate name map and rebuild it from scratch.\n * You can disable Spotlight alternate name mapping by setting this value to false or nil. If you set this to false, then the notifications indicating that more results might be possible if Spotlight is enabled will be suppressed."
    },
    "Finds running applications": {
        "prefix": "hs.application.find(hint) -> hs.application object(s)",
        "body": "hs.application.find(${1:hint})",
        "description": "Finds running applications\n\nParameters:\n * hint - search criterion for the desired application(s); it can be:\n   - a pid number as per `hs.application:pid()`\n   - a bundle ID string as per `hs.application:bundleID()`\n   - a string pattern that matches (via `string.find`) the application name as per `hs.application:name()` (for convenience, the matching will be done on lowercased strings)\n   - a string pattern that matches (via `string.find`) the application's window title per `hs.window:title()` (for convenience, the matching will be done on lowercased strings)\n\nReturns:\n * one or more hs.application objects for running applications that match the supplied search criterion, or `nil` if none found\n\nNotes:\n * If multiple results are found, this function will return multiple values. See [https://www.lua.org/pil/5.1.html](https://www.lua.org/pil/5.1.html) for more information on how to work with this\n * for convenience you can call this as `hs.application(hint)`\n * use this function when you don't know the exact name of an application you're interested in, i.e.\n   from the console: `hs.application'term' --> hs.application: iTerm2 (0x61000025fb88)  hs.application: Terminal (0x618000447588)`.\n   But be careful when using it in your `init.lua`: `terminal=hs.application'term'` will assign either \"Terminal\" or \"iTerm2\" arbitrarily (or even,\n   if neither are running, any other app with a window that happens to have \"term\" in its title); to make sure you get the right app in your scripts,\n   use `hs.application.get` with the exact name: `terminal=hs.application.get'Terminal' --> \"Terminal\" app, or nil if it's not running`\n\nUsage:\n-- by pid\nhs.application(42):name() --> Finder\n-- by bundle id\nhs.application'com.apple.Safari':name() --> Safari\n-- by name\nhs.application'chrome':name() --> Google Chrome\n-- by window title\nhs.application'bash':name() --> Terminal"
    },
    "Searches the application for a menu item": {
        "prefix": "hs.application:findMenuItem(menuItem[, isRegex]) -> table or nil",
        "body": "hs.application:findMenuItem(${1:menuItem[}, ${2:isRegex]})",
        "description": "Searches the application for a menu item\n\nParameters:\n * menuItem - This can either be a string containing the text of a menu item (e.g. `\"Messages\"`) or a table representing the hierarchical path of a menu item (e.g. `{\"File\", \"Share\", \"Messages\"}`). In the string case, all of the application's menus will be searched until a match is found (with no specified behaviour if multiple menu items exist with the same name). In the table case, the whole menu structure will not be searched, because a precise path has been specified.\n * isRegex - An optional boolean, defaulting to false, which is only used if `menuItem` is a string. If set to true, `menuItem` will be treated as a regular expression rather than a strict string to match against\n\nReturns:\n * Returns nil if the menu item cannot be found. If it does exist, returns a table with two keys:\n  * enabled - whether the menu item can be selected/ticked. This will always be false if the application is not currently focussed\n  * ticked - whether the menu item is ticked or not (obviously this value is meaningless for menu items that can't be ticked)\n\nNotes:\n * This can only search for menu items that don't have children - i.e. you can't search for the name of a submenu"
    },
    "Finds windows from this application": {
        "prefix": "hs.application:findWindow(titlePattern) -> hs.window object(s)",
        "body": "hs.application:findWindow(${1:titlePattern})",
        "description": "Finds windows from this application\n\nParameters:\n * titlePattern - a string pattern that matches (via `string.find`) the window title(s) as per `hs.window:title()` (for convenience, the matching will be done on lowercased strings)\n\nReturns:\n * one or more hs.window objects belonging to this application that match the supplied search criterion, or `nil` if none found"
    },
    "Returns the currently focused window of the application, or nil": {
        "prefix": "hs.application:focusedWindow() -> hs.window object or nil",
        "body": "hs.application:focusedWindow()",
        "description": "Returns the currently focused window of the application, or nil\n\nParameters:\n * None\n\nReturns:\n * An hs.window object representing the window of the application that currently has focus, or nil if there are none"
    },
    "Returns the application object for the frontmost (active) application.  This is the application which currently receives input events.": {
        "prefix": "hs.application.frontmostApplication() -> hs.application object",
        "body": "hs.application.frontmostApplication()",
        "description": "Returns the application object for the frontmost (active) application.  This is the application which currently receives input events.\n\nParameters:\n * None\n\nReturns:\n * An hs.application object"
    },
    "Gets a running application": {
        "prefix": "hs.application.get(hint) -> hs.application object",
        "body": "hs.application.get(${1:hint})",
        "description": "Gets a running application\n\nParameters:\n * hint - search criterion for the desired application; it can be:\n   - a pid number as per `hs.application:pid()`\n   - a bundle ID string as per `hs.application:bundleID()`\n   - an application name string as per `hs.application:name()`\n\nReturns:\n * an hs.application object for a running application that matches the supplied search criterion, or `nil` if not found\n\nNotes:\n * see also `hs.application.find`"
    },
    "Gets the menu structure of the application": {
        "prefix": "hs.application:getMenuItems([fn]) -> table or nil | hs.application object",
        "body": "hs.application:getMenuItems(${1:[fn]})",
        "description": "Gets the menu structure of the application\n\nParameters:\n * fn - an optional callback function.  If provided, the function will receive a single argument and return none.\n\nReturns:\n * If no argument is provided, returns a table containing the menu structure of the application, or nil if an error occurred. If a callback function is provided, the callback function will receive this table (or nil) and this method will return the application object this method was invoked on.\n\nNotes:\n * In some applications, this can take a little while to complete, because quite a large number of round trips are required to the source application, to get the information. When this method is invoked without a callback function, Hammerspoon will block while creating the menu structure table.  When invoked with a callback function, the menu structure is built in a background thread.\n\n * The table is nested with the same structure as the menus of the application. Each item has several keys containing information about the menu item. Not all keys will appear for all items. The possible keys are:\n  * AXTitle - A string containing the text of the menu item (entries which have no title are menu separators)\n  * AXEnabled - A boolean, 1 if the menu item is clickable, 0 if not\n  * AXRole - A string containing the role of the menu item - this will be either AXMenuBarItem for a top level menu, or AXMenuItem for an item in a menu\n  * AXMenuItemMarkChar - A string containing the \"mark\" character for a menu item. This is for toggleable menu items and will usually be an empty string or a Unicode tick character (\u2713)\n  * AXMenuItemCmdModifiers - A table containing string representations of the keyboard modifiers for the menu item's keyboard shortcut, or nil if no modifiers are present\n  * AXMenuItemCmdChar - A string containing the key for the menu item's keyboard shortcut, or an empty string if no shortcut is present\n  * AXMenuItemCmdGlyph - An integer, corresponding to one of the defined glyphs in `hs.application.menuGlyphs` if the keyboard shortcut is a special character usually represented by a pictorial representation (think arrow keys, return, etc), or an empty string if no glyph is used in presenting the keyboard shortcut.\n * Using `hs.inspect()` on these tables, while useful for exploration, can be extremely slow, taking several minutes to correctly render very complex menus"
    },
    "Gets a specific window from this application": {
        "prefix": "hs.application:getWindow(title) -> hs.window object",
        "body": "hs.application:getWindow(${1:title})",
        "description": "Gets a specific window from this application\n\nParameters:\n * title - the desired window's title string as per `hs.window:title()`\n\nReturns:\n * the desired hs.window object belonging to this application, or `nil` if not found"
    },
    "Hides the app (and all its windows).": {
        "prefix": "hs.application:hide() -> boolean",
        "body": "hs.application:hide()",
        "description": "Hides the app (and all its windows).\n\nParameters:\n * None\n\nReturns:\n * A boolean indicating whether the application was successfully hidden"
    },
    "Gets the metadata of an application from its bundle identifier": {
        "prefix": "hs.application.infoForBundleID(bundleID) -> table or nil",
        "body": "hs.application.infoForBundleID(${1:bundleID})",
        "description": "Gets the metadata of an application from its bundle identifier\n\nParameters:\n * bundleID - A string containing an application bundle identifier (e.g. \"com.apple.Safari\")\n\nReturns:\n * A table containing information about the application, or nil if the bundle identifier could not be located"
    },
    "Gets the metadata of an application from its path on disk": {
        "prefix": "hs.application.infoForBundlePath(bundlePath) -> table or nil",
        "body": "hs.application.infoForBundlePath(${1:bundlePath})",
        "description": "Gets the metadata of an application from its path on disk\n\nParameters:\n * bundlePath - A string containing the path to an application bundle (e.g. \"/Applications/Safari.app\")\n\nReturns:\n * A table containing information about the application, or nil if the bundle could not be located"
    },
    "Returns whether the app is the frontmost (i.e. is the currently active application)": {
        "prefix": "hs.application:isFrontmost() -> boolean",
        "body": "hs.application:isFrontmost()",
        "description": "Returns whether the app is the frontmost (i.e. is the currently active application)\n\nParameters:\n * None\n\nReturns:\n * True if the application is the frontmost application, otherwise false"
    },
    "Returns whether the app is currently hidden.": {
        "prefix": "hs.application:isHidden() -> boolean",
        "body": "hs.application:isHidden()",
        "description": "Returns whether the app is currently hidden.\n\nParameters:\n * None\n\nReturns:\n * A boolean indicating whether the application is hidden or not"
    },
    "Checks if the application is still running": {
        "prefix": "hs.application:isRunning() -> boolean",
        "body": "hs.application:isRunning()",
        "description": "Checks if the application is still running\n\nParameters:\n * None\n\nReturns:\n * A boolean, true if the application is running, false if not\n\nNotes:\n * If an application is terminated and re-launched, this method will still return false, as `hs.application` objects are tied to a specific instance of an application (i.e. its PID)"
    },
    "Tries to terminate the app gracefully.": {
        "prefix": "hs.application:kill()",
        "body": "hs.application:kill()",
        "description": "Tries to terminate the app gracefully.\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Tries to terminate the app forcefully.": {
        "prefix": "hs.application:kill9()",
        "body": "hs.application:kill9()",
        "description": "Tries to terminate the app forcefully.\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Identify the application's GUI state": {
        "prefix": "hs.application:kind() -> number",
        "body": "hs.application:kind()",
        "description": "Identify the application's GUI state\n\nParameters:\n * None\n\nReturns:\n * A number that is either 1 if the app is in the dock, 0 if it is not, or -1 if the application is prohibited from having GUI elements"
    },
    "Launches the app with the given name, or activates it if it's already running": {
        "prefix": "hs.application.launchOrFocus(name) -> boolean",
        "body": "hs.application.launchOrFocus(${1:name})",
        "description": "Launches the app with the given name, or activates it if it's already running\n\nParameters:\n * name - A string containing the name of the application to either launch or focus. This can also be the full path to an application (including the `.app` suffix) if you need to uniquely distinguish between applications in different locations that share the same name\n\nReturns:\n * True if the application was either launched or focused, otherwise false (e.g. if the application doesn't exist)\n\nNotes:\n * The name parameter should match the name of the application on disk, e.g. \"IntelliJ IDEA\", rather than \"IntelliJ\""
    },
    "Launches the app with the given bundle ID, or activates it if it's already running": {
        "prefix": "hs.application.launchOrFocusByBundleID(bundleID) -> boolean",
        "body": "hs.application.launchOrFocusByBundleID(${1:bundleID})",
        "description": "Launches the app with the given bundle ID, or activates it if it's already running\n\nParameters:\n * bundleID - A string containing the bundle ID of the application to either launch or focus.\n\nReturns:\n * True if the application was either launched or focused, otherwise false (e.g. if the application doesn't exist)\n\nNotes:\n * Bundle identifiers typically take the form of `com.company.ApplicationName`"
    },
    "Returns the main window of the given app, or nil.": {
        "prefix": "hs.application:mainWindow() -> hs.window object or nil",
        "body": "hs.application:mainWindow()",
        "description": "Returns the main window of the given app, or nil.\n\nParameters:\n * None\n\nReturns:\n * An hs.window object representing the main window of the application, or nil if it has no windows"
    },
    "A table containing UTF8 representations of the defined key glyphs used in Menus for keybaord shortcuts which are presented pictorially rather than as text (arrow keys, return key, etc.)": {
        "prefix": "hs.application.menuGlyphs",
        "body": "hs.application.menuGlyphs",
        "description": "A table containing UTF8 representations of the defined key glyphs used in Menus for keybaord shortcuts which are presented pictorially rather than as text (arrow keys, return key, etc.)\n\nThese glyphs are indexed numerically where the numeric index matches a possible value for the AXMenuItemCmdGlyph key of an entry returned by `hs.application.getMenus`.  If the AXMenuItemCmdGlyph field is non-numeric, then no glyph is used in the presentation of the keyboard shortcut for a menu item.\n\nThe following glyphs are defined:\n * \"\u21e5\",  -- kMenuTabRightGlyph, 0x02, Tab to the right key (for left-to-right script systems)\n * \"\u21e4\",  -- kMenuTabLeftGlyph, 0x03, Tab to the left key (for right-to-left script systems)\n * \"\u2324\",   -- kMenuEnterGlyph, 0x04, Enter key\n * \"\u21e7\",  -- kMenuShiftGlyph, 0x05, Shift key\n * \"\u2303\",   -- kMenuControlGlyph, 0x06, Control key\n * \"\u2325\",  -- kMenuOptionGlyph, 0x07, Option key\n * \"\u2423\",    -- kMenuSpaceGlyph, 0x09, Space (always glyph 3) key\n * \"\u2326\",  -- kMenuDeleteRightGlyph, 0x0A, Delete to the right key (for right-to-left script systems)\n * \"\u21a9\",  -- kMenuReturnGlyph, 0x0B, Return key (for left-to-right script systems)\n * \"\u21aa\",  -- kMenuReturnR2LGlyph, 0x0C, Return key (for right-to-left script systems)\n * \"\uf802\",   -- kMenuPencilGlyph, 0x0F, Pencil key\n * \"\u2193\",   -- kMenuDownwardArrowDashedGlyph, 0x10, Downward dashed arrow key\n * \"\u2318\",  -- kMenuCommandGlyph, 0x11, Command key\n * \"\u2713\",   -- kMenuCheckmarkGlyph, 0x12, Checkmark key\n * \"\u20df\",   -- kMenuDiamondGlyph, 0x13, Diamond key\n * \"\uf8ff\",   -- kMenuAppleLogoFilledGlyph, 0x14, Apple logo key (filled)\n * \"\u232b\",  -- kMenuDeleteLeftGlyph, 0x17, Delete to the left key (for left-to-right script systems)\n * \"\u2190\",  -- kMenuLeftArrowDashedGlyph, 0x18, Leftward dashed arrow key\n * \"\u2191\",   -- kMenuUpArrowDashedGlyph, 0x19, Upward dashed arrow key\n * \"\u2192\",   -- kMenuRightArrowDashedGlyph, 0x1A, Rightward dashed arrow key\n * \"\u238b\",  -- kMenuEscapeGlyph, 0x1B, Escape key\n * \"\u2327\",  -- kMenuClearGlyph, 0x1C, Clear key\n * \"\u300e\",  -- kMenuLeftDoubleQuotesJapaneseGlyph, 0x1D, Unassigned (left double quotes in Japanese)\n * \"\u300f\",  -- kMenuRightDoubleQuotesJapaneseGlyph, 0x1E, Unassigned (right double quotes in Japanese)\n * \"\u2422\",   -- kMenuBlankGlyph, 0x61, Blank key\n * \"\u21de\",   -- kMenuPageUpGlyph, 0x62, Page up key\n * \"\u21ea\",  -- kMenuCapsLockGlyph, 0x63, Caps lock key\n * \"\u2190\",  -- kMenuLeftArrowGlyph, 0x64, Left arrow key\n * \"\u2192\",   -- kMenuRightArrowGlyph, 0x65, Right arrow key\n * \"\u2196\",  -- kMenuNorthwestArrowGlyph, 0x66, Northwest arrow key\n * \"\ufe56\",  -- kMenuHelpGlyph, 0x67, Help key\n * \"\u2191\",   -- kMenuUpArrowGlyph, 0x68, Up arrow key\n * \"\u2198\",  -- kMenuSoutheastArrowGlyph, 0x69, Southeast arrow key\n * \"\u2193\",   -- kMenuDownArrowGlyph, 0x6A, Down arrow key\n * \"\u21df\",   -- kMenuPageDownGlyph, 0x6B, Page down key\n * \"\uf803\",  -- kMenuContextualMenuGlyph, 0x6D, Contextual menu key\n * \"\u233d\",  -- kMenuPowerGlyph, 0x6E, Power key\n * \"F1\",  -- kMenuF1Glyph, 0x6F, F1 key\n * \"F2\",  -- kMenuF2Glyph, 0x70, F2 key\n * \"F3\",  -- kMenuF3Glyph, 0x71, F3 key\n * \"F4\",  -- kMenuF4Glyph, 0x72, F4 key\n * \"F5\",  -- kMenuF5Glyph, 0x73, F5 key\n * \"F6\",  -- kMenuF6Glyph, 0x74, F6 key\n * \"F7\",  -- kMenuF7Glyph, 0x75, F7 key\n * \"F8\",  -- kMenuF8Glyph, 0x76, F8 key\n * \"F9\",  -- kMenuF9Glyph, 0x77, F9 key\n * \"F10\", -- kMenuF10Glyph, 0x78, F10 key\n * \"F11\", -- kMenuF11Glyph, 0x79, F11 key\n * \"F12\", -- kMenuF12Glyph, 0x7A, F12 key\n * \"F13\", -- kMenuF13Glyph, 0x87, F13 key\n * \"F14\", -- kMenuF14Glyph, 0x88, F14 key\n * \"F15\", -- kMenuF15Glyph, 0x89, F15 key\n * \"\u2388\",  -- kMenuControlISOGlyph, 0x8A, Control key (ISO standard)\n * \"\u23cf\",   -- kMenuEjectGlyph, 0x8C, Eject key (available on Mac OS X 10.2 and later)\n * \"\u82f1\u6570\", -- kMenuEisuGlyph, 0x8D, Japanese eisu key (available in Mac OS X 10.4 and later)\n * \"\u304b\u306a\", -- kMenuKanaGlyph, 0x8E, Japanese kana key (available in Mac OS X 10.4 and later)\n * \"F16\", -- kMenuF16Glyph, 0x8F, F16 key (available in SnowLeopard and later)\n * \"F17\", -- kMenuF16Glyph, 0x90, F17 key (available in SnowLeopard and later)\n * \"F18\", -- kMenuF16Glyph, 0x91, F18 key (available in SnowLeopard and later)\n * \"F19\", -- kMenuF16Glyph, 0x92, F19 key (available in SnowLeopard and later)\n\nNotes:\n * a `__tostring` metamethod is provided for this table so you can view its current contents by typing `hs.application.menuGlyphs` into the Hammerspoon console.\n * This table is provided as a variable so that you can change any representation if you feel you know of a better or more appropriate one for you usage at runtime.\n\n * The glyphs provided are defined in the Carbon framework headers in the Menus.h file, located (as of 10.11) at /System/Library/Frameworks/Carbon.framework/Frameworks/HIToolbox.framework/Headers/Menus.h.\n * The following constants are defined in Menus.h, but do not seem to correspond to a visible UTF8 character or well defined representation that I could discover.  If you believe that you know of a (preferably sanctioned by Apple) proper visual representation, please submit an issue detailing it at the Hammerspoon repository on Github.\n   * kMenuNullGlyph, 0x00, Null (always glyph 1)\n   * kMenuNonmarkingReturnGlyph, 0x0D, Nonmarking return key\n   * kMenuParagraphKoreanGlyph, 0x15, Unassigned (paragraph in Korean)\n   * kMenuTrademarkJapaneseGlyph, 0x1F, Unassigned (trademark in Japanese)\n   * kMenuAppleLogoOutlineGlyph, 0x6C, Apple logo key (outline)"
    },
    "Alias for `hs.application:title()`": {
        "prefix": "hs.application:name()",
        "body": "hs.application:name()",
        "description": "Alias for `hs.application:title()`"
    },
    "Gets the name of an application from its bundle identifier": {
        "prefix": "hs.application.nameForBundleID(bundleID) -> string or nil",
        "body": "hs.application.nameForBundleID(${1:bundleID})",
        "description": "Gets the name of an application from its bundle identifier\n\nParameters:\n * bundleID - A string containing an application bundle identifier (e.g. \"com.apple.Safari\")\n\nReturns:\n * A string containing the application name, or nil if the bundle identifier could not be located"
    },
    "Launches an application, or activates it if it's already running": {
        "prefix": "hs.application.open(app[, wait, [waitForFirstWindow]]) -> hs.application object",
        "body": "hs.application.open(${1:app[}, ${2:wait}, ${3:[waitForFirstWindow]]})",
        "description": "Launches an application, or activates it if it's already running\n\nParameters:\n * app - a string describing the application to open; it can be:\n   - the application's name as per `hs.application:name()`\n   - the full path to an application on disk (including the `.app` suffix)\n   - the application's bundle ID as per `hs.application:bundleID()`\n * wait - (optional) the maximum number of seconds to wait for the app to be launched, if not already running; if omitted, defaults to 0;\n  if the app takes longer than this to launch, this function will return `nil`, but the app will still launch\n * waitForFirstWindow - (optional) if `true`, additionally wait until the app has spawned its first window (which usually takes a bit longer)\n\nReturns:\n * the `hs.application` object for the launched or activated application; `nil` if not found\n\nNotes:\n * the `wait` parameter will *block all Hammerspoon activity* in order to return the application object \"synchronously\"; only use it if you\n   a) have no time-critical event processing happening elsewhere in your `init.lua` and b) need to act on the application object, or on\n   its window(s), right away\n * when launching a \"windowless\" app (background daemon, menulet, etc.) make sure to omit `waitForFirstWindow`"
    },
    "Returns the filesystem path of the app.": {
        "prefix": "hs.application:path() -> string",
        "body": "hs.application:path()",
        "description": "Returns the filesystem path of the app.\n\nParameters:\n * None\n\nReturns:\n * A string containing the filesystem path of the application or nil if the path could not be determined (e.g. if the application has terminated)."
    },
    "Gets the filesystem path of an application from its bundle identifier": {
        "prefix": "hs.application.pathForBundleID(bundleID) -> string or nil",
        "body": "hs.application.pathForBundleID(${1:bundleID})",
        "description": "Gets the filesystem path of an application from its bundle identifier\n\nParameters:\n * bundleID - A string containing an application bundle identifier (e.g. \"com.apple.Safari\")\n\nReturns:\n * A string containing the app bundle's filesystem path, or nil if the bundle identifier could not be located"
    },
    "Returns the app's process identifier.": {
        "prefix": "hs.application:pid() -> number",
        "body": "hs.application:pid()",
        "description": "Returns the app's process identifier.\n\nParameters:\n * None\n\nReturns:\n * The UNIX process identifier of the application (i.e. a number)"
    },
    "Returns all running apps.": {
        "prefix": "hs.application.runningApplications() -> list of hs.application objects",
        "body": "hs.application.runningApplications()",
        "description": "Returns all running apps.\n\nParameters:\n * None\n\nReturns:\n * A table containing zero or more hs.application objects currently running on the system"
    },
    "Selects a menu item (i.e. simulates clicking on the menu item)": {
        "prefix": "hs.application:selectMenuItem(menuitem[, isRegex]) -> true or nil",
        "body": "hs.application:selectMenuItem(${1:menuitem[}, ${2:isRegex]})",
        "description": "Selects a menu item (i.e. simulates clicking on the menu item)\n\nParameters:\n * menuitem - The menu item to select, specified as either a string or a table. See the `menuitem` parameter of `hs.application:findMenuItem()` for more information.\n * isRegex - An optional boolean, defaulting to false, which is only used if `menuItem` is a string. If set to true, `menuItem` will be treated as a regular expression rather than a strict string to match against\n\nReturns:\n * True if the menu item was found and selected, or nil if it wasn't (e.g. because the menu item couldn't be found)\n\nNotes:\n * Depending on the type of menu item involved, this will either activate or tick/untick the menu item"
    },
    "Sets the app to the frontmost (i.e. currently active) application": {
        "prefix": "hs.application:setFrontmost([allWindows]) -> boolean",
        "body": "hs.application:setFrontmost(${1:[allWindows]})",
        "description": "Sets the app to the frontmost (i.e. currently active) application\n\nParameters:\n * allWindows - An optional boolean, true to bring all windows of the application to the front. Defaults to false\n\nReturns:\n * A boolean, true if the operation was successful, otherwise false"
    },
    "Returns the localized name of the app (in UTF8).": {
        "prefix": "hs.application:title() -> string",
        "body": "hs.application:title()",
        "description": "Returns the localized name of the app (in UTF8).\n\nParameters:\n * None\n\nReturns:\n * A string containing the name of the application"
    },
    "Unhides the app (and all its windows) if it's hidden.": {
        "prefix": "hs.application:unhide() -> boolean",
        "body": "hs.application:unhide()",
        "description": "Unhides the app (and all its windows) if it's hidden.\n\nParameters:\n * None\n\nReturns:\n * A boolean indicating whether the application was successfully unhidden"
    },
    "Returns only the app's windows that are visible.": {
        "prefix": "hs.application:visibleWindows() -> win[]",
        "body": "hs.application:visibleWindows()",
        "description": "Returns only the app's windows that are visible.\n\nParameters:\n * None\n\nReturns:\n * A table containing zero or more hs.window objects"
    },
    "An application has been activated (i.e. given keyboard/mouse focus)": {
        "prefix": "hs.application.watcher.activated",
        "body": "hs.application.watcher.activated",
        "description": "An application has been activated (i.e. given keyboard/mouse focus)"
    },
    "An application has been deactivated (i.e. lost keyboard/mouse focus)": {
        "prefix": "hs.application.watcher.deactivated",
        "body": "hs.application.watcher.deactivated",
        "description": "An application has been deactivated (i.e. lost keyboard/mouse focus)"
    },
    "An application has been hidden": {
        "prefix": "hs.application.watcher.hidden",
        "body": "hs.application.watcher.hidden",
        "description": "An application has been hidden"
    },
    "An application has been launched": {
        "prefix": "hs.application.watcher.launched",
        "body": "hs.application.watcher.launched",
        "description": "An application has been launched"
    },
    "An application is in the process of being launched": {
        "prefix": "hs.application.watcher.launching",
        "body": "hs.application.watcher.launching",
        "description": "An application is in the process of being launched"
    },
    "Creates an application event watcher": {
        "prefix": "hs.application.watcher.new(fn) -> watcher",
        "body": "hs.application.watcher.new(${1:fn})",
        "description": "Creates an application event watcher\n\nParameters:\n * fn - A function that will be called when application events happen. It should accept three parameters:\n  * A string containing the name of the application\n  * An event type (see the constants defined above)\n  * An `hs.application` object representing the application, or nil if the application couldn't be found\n\nReturns:\n * An `hs.application.watcher` object\n\nNotes:\n * If the function is called with an event type of `hs.application.watcher.terminated` then the application name parameter will be `nil` and the `hs.application` parameter, will only be useful for getting the UNIX process ID (i.e. the PID) of the application"
    },
    "Starts the application watcher": {
        "prefix": "hs.application.watcher:start()",
        "body": "hs.application.watcher:start()",
        "description": "Starts the application watcher\n\nParameters:\n * None\n\nReturns:\n * The `hs.application.watcher` object"
    },
    "Stops the application watcher": {
        "prefix": "hs.application.watcher:stop()",
        "body": "hs.application.watcher:stop()",
        "description": "Stops the application watcher\n\nParameters:\n * None\n\nReturns:\n * The `hs.application.watcher` object"
    },
    "An application has been terminated": {
        "prefix": "hs.application.watcher.terminated",
        "body": "hs.application.watcher.terminated",
        "description": "An application has been terminated"
    },
    "An application has been unhidden": {
        "prefix": "hs.application.watcher.unhidden",
        "body": "hs.application.watcher.unhidden",
        "description": "An application has been unhidden"
    },
    "Returns a list of all connected devices": {
        "prefix": "hs.audiodevice.allDevices() -> hs.audiodevice[]",
        "body": "hs.audiodevice.allDevices()",
        "description": "Returns a list of all connected devices\n\nParameters:\n * None\n\nReturns:\n * A table of zero or more audio devices connected to the system"
    },
    "Gets all of the input data sources of an audio device": {
        "prefix": "hs.audiodevice:allInputDataSources() -> hs.audiodevice.dataSource[] or nil",
        "body": "hs.audiodevice:allInputDataSources()",
        "description": "Gets all of the input data sources of an audio device\n\nParameters:\n * None\n\nReturns:\n * A list of hs.audiodevice.dataSource objects, or nil if an error occurred"
    },
    "Returns a list of all connected input devices.": {
        "prefix": "hs.audiodevice.allInputDevices() -> audio[]",
        "body": "hs.audiodevice.allInputDevices()",
        "description": "Returns a list of all connected input devices.\n\nParameters:\n * None\n\nReturns:\n * A table of zero or more audio input devices connected to the system"
    },
    "Gets all of the output data sources of an audio device": {
        "prefix": "hs.audiodevice:allOutputDataSources() -> hs.audiodevice.dataSource[] or nil",
        "body": "hs.audiodevice:allOutputDataSources()",
        "description": "Gets all of the output data sources of an audio device\n\nParameters:\n * None\n\nReturns:\n * A list of hs.audiodevice.dataSource objects, or nil if an error occurred"
    },
    "Returns a list of all connected output devices": {
        "prefix": "hs.audiodevice.allOutputDevices() -> hs.audiodevice[]",
        "body": "hs.audiodevice.allOutputDevices()",
        "description": "Returns a list of all connected output devices\n\nParameters:\n * None\n\nReturns:\n * A table of zero or more audio output devices connected to the system"
    },
    "Get the current left/right balance of this audio device": {
        "prefix": "hs.audiodevice:balance() -> number or nil",
        "body": "hs.audiodevice:balance()",
        "description": "Get the current left/right balance of this audio device\n\nParameters:\n * None\n\nReturns:\n * A number between 0.0 and 1.0, representing the balance (0.0 for full left, 1.0 for full right, 0.5 for center), or nil if the audio device does not support balance\n\nNotes:\n * The return value will be a floating point number\n * This method will inspect the device to determine if it is an input or output device, and return the appropriate volume. For devices that are both input and output devices, see `:inputVolume()` and `:outputVolume()`"
    },
    "Fetch various metadata about the current default audio devices": {
        "prefix": "hs.audiodevice.current([input]) -> table",
        "body": "hs.audiodevice.current(${1:[input]})",
        "description": "Fetch various metadata about the current default audio devices\n\nParameters:\n * output - An optional boolean, true to fetch information about the default input device, false for output device. Defaults to false\n\nReturns:\n * A table with the following contents:\n```lua\n    {\n        name = defaultOutputDevice():name(),\n        uid = module.defaultOutputDevice():uid(),\n        muted = defaultOutputDevice():muted(),\n        volume = defaultOutputDevice():volume(),\n        device = defaultOutputDevice(),\n    }\n```"
    },
    "Gets the current input data source of an audio device": {
        "prefix": "hs.audiodevice:currentInputDataSource() -> hs.audiodevice.dataSource object or nil",
        "body": "hs.audiodevice:currentInputDataSource()",
        "description": "Gets the current input data source of an audio device\n\nParameters:\n * None\n\nReturns:\n * An hs.audiodevice.dataSource object, or nil if an error occurred\n\nNotes:\n * Before calling this method, you should check the result of hs.audiodevice:supportsInputDataSources()"
    },
    "Gets the current output data source of an audio device": {
        "prefix": "hs.audiodevice:currentOutputDataSource() -> hs.audiodevice.dataSource object or nil",
        "body": "hs.audiodevice:currentOutputDataSource()",
        "description": "Gets the current output data source of an audio device\n\nParameters:\n * None\n\nReturns:\n * An hs.audiodevice.dataSource object, or nil if an error occurred\n\nNotes:\n * Before calling this method, you should check the result of hs.audiodevice:supportsOutputDataSources()"
    },
    "Get the currently selected audio input device": {
        "prefix": "hs.audiodevice.defaultInputDevice() -> audio or nil",
        "body": "hs.audiodevice.defaultInputDevice()",
        "description": "Get the currently selected audio input device\n\nParameters:\n * None\n\nReturns:\n * An hs.audiodevice object, or nil if no suitable device could be found"
    },
    "Get the currently selected audio output device": {
        "prefix": "hs.audiodevice.defaultOutputDevice() -> audio or nil",
        "body": "hs.audiodevice.defaultOutputDevice()",
        "description": "Get the currently selected audio output device\n\nParameters:\n * None\n\nReturns:\n * An hs.audiodevice object, or nil if no suitable device could be found"
    },
    "Find an audio device by name": {
        "prefix": "hs.audiodevice.findDeviceByName(name) -> device or nil",
        "body": "hs.audiodevice.findDeviceByName(${1:name})",
        "description": "Find an audio device by name\n\nParameters:\n * name - A string containing the name of an audio device to search for\n\nReturns:\n * An `hs.audiodevice` object or nil if the device could not be found"
    },
    "Find an audio device by UID": {
        "prefix": "hs.audiodevice.findDeviceByUID(uid) -> device or nil",
        "body": "hs.audiodevice.findDeviceByUID(${1:uid})",
        "description": "Find an audio device by UID\n\nParameters:\n * uid - A string containing the UID of an audio device to search for\n\nReturns:\n * An `hs.audiodevice` object or nil if the device could not be found"
    },
    "Find an audio input device by name": {
        "prefix": "hs.audiodevice.findInputByName(name) -> device or nil",
        "body": "hs.audiodevice.findInputByName(${1:name})",
        "description": "Find an audio input device by name\n\nParameters:\n * name - A string containing the name of an audio input device to search for\n\nReturns:\n * An hs.audiodevice object or nil if the device could not be found"
    },
    "Find an audio input device by UID": {
        "prefix": "hs.audiodevice.findInputByUID(uid) -> device or nil",
        "body": "hs.audiodevice.findInputByUID(${1:uid})",
        "description": "Find an audio input device by UID\n\nParameters:\n * name - A string containing the UID of an audio input device to search for\n\nReturns:\n * An hs.audiodevice object or nil if the device could not be found"
    },
    "Find an audio output device by name": {
        "prefix": "hs.audiodevice.findOutputByName(name) -> device or nil",
        "body": "hs.audiodevice.findOutputByName(${1:name})",
        "description": "Find an audio output device by name\n\nParameters:\n * name - A string containing the name of an audio output device to search for\n\nReturns:\n * An hs.audiodevice object or nil if the device could not be found"
    },
    "Find an audio output device by UID": {
        "prefix": "hs.audiodevice.findOutputByUID(uid) -> device or nil",
        "body": "hs.audiodevice.findOutputByUID(${1:uid})",
        "description": "Find an audio output device by UID\n\nParameters:\n * name - A string containing the UID of an audio output device to search for\n\nReturns:\n * An hs.audiodevice object or nil if the device could not be found"
    },
    "Get the Input mutedness state of the audio device": {
        "prefix": "hs.audiodevice:inputMuted() -> bool or nil",
        "body": "hs.audiodevice:inputMuted()",
        "description": "Get the Input mutedness state of the audio device\n\nParameters:\n * None\n\nReturns:\n * True if the audio device's Input is muted. False if it's not muted, nil if it does not support muting"
    },
    "Get the current input volume of this audio device": {
        "prefix": "hs.audiodevice:inputVolume() -> number or nil",
        "body": "hs.audiodevice:inputVolume()",
        "description": "Get the current input volume of this audio device\n\nParameters:\n * None\n\nReturns:\n * A number between 0 and 100, representing the input volume percentage, or nil if the audio device does not support input volume levels\n\nNotes:\n * The return value will be a floating point number"
    },
    "Determins if an audio device is an input device": {
        "prefix": "hs.audiodevice:isInputDevice() -> boolean",
        "body": "hs.audiodevice:isInputDevice()",
        "description": "Determins if an audio device is an input device\n\nParameters:\n * None\n\nReturns:\n * A boolean, true if the device is an input device, false if not"
    },
    "Determins if an audio device is an output device": {
        "prefix": "hs.audiodevice:isOutputDevice() -> boolean",
        "body": "hs.audiodevice:isOutputDevice()",
        "description": "Determins if an audio device is an output device\n\nParameters:\n * None\n\nReturns:\n * A boolean, true if the device is an output device, false if not"
    },
    "Determines whether an audio jack (e.g. headphones) is connected to an audio device": {
        "prefix": "hs.audiodevice:jackConnected() -> boolean or nil",
        "body": "hs.audiodevice:jackConnected()",
        "description": "Determines whether an audio jack (e.g. headphones) is connected to an audio device\n\nParameters:\n * None\n\nReturns:\n * A boolean, true if a jack is connected, false if not, or nil if the device does not support jack sense"
    },
    "Get the mutedness state of the audio device": {
        "prefix": "hs.audiodevice:muted() -> bool or nil",
        "body": "hs.audiodevice:muted()",
        "description": "Get the mutedness state of the audio device\n\nParameters:\n * None\n\nReturns:\n * True if the audio device is muted, False if it is not muted, nil if it does not support muting\n\nNotes:\n * If a device is capable of both input and output, this method will prefer the output. See `:inputMuted()` and `:outputMuted()` for specific variants."
    },
    "Get the name of the audio device": {
        "prefix": "hs.audiodevice:name() -> string or nil",
        "body": "hs.audiodevice:name()",
        "description": "Get the name of the audio device\n\nParameters:\n * None\n\nReturns:\n * A string containing the name of the audio device, or nil if it has no name"
    },
    "Get the Output mutedness state of the audio device": {
        "prefix": "hs.audiodevice:outputMuted() -> bool or nil",
        "body": "hs.audiodevice:outputMuted()",
        "description": "Get the Output mutedness state of the audio device\n\nParameters:\n * None\n\nReturns:\n * True if the audio device's Output is muted. False if it's not muted, nil if it does not support muting"
    },
    "Get the current output volume of this audio device": {
        "prefix": "hs.audiodevice:outputVolume() -> number or nil",
        "body": "hs.audiodevice:outputVolume()",
        "description": "Get the current output volume of this audio device\n\nParameters:\n * None\n\nReturns:\n * A number between 0 and 100, representing the output volume percentage, or nil if the audio device does not support output volume levels\n\nNotes:\n * The return value will be a floating point number"
    },
    "Set the balance of this audio device": {
        "prefix": "hs.audiodevice:setBalance(level) -> bool",
        "body": "hs.audiodevice:setBalance(${1:level})",
        "description": "Set the balance of this audio device\n\nParameters:\n * level - A number between 0.0 and 1.0, representing the balance (0.0 for full left, 1.0 for full right, 0.5 for center)\n\nReturns:\n * True if the balance was set, false if the audio device does not support setting a balance.\n\nNotes:\n * This method will inspect the device to determine if it is an input or output device, and set the appropriate volume. For devices that are both input and output devices, see `:setInputVolume()` and `:setOutputVolume()`"
    },
    "Selects this device as the system's audio input device": {
        "prefix": "hs.audiodevice:setDefaultInputDevice() -> bool",
        "body": "hs.audiodevice:setDefaultInputDevice()",
        "description": "Selects this device as the system's audio input device\n\nParameters:\n * None\n\nReturns:\n * True if the audio device was successfully selected, otherwise false."
    },
    "Selects this device as the system's audio output device": {
        "prefix": "hs.audiodevice:setDefaultOutputDevice() -> bool",
        "body": "hs.audiodevice:setDefaultOutputDevice()",
        "description": "Selects this device as the system's audio output device\n\nParameters:\n * None\n\nReturns:\n * True if the audio device was successfully selected, otherwise false."
    },
    "Set the mutedness state of the Input of the audio device": {
        "prefix": "hs.audiodevice:setInputMuted(state) -> bool",
        "body": "hs.audiodevice:setInputMuted(${1:state})",
        "description": "Set the mutedness state of the Input of the audio device\n\nParameters:\n * state - A boolean value. True to mute the device, False to unmute it\n\nReturns:\n * True if the device's Input mutedness state was set, or False if it does not support muting"
    },
    "Set the input volume of this audio device": {
        "prefix": "hs.audiodevice:setInputVolume(level) -> bool",
        "body": "hs.audiodevice:setInputVolume(${1:level})",
        "description": "Set the input volume of this audio device\n\nParameters:\n * level - A number between 0 and 100, representing the input volume as a percentage\n\nReturns:\n * True if the volume was set, false if the audio device does not support setting an input volume level\n\nNotes:\n * The volume level is a floating point number. Depending on your audio hardware, it may not be possible to increase volume in single digit increments"
    },
    "Set the mutedness state of the audio device": {
        "prefix": "hs.audiodevice:setMuted(state) -> bool",
        "body": "hs.audiodevice:setMuted(${1:state})",
        "description": "Set the mutedness state of the audio device\n\nParameters:\n * state - A boolean value. True to mute the device, False to unmute it\n\nReturns:\n * True if the device's mutedness state was set, or False if it does not support muting\n\nNotes:\n * If a device is capable of both input and output, this method will prefer the output. See `:inputSetMuted()` and `:outputSetMuted()` for specific variants."
    },
    "Set the mutedness state of the Output of the audio device": {
        "prefix": "hs.audiodevice:setOutputMuted(state) -> bool",
        "body": "hs.audiodevice:setOutputMuted(${1:state})",
        "description": "Set the mutedness state of the Output of the audio device\n\nParameters:\n * state - A boolean value. True to mute the device, False to unmute it\n\nReturns:\n * True if the device's Output mutedness state was set, or False if it does not support muting"
    },
    "Set the output volume of this audio device": {
        "prefix": "hs.audiodevice:setOutputVolume(level) -> bool",
        "body": "hs.audiodevice:setOutputVolume(${1:level})",
        "description": "Set the output volume of this audio device\n\nParameters:\n * level - A number between 0 and 100, representing the output volume as a percentage\n\nReturns:\n * True if the volume was set, false if the audio device does not support setting an output volume level\n\nNotes:\n * The volume level is a floating point number. Depending on your audio hardware, it may not be possible to increase volume in single digit increments"
    },
    "Set the volume of this audio device": {
        "prefix": "hs.audiodevice:setVolume(level) -> bool",
        "body": "hs.audiodevice:setVolume(${1:level})",
        "description": "Set the volume of this audio device\n\nParameters:\n * level - A number between 0 and 100, representing the volume as a percentage\n\nReturns:\n * True if the volume was set, false if the audio device does not support setting a volume level.\n\nNotes:\n * The volume level is a floating point number. Depending on your audio hardware, it may not be possible to increase volume in single digit increments.\n * This method will inspect the device to determine if it is an input or output device, and set the appropriate volume. For devices that are both input and output devices, see `:setInputVolume()` and `:setOutputVolume()`"
    },
    "Determines whether an audio device supports input data sources": {
        "prefix": "hs.audiodevice:supportsInputDataSources() -> boolean",
        "body": "hs.audiodevice:supportsInputDataSources()",
        "description": "Determines whether an audio device supports input data sources\n\nParameters:\n * None\n\nReturns:\n * A boolean, true if the device supports input data sources, false if not"
    },
    "Determines whether an audio device supports output data sources": {
        "prefix": "hs.audiodevice:supportsOutputDataSources() -> boolean",
        "body": "hs.audiodevice:supportsOutputDataSources()",
        "description": "Determines whether an audio device supports output data sources\n\nParameters:\n * None\n\nReturns:\n * A boolean, true if the device supports output data sources, false if not"
    },
    "Gets the hardware transport type of an audio device": {
        "prefix": "hs.audiodevice:transportType() -> string",
        "body": "hs.audiodevice:transportType()",
        "description": "Gets the hardware transport type of an audio device\n\nParameters:\n * None\n\nReturns:\n * A string containing the transport type, or nil if an error occurred"
    },
    "Get the unique identifier of the audio device": {
        "prefix": "hs.audiodevice:uid() -> string or nil",
        "body": "hs.audiodevice:uid()",
        "description": "Get the unique identifier of the audio device\n\nParameters:\n * None\n\nReturns:\n * A string containing the UID of the audio device, or nil if it has no UID."
    },
    "Get the current volume of this audio device": {
        "prefix": "hs.audiodevice:volume() -> number or nil",
        "body": "hs.audiodevice:volume()",
        "description": "Get the current volume of this audio device\n\nParameters:\n * None\n\nReturns:\n * A number between 0 and 100, representing the volume percentage, or nil if the audio device does not support volume levels\n\nNotes:\n * The return value will be a floating point number\n * This method will inspect the device to determine if it is an input or output device, and return the appropriate volume. For devices that are both input and output devices, see `:inputVolume()` and `:outputVolume()`"
    },
    "Sets or removes a callback function for an audio device watcher": {
        "prefix": "hs.audiodevice:watcherCallback(fn) -> hs.audiodevice",
        "body": "hs.audiodevice:watcherCallback(${1:fn})",
        "description": "Sets or removes a callback function for an audio device watcher\n\nParameters:\n * fn - A callback function that will be called when properties of this audio device change, or nil to remove an existing callback. The function should accept four arguments:\n  * A string containing the UID of the audio device (see `hs.audiodevice.findDeviceByUID()`)\n  * A string containing the name of the event. Possible values are:\n   * vmvc - Volume changed\n   * mute - Mute state changed\n   * jack - Jack sense state changed (usually this means headphones were plugged/unplugged)\n   * span - Stereo pan changed\n   * diff - Device configuration changed (if you are caching audio device properties, this event indicates you should flush your cache)\n  * A string containing the scope of the event. Possible values are:\n   * glob - This is a global event pertaining to the whole device\n   * inpt - This is an event pertaining only to the input functions of the device\n   * outp - This is an event pertaining only to the output functions of the device\n  * A number containing the element of the event. Typical values are:\n   * 0 - Typically this means the Master channel\n   * 1 - Typically this means the Left channel\n   * 2 - Typically this means the Right channel\n\nReturns:\n * The `hs.audiodevice` object\n\nNotes:\n * You will receive many events to your callback, so filtering on the name/scope/element arguments is vital. For example, on a stereo device, it is not uncommon to receive a `volm` event for each audio channel when the volume changes, or multiple `mute` events for channels. Dragging a volume slider in the system Sound preferences will produce a large number of `volm` events. Plugging/unplugging headphones may trigger `volm` events in addition to `jack` ones, etc.\n * If you need to use the `hs.audiodevice` object in your callback, use `hs.audiodevice.findDeviceByUID()` to obtain it fro the first callback argument"
    },
    "Gets the status of the `hs.audiodevice` object watcher": {
        "prefix": "hs.audiodevice:watcherIsRunning() -> boolean",
        "body": "hs.audiodevice:watcherIsRunning()",
        "description": "Gets the status of the `hs.audiodevice` object watcher\n\nParameters:\n * None\n\nReturns:\n * A boolean, true if the watcher is running, false if not"
    },
    "Starts the watcher on an `hs.audiodevice` object": {
        "prefix": "hs.audiodevice:watcherStart() -> hs.audiodevice or nil",
        "body": "hs.audiodevice:watcherStart()",
        "description": "Starts the watcher on an `hs.audiodevice` object\n\nParameters:\n * None\n\nReturns:\n * The `hs.audiodevice` object, or nil if an error occurred"
    },
    "Stops the watcher on an `hs.audiodevice` object": {
        "prefix": "hs.audiodevice:watcherStop() -> hs.audiodevice",
        "body": "hs.audiodevice:watcherStop()",
        "description": "Stops the watcher on an `hs.audiodevice` object\n\nParameters:\n * None\n\nReturns:\n * The `hs.audiodevice` object"
    },
    "Gets the name of an audio device datasource": {
        "prefix": "hs.audiodevice.datasource:name() -> string",
        "body": "hs.audiodevice.datasource:name()",
        "description": "Gets the name of an audio device datasource\n\nParameters:\n * None\n\nReturns:\n * A string containing the name of the datasource"
    },
    "Sets the audio device datasource as the default": {
        "prefix": "hs.audiodevice.datasource:setDefault() -> hs.audiodevice.datasource",
        "body": "hs.audiodevice.datasource:setDefault()",
        "description": "Sets the audio device datasource as the default\n\nParameters:\n * None\n\nReturns:\n * The `hs.audiodevice.datasource` object"
    },
    "Gets the status of the audio device watcher": {
        "prefix": "hs.audiodevice.watcher.isRunning() -> boolean",
        "body": "hs.audiodevice.watcher.isRunning()",
        "description": "Gets the status of the audio device watcher\n\nParameters:\n * None\n\nReturns:\n * A boolean, true if the watcher is running, false if not"
    },
    "Sets the callback function for the audio device watcher": {
        "prefix": "hs.audiodevice.watcher.setCallback(fn)",
        "body": "hs.audiodevice.watcher.setCallback(${1:fn})",
        "description": "Sets the callback function for the audio device watcher\n\nParameters:\n * fn - A callback function, or nil to remove a previously set callback. The callback function should accept a single argument (see Notes below)\n\nReturns:\n * None\n\nNotes:\n * This watcher will call the callback when various audio device related events occur (e.g. an audio device appears/disappears, a system default audio device setting changes, etc)\n * To watch for changes within an audio device, see `hs.audiodevice:newWatcher()`\n * The callback function argument is a string which may be one of the following strings, but might also be a different string entirely:\n  * dIn  - Default audio input device setting changed (Note that there is a space character after `dIn`, because these values always have to be four characters long)\n  * dOut - Default audio output device setting changed\n  * sOut - Default system audio output setting changed (i.e. the device that system sound effects use. This may also be triggered by dOut, depending on the user's settings)\n  * dev# - An audio device appeared or disappeared\n * The callback will be called for each individual audio device event received from the OS, so you may receive multiple events for a single physical action (e.g. unplugging the default audio device will cause `dOut` and `dev#` events, and possibly `sOut` too)\n * Passing nil will cause the watcher to stop if it is already running"
    },
    "Starts the audio device watcher": {
        "prefix": "hs.audiodevice.watcher.start()",
        "body": "hs.audiodevice.watcher.start()",
        "description": "Starts the audio device watcher\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Stops the audio device watcher": {
        "prefix": "hs.audiodevice.watcher.stop() -> hs.audiodevice.watcher",
        "body": "hs.audiodevice.watcher.stop()",
        "description": "Stops the audio device watcher\n\nParameters:\n * None\n\nReturns:\n * The `hs.audiodevice.watcher` object"
    },
    "Returns a localized description of the specified accessibility object's action.": {
        "prefix": "hs.axuielement:actionDescription(action) -> string | nil, errString",
        "body": "hs.axuielement:${1:action}Description(action)",
        "description": "Returns a localized description of the specified accessibility object's action.\n\nParameters:\n * `action` - the name of the action, as specified by [hs.axuielement:actionNames](#actionNames).\n\nReturns:\n * a string containing a description of the object's action, nil if no description is available, or nil and an error string if an accessibility error occurred\n\nNotes:\n * The action descriptions are provided by the target application; as such their accuracy and usefulness rely on the target application's developers."
    },
    "Returns a list of all the actions the specified accessibility object can perform.": {
        "prefix": "hs.axuielement:actionNames() -> table | nil, errString",
        "body": "hs.axuielement:actionNames()",
        "description": "Returns a list of all the actions the specified accessibility object can perform.\n\nParameters:\n * None\n\nReturns:\n * an array of the names of all actions supported by the axuielementObject or nil and an error string if an accessibility error occurred\n\nNotes:\n * Common action names can be found in the [hs.axuielement.actions](#actions) table; however, this method will list only those names which are supported by this object, and is not limited to just those in the referenced table."
    },
    "A table of common accessibility object action names, provided for reference.": {
        "prefix": "hs.axuielement.actions[]",
        "body": "hs.axuielement.actions",
        "description": "A table of common accessibility object action names, provided for reference.\n\nNotes:\n * this table is provided for reference only and is not intended to be comprehensive.\n * you can view the contents of this table from the Hammerspoon console by typing in `hs.axuielement.actions`"
    },
    "Returns a table containing key-value pairs for all attributes of the accessibility object.": {
        "prefix": "hs.axuielement:allAttributeValues([includeErrors]) -> table | nil, errString",
        "body": "hs.axuielement:allAttributeValues(${1:[includeErrors]})",
        "description": "Returns a table containing key-value pairs for all attributes of the accessibility object.\n\nParameters:\n * `includeErrors` - an optional boolean, default false, that specifies whether attribute names which generate an error when retrieved are included in the returned results.\n\nReturns:\n * a table with key-value pairs corresponding to the attributes of the accessibility object or nil and an error string if an accessibility error occurred\n\nNotes:\n * if `includeErrors` is not specified or is false, then attributes which exist for the element, but currently have no value assigned, will not appear in the table. This is because Lua treats a nil value for a table's key-value pair as an instruction to remove the key from the table, if it currently exists.\n * To include attributes which exist but are currently unset, you need to specify `includeErrors` as true.\n   * attributes for which no value is currently assigned will be given a table value with the following key-value pairs:\n     * `_code` = -25212\n     * `error` = \"Requested value does not exist\""
    },
    "Query the accessibility object for all child accessibility objects and their descendants": {
        "prefix": "hs.axuielement:allDescendantElements(callback, [withParents]) -> elementSearchObject",
        "body": "hs.axuielement:allDescendantElements(${1:callback}, ${2:[withParents]})",
        "description": "Query the accessibility object for all child accessibility objects and their descendants\n\nParameters:\n * `callback`    - a required function which should expect two arguments: a `msg` string specifying how the search ended, and a table containing the discovered descendant elements. `msg` will be \"completed\" when the traversal has completed normally and will contain a string starting with \"**\" if it terminates early for some reason (see Notes: section for more information)\n * `withParents` - an optional boolean, default false, indicating that the parent of objects (and their descendants) should be collected as well.\n\nReturns:\n * an elementSearchObject as described in [hs.axuielement:elementSearch](#elementSearch)\n\nNotes:\n * This method is syntactic sugar for `hs.axuielement:elementSearch(callback, { [includeParents = withParents] })`. Please refer to [hs.axuielement:elementSearch](#elementSearch) for details about the returned object and callback arguments."
    },
    "Returns the top-level accessibility object for the application specified by the `hs.application` object.": {
        "prefix": "hs.axuielement.applicationElement(applicationObject) -> axuielementObject",
        "body": "hs.axuielement.applicationElement(${1:applicationObject})",
        "description": "Returns the top-level accessibility object for the application specified by the `hs.application` object.\n\nParameters:\n * `applicationObject` - the `hs.application` object for the Application or a string or number which will be passed to `hs.application.find` to get an `hs.application` object.\n\nReturns:\n * an axuielementObject for the application specified\n\nNotes:\n * if `applicationObject` is a string or number, only the first item found with `hs.application.find` will be used by this function to create an axuielementObject."
    },
    "Returns the top-level accessibility object for the application with the specified process ID.": {
        "prefix": "hs.axuielement.applicationElementForPID(pid) -> axuielementObject",
        "body": "hs.axuielement.applicationElementForPID(${1:pid})",
        "description": "Returns the top-level accessibility object for the application with the specified process ID.\n\nParameters:\n * `pid` - the process ID of the application.\n\nReturns:\n * an axuielementObject for the application specified, or nil if it cannot be determined"
    },
    "If the element referes to an application, return an `hs.application` object for the element.": {
        "prefix": "hs.axuielement:asHSApplication() -> hs.application object | nil",
        "body": "hs.axuielement:asHSApplication()",
        "description": "If the element referes to an application, return an `hs.application` object for the element.\n\nParameters:\n * None\n\nReturns:\n * if the element refers to an application, return an `hs.application` object for the element ; otherwise return nil\n\nNotes:\n * An element is considered an application by this method if it has an AXRole of AXApplication and has a process identifier (pid)."
    },
    "If the element referes to a window, return an `hs.window` object for the element.": {
        "prefix": "hs.axuielement:asHSWindow() -> hs.window object | nil",
        "body": "hs.axuielement:asHSWindow()",
        "description": "If the element referes to a window, return an `hs.window` object for the element.\n\nParameters:\n * None\n\nReturns:\n * if the element refers to a window, return an `hs.window` object for the element ; otherwise return nil\n\nNotes:\n * An element is considered a window by this method if it has an AXRole of AXWindow."
    },
    "Returns a list of all the attributes supported by the specified accessibility object.": {
        "prefix": "hs.axuielement:attributeNames() -> table | nil, errString",
        "body": "hs.axuielement:attributeNames()",
        "description": "Returns a list of all the attributes supported by the specified accessibility object.\n\nParameters:\n * None\n\nReturns:\n * an array of the names of all attributes supported by the axuielementObject or nil and an error string if an accessibility error occurred\n\nNotes:\n * Common attribute names can be found in the [hs.axuielement.attributes](#attributes) tables; however, this method will list only those names which are supported by this object, and is not limited to just those in the referenced table."
    },
    "A table of common accessibility object attribute names which may be used with [hs.axuielement:elementSearch](#elementSearch) or [hs.axuielement:matchesCriteria](#matchesCriteria) as keys in the match criteria argument.": {
        "prefix": "hs.axuielement.attributes[]",
        "body": "hs.axuielement.attributes",
        "description": "A table of common accessibility object attribute names which may be used with [hs.axuielement:elementSearch](#elementSearch) or [hs.axuielement:matchesCriteria](#matchesCriteria) as keys in the match criteria argument.\n\nNotes:\n * This table is provided for reference only and is not intended to be comprehensive.\n * You can view the contents of this table from the Hammerspoon console by typing in `hs.axuielement.attributes`"
    },
    "Returns the value of an accessibility object's attribute.": {
        "prefix": "hs.axuielement:attributeValue(attribute) -> value | nil, errString",
        "body": "hs.axuielement:${1:attribute}Value(attribute)",
        "description": "Returns the value of an accessibility object's attribute.\n\nParameters:\n * `attribute` - the name of the attribute, as specified by [hs.axuielement:attributeNames](#attributeNames).\n\nReturns:\n * the current value of the attribute, nil if the attribute has no value, or nil and an error string if an accessibility error occurred"
    },
    "Returns the count of the array of an accessibility object's attribute value.": {
        "prefix": "hs.axuielement:attributeValueCount(attribute) -> integer | nil, errString",
        "body": "hs.axuielement:${1:attribute}ValueCount(attribute)",
        "description": "Returns the count of the array of an accessibility object's attribute value.\n\nParameters:\n * `attribute` - the name of the attribute, as specified by [hs.axuielement:attributeNames](#attributeNames).\n\nReturns:\n * the number of items in the value for the attribute, if it is an array, or nil and an error string if an accessibility error occurred"
    },
    "Captures all of the available information for the accessibility object and its descendants and returns it in a table for inspection.": {
        "prefix": "hs.axuielement:buildTree(callback, [depth], [withParents]) -> elementSearchObject",
        "body": "hs.axuielement:buildTree(${1:callback}, ${2:[depth]}, ${3:[withParents]})",
        "description": "Captures all of the available information for the accessibility object and its descendants and returns it in a table for inspection.\n\nParameters:\n * `callback` - a required function which should expect two arguments: a `msg` string specifying how the search ended, and a table containing the recorded information. `msg` will be \"completed\" when the search has completed normally (or reached the specified depth) and will contain a string starting with \"**\" if it terminates early for some reason (see Notes: section for more information)\n * `depth`    - an optional integer, default `math.huge`, specifying the maximum depth from the initial accessibility object that should be visited to identify descendant elements and their attributes.\n * `withParents` - an optional boolean, default false, specifying whether or not an element's (or descendant's) attributes for `AXParent` and `AXTopLevelUIElement` should also be visited when identifying additional elements to include in the results table.\n\nReturns:\n * an elementSearchObject as described in [hs.axuielement:elementSearch](#elementSearch)\n\nNotes:\n* The format of the `results` table passed to the callback for this method is primarily for debugging and exploratory purposes and may not be arranged for easy programatic evaluation.\n\n * This method is syntactic sugar for `hs.axuielement:elementSearch(callback, { objectOnly = false, asTree = true, [depth = depth], [includeParents = withParents] })`. Please refer to [hs.axuielement:elementSearch](#elementSearch) for details about the returned object and callback arguments."
    },
    "Return a duplicate userdata reference to the Accessibility object.": {
        "prefix": "hs.axuielement:copy() -> axuielementObject",
        "body": "hs.axuielement:copy()",
        "description": "Return a duplicate userdata reference to the Accessibility object.\n\nParameters:\n * None\n\nReturns:\n * a new userdata object representing a new reference to the Accessibility object."
    },
    "Returns the accessibility object at the specified position on the screen. The top-left corner of the primary screen is 0, 0.": {
        "prefix": "hs.axuielement.systemElementAtPosition(x, y | pointTable) -> axuielementObject",
        "body": "hs.a${1:x}uielement.systemElementAtPosition(x, ${2:y | pointTable})",
        "description": "Returns the accessibility object at the specified position on the screen. The top-left corner of the primary screen is 0, 0.\n\nParameters:\n * `x`, `y`     - the x and y coordinates of the screen location to test, provided as separate parameters\n * `pointTable` - the x and y coordinates of the screen location to test, provided as a point-table, like the one returned by `hs.mouse.getAbsolutePosition`. A point-table is a table with key-value pairs for keys `x` and `y`.\n\nReturns:\n * an axuielementObject for the object at the specified coordinates, or nil if no object could be identified.\n\nNotes:\n * See also [hs.axuielement:elementAtPosition](#elementAtPosition) -- this function is a shortcut for `hs.axuielement.systemWideElement():elementAtPosition(...)`.\n\n * This function does hit-testing based on window z-order (that is, layering). If one window is on top of another window, the returned accessibility object comes from whichever window is topmost at the specified location."
    },
    "Search for and generate a table of the accessibility elements for the attributes and descendants of this object based on the specified criteria.": {
        "prefix": "hs.axuielement:elementSearch(callback, [criteria], [namedModifiers]) -> elementSearchObject",
        "body": "hs.axuielement:elementSearch(${1:callback}, ${2:[criteria]}, ${3:[namedModifiers]})",
        "description": "Search for and generate a table of the accessibility elements for the attributes and descendants of this object based on the specified criteria.\n\nParameters:\n * `callback`       - a (usually) required function which will receive the results of this search. The callback should expect three arguments and return none. The arguments to the callback function will be `msg`, a string specifying how the search ended and `results`, the elementSearchObject containing the requested results, and the number of items added to the results (see `count` in `namedModifiers`). `msg` will be \"completed\" if the search completes normally, or a string starting with \"**\" if it is terminated early (see Returns: and Notes: for more details).\n * `criteria`       - an optional function which should accept one argument (the current element being examined) and return true if it should be included in the results or false if it should be rejected. See [hs.axuielement.searchCriteriaFunction](#searchCriteriaFunction) to create a search function that uses [hs.axuielement:matchesCriteria](#matchesCriteria) for evaluation.\n * `namedModifiers` - an optional table specifying key-value pairs that further modify or control the search. This table may contain 0 or more of the following keys:\n   * `count`          - an optional integer, default `math.huge`, specifying the maximum number of matches to collect before ending the search and invoking the callback. You can continue the search to find additional elements by invoking `elementSearchObject:next()` (described below in the `Returns` section) on the return value of this method, or on the results argument passed to the callback.\n   * `depth`          - an optional integer, default `math.huge`, specifying the maximum number of steps (descendants) from the initial accessibility element the search should visit. If you know that your desired element(s) are relatively close to your starting element, setting this to a lower value can significantly speed up the search.\n\n   * The following are also recognized, but may impact the speed of the search, the responsiveness of Hammerspoon, or the format of the results in ways that limit further filtering and are not recommended except when you know that you require them:\n     * `asTree`         - an optional boolean, default false, and ignored if `criteria` is specified and non-empty, `objectOnly` is true, or `count` is specified. This modifier specifies whether the search results should return as an array table of tables containing each element's details (false) or as a tree where in which the root node details are the key-value pairs of the returned table and descendant elements are likewise described in subtables attached to the attribute name they belong to (true). This format is primarily for debugging and exploratory purposes and may not be arranged for easy programatic evaluation.\n     * `includeParents` - a boolean, default false, specifying whether or not parent attributes (`AXParent` and `AXTopLevelUIElement`) should be examined during the search. Note that in most cases, setting this value to true will end up traversing the entire Accessibility structure for the target application and may significantly slow down the search.\n     * `noCallback`     - an optional boolean, default false, and ignored if `callback` is not also nil, allowing you to specify nil as the callback when set to true. This feature requires setting this named argumennt to true *and* specifying the callback field as nil because starting a query from an element with a lot of descendants **WILL** block Hammerspoon and slow down the responsiveness of your computer (I've seen blocking for over 5 minutes in extreme cases) and should be used *only* when you know you are starting from close to the end of the element heirarchy.\n     * `objectOnly`     - an optional boolean, default true, specifying whether each result in the final table will be the accessibility element discovered (true) or a table containing details about the element include the attribute names, actions, etc. for the element (false). This latter format is primarily for debugging and exploratory purposes and may not be arranged for easy programatic evaluation.\n\nReturns:\n * an elementSearchObject which contains metamethods allowing you to check to see if the process has completed and cancel it early if desired. The methods include:\n   * `elementSearchObject:cancel([reason])` - cancels the current search and invokes the callback with the partial results already collected. If you specify `reason`, the `msg` argument for the callback will be `** <reason>`; otherwise it will be \"** cancelled\".\n   * `elementSearchObject:isRunning()`      - returns true if the search is currently ongoing or false if it has completed or been cancelled.\n   * `elementSearchObject:matched()`        - returns an integer specifying the number of elements which have already been found that meet the specified criteria function.\n   * `elementSearchObject:runTime()`        - returns an integer specifying the number of seconds spent performing this search. Note that this is *not* an accurate measure of how much time a given search will always take because the time will be greatly affected by how much other activity is occurring within Hammerspoon and on the users computer. Resuming a cancelled search or a search which invoked the callback because it reached `count` items with the `next` method (descibed below) will cause this number to begin increasing again to provide a cumulative total of time spent performing the search; time between when the callback is invoked and the `next` method is invoked is not included.\n   * `elementSearchObject:visited()`        - returns an integer specifying the number of elements which have been examined during the search so far.\n\n   * If `asTree` is false or not specified, the following additional methods will be available:\n     * `elementSearchObject:filter(criteria, [callback]) -> filterObject`\n       * returns a new table containing elements in the search results that match the specified criteria.\n         * `criteria`  - a required function which should accept one argument (the current element being examined) and return true if it should be included in the results or false if it should be rejected. See [hs.axuielement.searchCriteriaFunction](#searchCriteriaFunction) to create a search function that uses [hs.axuielement:matchesCriteria](#matchesCriteria) for evaluation.\n         * `callback`  - an optional callback which should expect two arguments and return none. If a callback is specified, the callback will receive two arguments, a msg indicating how the callback ended (the message format matches the style defined for this method) and the filterObject which contains the matching elements.\n       * The filterObject returned by this method and passed to the callback, if defined, will support the following methods as defined here: `cancel`, `filter`, `isRunning`, `matched`, `runTime`, and `visited`.\n     * `elementSearchObject:next()` - if the search was cancelled or reached the count of matches specified, this method will continue the search where it left off. The elementSearchObject returned when the callback is next invoked will have up to `count` items added to the existing results (calls to `next` are cummulative for the total results captured in the elementSearchObject). The third ardument to the callback will be the number of items *added* to the search results, not the number of items *in* the search results.\n\nNotes:\n * This method utilizes coroutines to keep Hammerspoon responsive, but may be slow to complete if `includeParents` is true, if you do not specify `depth`, or if you start from an element that has a lot of descendants (e.g. the application element for a web browser). This is dependent entirely upon how many active accessibility elements the target application defines and where you begin your search and cannot reliably be determined up front, so you may need to experiment to find the best balance for your specific requirements.\n\n* The search performed is a breadth-first search, so in general earlier elements in the results table will be \"closer\" in the Accessibility hierarchy to the starting point than later elements.\n\n* The `elementSearchObject` returned by this method and the results passed in as the second argument to the callback function are the same object -- you can use either one in your code depending upon which makes the most sense. Results that match the criteria function are added to the `elementSearchObject` as they are found, so if you examine the object/table returned by this method and determine that you have located the element or elements you require before the callback has been invoked, you can safely invoke the cancel method to end the search early.\n\n* If `objectsOnly` is specified as false, it may take some time after `cancel` is invoked for the mapping of element attribute tables to the descendant elements in the results set -- this is a by product of the need to iterate through the results to match up all of the instances of each element to it's attribute table.\n\n* [hs.axuielement:allDescendantElements](#allDescendantElements) is syntactic sugar for `hs.axuielement:elementSearch(callback, { [includeParents = withParents] })`\n* [hs.axuielement:buildTree](#buildTree) is syntactic sugar for `hs.axuielement:elementSearch(callback, { objectOnly = false, asTree = true, [depth = depth], [includeParents = withParents] })`"
    },
    "Returns whether the specified accessibility object's attribute can be modified.": {
        "prefix": "hs.axuielement:isAttributeSettable(attribute) -> boolean | nil, errString",
        "body": "hs.axuielement:isAttributeSettable(${1:attribute})",
        "description": "Returns whether the specified accessibility object's attribute can be modified.\n\nParameters:\n * `attribute` - the name of the attribute, as specified by [hs.axuielement:attributeNames](#attributeNames).\n\nReturns:\n * a boolean value indicating whether or not the value of the parameter can be modified or nil and an error string if an accessibility error occurred"
    },
    "Returns whether the specified accessibility object is still valid.": {
        "prefix": "hs.axuielement:isValid() -> boolean | nil, errString",
        "body": "hs.axuielement:isValid()",
        "description": "Returns whether the specified accessibility object is still valid.\n\nParameters:\n * None\n\nReturns:\n * a boolean value indicating whether or not the accessibility object is still valid or nil and an error string if any other accessibility error occurred\n\nNotes:\n * an accessibilityObject can become invalid for a variety of reasons, including but not limited to the element referred to no longer being available (e.g. an element referring to a window or one of its descendants that has been closed) or the application terminating."
    },
    "Returns true if the axuielementObject matches the specified criteria or false if it does not.": {
        "prefix": "hs.axuielement:matchesCriteria(criteria) -> boolean",
        "body": "hs.axuielement:matchesCriteria(${1:criteria})",
        "description": "Returns true if the axuielementObject matches the specified criteria or false if it does not.\n\nParameters:\n * `criteria`  - the criteria to compare against the accessibility object\n\nReturns:\n * true if the axuielementObject matches the criteria, false if it does not.\n\nNotes:\n * the `criteria` argument must be one of the following:\n   * a single string, specifying the value the element's AXRole attribute must equal for a positive match\n\n   * an array table of strings specifying a list of possible values the element's AXRole attribute can equal for a positive match\n\n   * a table of key-value pairs specifying a more complex criteria. The table should be defined as follows:\n     * one or more of the following must be specified (though all specified must match):\n       * `attribute`              -- a string, or table of strings, specifying attributes that the element must support.\n       * `action`                 -- a string, or table of strings, specifying actions that the element must be able to perform.\n       * `parameterizedAttribute` -- a string, or table of strings, specifying parametrized attributes that the element must support.\n\n     * if the `attribute` key is specified, you can use one of the the following to specify a specific value the attribute must equal for a positive match. No more than one of these should be provided. If neither are present, then only the existence of the attributes specified by `attribute` are required.\n       * `value`                  -- a value, or table of values, that a specifeid attribute must equal. If it's a table, then only one of the values has to match the attribute value for a positive match. Note that if you specify more than one attribute with the `attribute` key, you must provide at least one value for each attribute in this table (order does not matter, but the match will fail if any atrribute does not match at least one value provided).\n       * `nilValue`               -- a boolean, specifying that the attributes must not have an assigned value (true) or may be assigned any value except nil (false). If the `value` key is specified, this key is ignored. Note that this applies to *all* of the attributes specified with the `attribute` key.\n\n     * the following are optional keys and are not required:\n       * `pattern`                -- a boolean, default false, specifying whether string matches for attribute values should be evaluated with `string.match` (true) or as exact matches (false). See the Lua manual, section 6.4.1 (`help.lua._man._6_4_1` in the Hammerspoon console). If the `value` key is not set, than this key is ignored.\n       * `invert`                 -- a boolean, default false, specifying inverted logic for the criteria result --- if this is true and the criteria matches, evaluate criteria as false; otherwise evaluate as true.\n\n   * an array table of one or more key-value tables as described immediately above; the element must be a positive match for all of the individual criteria tables specified (logical AND).\n\n * This method is used by [hs.axuielement.searchCriteriaFunction](#searchCriteriaFunction) to create criteria functions compatible with [hs.axuielement:elementSearch](#elementSearch)."
    },
    "A table of orientation types which may be used with [hs.axuielement:elementSearch](#elementSearch) or [hs.axuielement:matchesCriteria](#matchesCriteria) as attribute values for \"AXOrientation\" in the match criteria argument.": {
        "prefix": "hs.axuielement.orientations[]",
        "body": "hs.axuielement.orientations",
        "description": "A table of orientation types which may be used with [hs.axuielement:elementSearch](#elementSearch) or [hs.axuielement:matchesCriteria](#matchesCriteria) as attribute values for \"AXOrientation\" in the match criteria argument.\n\nNotes:\n * this table is provided for reference only and may not be comprehensive.\n * you can view the contents of this table from the Hammerspoon console by typing in `hs.axuielement.orientations`"
    },
    "Returns a list of all the parameterized attributes supported by the specified accessibility object.": {
        "prefix": "hs.axuielement:parameterizedAttributeNames() -> table | nil, errString",
        "body": "hs.axuielement:parameterizedAttributeNames()",
        "description": "Returns a list of all the parameterized attributes supported by the specified accessibility object.\n\nParameters:\n * None\n\nReturns:\n * an array of the names of all parameterized attributes supported by the axuielementObject or nil and an error string if an accessibility error occurred"
    },
    "A table of common accessibility object parameterized attribute names, provided for reference.": {
        "prefix": "hs.axuielement.parameterizedAttributes[]",
        "body": "hs.axuielement.parameterizedAttributes",
        "description": "A table of common accessibility object parameterized attribute names, provided for reference.\n\nNotes:\n * this table is provided for reference only and is not intended to be comprehensive.\n * you can view the contents of this table from the Hammerspoon console by typing in `hs.axuielement.parameterizedAttributes`\n\n * Parameterized attributes are attributes that take an argument when querying the element. There is very little documentation available for most of these and application developers can implement their own for which we may never be able to get any documentation. This table contains parameterized attribute names that are defined within the Apple documentation and a few others that have been discovered.\n\n * Documentation covering what has been discovered through experimentation about paramterized attributes is planned and should be added to the Hammerspoon wiki shortly after this module becomes part of a formal release."
    },
    "Returns the value of an accessibility object's parameterized attribute.": {
        "prefix": "hs.axuielement:parameterizedAttributeValue(attribute, parameter) -> value | nil, errString",
        "body": "hs.axuielement:${2:parameter}izedAttributeValue(${1:attribute}, parameter)",
        "description": "Returns the value of an accessibility object's parameterized attribute.\n\nParameters:\n * `attribute` - the name of the attribute, as specified by [hs.axuielement:parameterizedAttributeNames](#parameterizedAttributeNames).\n * `parameter` - the parameter required by the paramaterized attribute.\n\nReturns:\n * the current value of the parameterized attribute, nil if the parameterized attribute has no value, or nil and an error string if an accessibility error occurred\n\nNotes:\n * The specific parameter required for a each parameterized attribute is different and is often application specific thus requiring some experimentation. Notes regarding identified parameter types and thoughts on some still being investigated will be provided in the Hammerspoon Wiki, hopefully shortly after this module becomes part of a Hammerspoon release."
    },
    "Returns a table of axuielements tracing this object through its parent objects to the root for this element, most likely an application object or the system wide object.": {
        "prefix": "hs.axuielement:path() -> table",
        "body": "hs.axuielement:path()",
        "description": "Returns a table of axuielements tracing this object through its parent objects to the root for this element, most likely an application object or the system wide object.\n\nParameters:\n * None\n\nReturns:\n * a table containing this object and 0 or more parent objects representing the path from the root object to this element.\n\nNotes:\n * this object will always exist as the last element in the table (e.g. at `table[#table]`) with its most immediate parent at `#table - 1`, etc. until the rootmost object for this element is reached at index position 1.\n\n * an axuielement object representing an application or the system wide object is its own rootmost object and will return a table containing only itself (i.e. `#table` will equal 1)"
    },
    "Requests that the specified accessibility object perform the specified action.": {
        "prefix": "hs.axuielement:performAction(action) -> axuielement | false | nil, errString",
        "body": "hs.axuielement:performAction(${1:action})",
        "description": "Requests that the specified accessibility object perform the specified action.\n\nParameters:\n * `action` - the name of the action, as specified by [hs.axuielement:actionNames](#actionNames).\n\nReturns:\n * if the requested action was accepted by the target, returns the axuielementObject; if the requested action was rejected, returns false; otherwise returns nil and an error string if an accessibility error occurred\n\nNotes:\n * The return value only suggests success or failure, but is not a guarantee.  The receiving application may have internal logic which prevents the action from occurring at this time for some reason, even though this method returns success (the axuielementObject).  Contrawise, the requested action may trigger a requirement for a response from the user and thus appear to time out, causing this method to return false or nil."
    },
    "Returns the process ID associated with the specified accessibility object.": {
        "prefix": "hs.axuielement:pid() -> integer | nil, errString",
        "body": "hs.axuielement:pid()",
        "description": "Returns the process ID associated with the specified accessibility object.\n\nParameters:\n * None\n\nReturns:\n * the process ID for the application to which the accessibility object ultimately belongs or nil and an error string if an accessibility error occurred"
    },
    "A table of common accessibility object roles which may be used with [hs.axuielement:elementSearch](#elementSearch) or [hs.axuielement:matchesCriteria](#matchesCriteria) as attribute values for \"AXRole\" in the match criteria argument.": {
        "prefix": "hs.axuielement.roles[]",
        "body": "hs.axuielement.roles",
        "description": "A table of common accessibility object roles which may be used with [hs.axuielement:elementSearch](#elementSearch) or [hs.axuielement:matchesCriteria](#matchesCriteria) as attribute values for \"AXRole\" in the match criteria argument.\n\nNotes:\n * this table is provided for reference only and is not intended to be comprehensive.\n * you can view the contents of this table from the Hammerspoon console by typing in `hs.axuielement.roles`"
    },
    "A table of ruler marker types which may be used with [hs.axuielement:elementSearch](#elementSearch) or [hs.axuielement:matchesCriteria](#matchesCriteria) as attribute values for \"AXMarkerType\" in the match criteria argument.": {
        "prefix": "hs.axuielement.rulerMarkers[]",
        "body": "hs.axuielement.rulerMarkers",
        "description": "A table of ruler marker types which may be used with [hs.axuielement:elementSearch](#elementSearch) or [hs.axuielement:matchesCriteria](#matchesCriteria) as attribute values for \"AXMarkerType\" in the match criteria argument.\n\nNotes:\n * this table is provided for reference only and may not be comprehensive.\n * you can view the contents of this table from the Hammerspoon console by typing in `hs.axuielement.rulerMarkers`"
    },
    "Returns a function for use with [hs.axuielement:elementSearch](#elementSearch) that uses [hs.axuielement:matchesCriteria](#matchesCriteria) with the specified criteria.": {
        "prefix": "hs.axuielement.searchCriteriaFunction(criteria) -> function",
        "body": "hs.axuielement.searchCriteriaFunction(${1:criteria})",
        "description": "Returns a function for use with [hs.axuielement:elementSearch](#elementSearch) that uses [hs.axuielement:matchesCriteria](#matchesCriteria) with the specified criteria.\n\nParameters:\n * `criteria` - a criteria definition as defined for the [hs.axuielement:matchesCriteria](#matchesCriteria) method.\n\nReturns:\n * a function which can be used as the `criteriaFunction` for [hs.axuielement:elementSearch](#elementSearch)."
    },
    "Sets the accessibility object's attribute to the specified value.": {
        "prefix": "hs.axuielement:setAttributeValue(attribute, value) -> axuielementObject  | nil, errString",
        "body": "hs.axuielement:setAttributeValue(${1:attribute}, ${2:value})",
        "description": "Sets the accessibility object's attribute to the specified value.\n\nParameters:\n * `attribute` - the name of the attribute, as specified by [hs.axuielement:attributeNames](#attributeNames).\n * `value`     - the value to assign to the attribute\n\nReturns:\n * the axuielementObject on success; nil and an error string if the attribute could not be set or an accessibility error occurred."
    },
    "Sets the timeout value used accessibility queries performed from this element.": {
        "prefix": "hs.axuielement:setTimeout(value) -> axuielementObject | nil, errString",
        "body": "hs.axuielement:setTimeout(${1:value})",
        "description": "Sets the timeout value used accessibility queries performed from this element.\n\nParameters:\n * `value` - the number of seconds for the new timeout value. Must be 0 or positive.\n\nReturns:\n * the axuielementObject or nil and an error string if an accessibility error occurred\n\nNotes:\n * To change the global timeout affecting all queries on elements which do not have a specific timeout set, use this method on the systemwide element (see [hs.axuielement.systemWideElement](#systemWideElement).\n * Changing the timeout value for an axuielement object only changes the value for that specific element -- other axuieleement objects that may refer to the identical accessibiity item are not affected.\n\n * Setting the value to 0.0 resets the timeout -- if applied to the `systemWideElement`, the global default will be reset to its default value; if applied to another axuielement object, the timeout will be reset to the current global value as applied to the systemWideElement."
    },
    "A table of sort direction types which may be used with [hs.axuielement:elementSearch](#elementSearch) or [hs.axuielement:matchesCriteria](#matchesCriteria) as attribute values for \"AXSortDirection\" in the match criteria argument.": {
        "prefix": "hs.axuielement.sortDirections[]",
        "body": "hs.axuielement.sortDirections",
        "description": "A table of sort direction types which may be used with [hs.axuielement:elementSearch](#elementSearch) or [hs.axuielement:matchesCriteria](#matchesCriteria) as attribute values for \"AXSortDirection\" in the match criteria argument.\n\nNotes:\n * this table is provided for reference only and may not be comprehensive.\n * you can view the contents of this table from the Hammerspoon console by typing in `hs.axuielement.sortDirections`"
    },
    "A table of common accessibility object subroles which may be used with [hs.axuielement:elementSearch](#elementSearch) or [hs.axuielement:matchesCriteria](#matchesCriteria) as attribute values for \"AXSubrole\" in the match criteria argument.": {
        "prefix": "hs.axuielement.subroles[]",
        "body": "hs.axuielement.subroles",
        "description": "A table of common accessibility object subroles which may be used with [hs.axuielement:elementSearch](#elementSearch) or [hs.axuielement:matchesCriteria](#matchesCriteria) as attribute values for \"AXSubrole\" in the match criteria argument.\n\nNotes:\n * this table is provided for reference only and is not intended to be comprehensive.\n * you can view the contents of this table from the Hammerspoon console by typing in `hs.axuielement.subroles`"
    },
    "Returns an accessibility object that provides access to system attributes.": {
        "prefix": "hs.axuielement.systemWideElement() -> axuielementObject",
        "body": "hs.axuielement.systemWideElement()",
        "description": "Returns an accessibility object that provides access to system attributes.\n\nParameters:\n * None\n\nReturns:\n * the axuielementObject for the system attributes"
    },
    "A table of measurement unit types which may be used with [hs.axuielement:elementSearch](#elementSearch) or [hs.axuielement:matchesCriteria](#matchesCriteria) as attribute values for attributes which specify measurement unit types (e.g. \"AXUnits\", \"AXHorizontalUnits\", and \"AXVerticalUnits\") in the match criteria argument.": {
        "prefix": "hs.axuielement.units[]",
        "body": "hs.axuielement.units",
        "description": "A table of measurement unit types which may be used with [hs.axuielement:elementSearch](#elementSearch) or [hs.axuielement:matchesCriteria](#matchesCriteria) as attribute values for attributes which specify measurement unit types (e.g. \"AXUnits\", \"AXHorizontalUnits\", and \"AXVerticalUnits\") in the match criteria argument.\n\nNotes:\n * this table is provided for reference only and may not be comprehensive.\n * you can view the contents of this table from the Hammerspoon console by typing in `hs.axuielement.units`"
    },
    "Returns the accessibility object for the window specified by the `hs.window` object.": {
        "prefix": "hs.axuielement.windowElement(windowObject) -> axuielementObject",
        "body": "hs.axuielement.windowElement(${1:windowObject})",
        "description": "Returns the accessibility object for the window specified by the `hs.window` object.\n\nParameters:\n * `windowObject` - the `hs.window` object for the window or a string or number which will be passed to `hs.window.find` to get an `hs.window` object.\n\nReturns:\n * an axuielementObject for the window specified\n\nNotes:\n * if `windowObject` is a string or number, only the first item found with `hs.window.find` will be used by this function to create an axuielementObject."
    },
    "Returns a table of the AXTextMarker and AXTextMarkerRange functions that have been discovered and are used within this module.": {
        "prefix": "hs.axuielement.axtextmarker._functionCheck() -> table",
        "body": "hs.axuielement.axtextmarker._functionCheck()",
        "description": "Returns a table of the AXTextMarker and AXTextMarkerRange functions that have been discovered and are used within this module.\n\nParamters:\n * None\n\nReturns:\n * a table with key-value pairs where the keys correspond to the undocumented Core Foundation functions required by this module to support AXTextMarker and AXTextMarkerRange and the value will be a boolean indicating whether the function exists in the currently loaded frameworks.\n\nNotes:\n * the functions are defined within the HIServices framework which is part of the ApplicationServices framework, so it is expected that the necessary functions will always be available; however, if you ever receive an error message from a function or method within this submodule of the form \"CF function AX... undefined\", please see the submodule heading documentation for a description of the information, including that which this function provides, that should be included in any error report you submit.\n\n* This is for debugging purposes and is not expected to be used often."
    },
    "Returns a string containing the opaque binary data contained within the axTextMarkerObject": {
        "prefix": "hs.axuielement.axtextmarker:bytes() -> string | nil, errorString",
        "body": "hs.axuielement.axtextmarker:bytes()",
        "description": "Returns a string containing the opaque binary data contained within the axTextMarkerObject\n\nParamters:\n * None\n\nReturns:\n *  a string containing the opaque binary data contained within the axTextMarkerObject\n\nNotes:\n * the string will likely contain invalid UTF8 code sequences or unprintable ascii values; to see the data in decimal or hexidecimal form you can use:\n\n    string.byte(hs.axuielement.axtextmarker:bytes(), 1, hs.axuielement.axtextmarker:length())\n    -- or\n    hs.utf8.hexDump(hs.axuielement.axtextmarker:bytes())\n\n * As the data is application specific, it is unlikely that you will use this method often; it is included primarily for testing and debugging purposes."
    },
    "Returns the ending marker for an axTextMarkerRangeObject": {
        "prefix": "hs.axuielement.axtextmarker:endMarker() -> axTextMarkerObject | nil, errorString",
        "body": "hs.axuielement.axtextmarker:endMarker()",
        "description": "Returns the ending marker for an axTextMarkerRangeObject\n\nParamters:\n * None\n\nReturns:\n *  the ending marker for an axTextMarkerRangeObject"
    },
    "Returns an integer specifying the number of bytes in the data portion of the axTextMarkerObject.": {
        "prefix": "hs.axuielement.axtextmarker:length() -> integer | nil, errorString",
        "body": "hs.axuielement.axtextmarker:length()",
        "description": "Returns an integer specifying the number of bytes in the data portion of the axTextMarkerObject.\n\nParamters:\n * None\n\nReturns:\n *  an integer specifying the number of bytes in the data portion of the axTextMarkerObject\n\nNotes:\n * As the data is application specific, it is unlikely that you will use this method often; it is included primarily for testing and debugging purposes."
    },
    "Creates a new AXTextMarker object from the string of binary data provided": {
        "prefix": "hs.axuielement.axtextmarker.newMarker(string) -> axTextMarkerObject | nil, errorString",
        "body": "hs.axuielement.axtextmarker.newMarker(${1:string})",
        "description": "Creates a new AXTextMarker object from the string of binary data provided\n\nParameters:\n * `string` - a string containing 1 or more bytes of data for the AXTextMarker object\n\nReturns:\n * a new axTextMarkerObject or nil and a string description if there was an error\n\nNotes:\n * This function is included primarily for testing and debugging purposes -- in general you will probably never use this constructor; AXTextMarker objects appear to be mostly application dependant and have no meaning external to the application from which it was created."
    },
    "Creates a new AXTextMarkerRange object from the start and end markers provided": {
        "prefix": "hs.axuielement.axtextmarker.newRange(startMarker, endMarker) -> axTextMarkerRangeObject | nil, errorString",
        "body": "hs.axuielement.axtextmarker.newRange(${1:startMarker}, ${2:endMarker})",
        "description": "Creates a new AXTextMarkerRange object from the start and end markers provided\n\nParameters:\n * `startMarker` - an axTextMarkerObject representing the start of the range to be created\n * `endMarker`   - an axTextMarkerObject representing the end of the range to be created\n\nReturns:\n * a new axTextMarkerRangeObject or nil and a string description if there was an error\n\nNotes:\n * this constructor can be used to create a range from axTextMarkerObjects obtained from an application to specify a new range for a paramterized attribute. As a simple example (it is hoped that more will be added to the Hammerspoon wiki shortly):\n\n    ```\n    s = hs.axuielement.applicationElement(hs.application(\"Safari\"))\n    -- for a window displaying the DuckDuckGo main search page, this gets the\n    -- primary display area. Other pages may vary and you should build your\n    -- object as necessary for your target.\n    c = s(\"AXMainWindow\")(\"AXSections\")[1].SectionObject[1][1]\n    start = c(\"AXStartTextMarker\") -- get the text marker for the start of this element\n    ending = c(\"AXNextLineEndTextMarkerForTextMarker\", start) -- get the next end of line marker\n    print(c(\"AXStringForTextMarkerRange\", hs.axuielement.axtextmarker.newRange(start, ending)))\n    -- outputs \"Privacy, simplified.\" to the Hammerspoon console\n    ```\n\n * The specific attributes and parameterized attributes supported by a given application differ and can be discovered with the `hs.axuielement:getAttributeNames` and `hs.axuielement:getParameterizedAttributeNames` methods."
    },
    "Returns the starting marker for an axTextMarkerRangeObject": {
        "prefix": "hs.axuielement.axtextmarker:startMarker() -> axTextMarkerObject | nil, errorString",
        "body": "hs.axuielement.axtextmarker:startMarker()",
        "description": "Returns the starting marker for an axTextMarkerRangeObject\n\nParamters:\n * None\n\nReturns:\n *  the starting marker for an axTextMarkerRangeObject"
    },
    "Registers the specified notification for the specified accesibility element with the observer.": {
        "prefix": "hs.axuielement.observer:addWatcher(element, notification) -> observerObject",
        "body": "hs.axui${1:element}.observer:addWatcher(element, ${2:notification})",
        "description": "Registers the specified notification for the specified accesibility element with the observer.\n\nParameters:\n * `element`      - the `hs.axuielement` representing an accessibility element of the application the observer was created for.\n * `notification` - a string specifying the notification.\n\nReturns:\n * the observerObject; generates an error if watcher cannot be registered\n\nNotes:\n * multiple notifications for the same accessibility element can be registered by invoking this method multiple times with the same element but different notification strings.\n * if the specified element and notification string are already registered, this method does nothing.\n * the notification string is application dependent and can be any string that the application developers choose; some common ones are found in `hs.axuielement.observer.notifications`, but the list is not exhaustive nor is an application or element required to provide them."
    },
    "Get or set the callback for the observer.": {
        "prefix": "hs.axuielement.observer:callback([fn | nil]) -> observerObject | fn | nil",
        "body": "hs.axuielement.observer:callback(${1:[fn | nil]})",
        "description": "Get or set the callback for the observer.\n\nParameters:\n * `fn` - a function, or an explicit nil to remove, specifying the callback to the observer will invoke when the assigned elements generate notifications.\n\nReturns:\n * If an argument is provided, the observerObject; otherwise the current value.\n\nNotes:\n * the callback should expect 4 arguments and return none. The arguments passed to the callback will be as follows:\n   * the observerObject itself\n   * the `hs.axuielement` object for the accessibility element which generated the notification\n   * a string specifying the specific notification which was received\n   * a table containing key-value pairs with more information about the notification, if the element and notification type provide it. Commonly this will be an empty table indicating that no additional detail was provided."
    },
    "Returns true or false indicating whether the observer is currently watching for notifications and generating callbacks.": {
        "prefix": "hs.axuielement.observer:isRunning() -> boolean",
        "body": "hs.axuielement.observer:isRunning()",
        "description": "Returns true or false indicating whether the observer is currently watching for notifications and generating callbacks.\n\nParameters:\n * None\n\nReturns:\n * a boolean value indicating whether or not the observer is currently active."
    },
    "Creates a new observer object for the application with the specified process ID.": {
        "prefix": "hs.axuielement.observer.new(pid) -> observerObject",
        "body": "hs.axuielement.observer.new(${1:pid})",
        "description": "Creates a new observer object for the application with the specified process ID.\n\nParameters:\n * `pid` - the process ID of the application.\n\nReturns:\n * a new observerObject; generates an error if the pid does not exist or if the object cannot be created.\n\nNotes:\n * If you already have the `hs.application` object for an application, you can get its process ID with `hs.application:pid()`\n * If you already have an `hs.axuielement` from the application you wish to observe (it doesn't have to be the application axuielement object, just one belonging to the application), you can get the process ID with `hs.axuielement:pid()`."
    },
    "A table of common accessibility object notification names, provided for reference.": {
        "prefix": "hs.axuielement.observer.notifications[]",
        "body": "hs.axuielement.observer.notifications",
        "description": "A table of common accessibility object notification names, provided for reference.\n\nNotes:\n * Notifications are application dependent and can be any string that the application developers choose; this list provides the suggested notification names found within the macOS Framework headers, but the list is not exhaustive nor is an application or element required to provide them."
    },
    "Unregisters the specified notification for the specified accessibility element from the observer.": {
        "prefix": "hs.axuielement.observer:removeWatcher(element, notification) -> observerObject",
        "body": "hs.axui${1:element}.observer:removeWatcher(element, ${2:notification})",
        "description": "Unregisters the specified notification for the specified accessibility element from the observer.\n\nParameters:\n * `element`      - the `hs.axuielement` representing an accessibility element of the application the observer was created for.\n * `notification` - a string specifying the notification.\n\nReturns:\n * the observerObject; generates an error if watcher cannot be unregistered\n\nNotes:\n * if the specified element and notification string are not currently registered with the observer, this method does nothing."
    },
    "Start observing the application and trigger callbacks for the elements and notifications assigned.": {
        "prefix": "hs.axuielement.observer:start() -> observerObject",
        "body": "hs.axuielement.observer:start()",
        "description": "Start observing the application and trigger callbacks for the elements and notifications assigned.\n\nParameters:\n * None\n\nReturns:\n * the observerObject\n\nNotes:\n * This method does nothing if the observer is already running"
    },
    "Stop observing the application; no further callbacks will be generated.": {
        "prefix": "hs.axuielement.observer:stop() -> observerObject",
        "body": "hs.axuielement.observer:stop()",
        "description": "Stop observing the application; no further callbacks will be generated.\n\nParameters:\n * None\n\nReturns:\n * the observerObject\n\nNotes:\n * This method does nothing if the observer is not currently running"
    },
    "Returns a table of the notifications currently registered with the observer.": {
        "prefix": "hs.axuielement.observer:watching([element]) -> table",
        "body": "hs.axuielement.observer:watching(${1:[element]})",
        "description": "Returns a table of the notifications currently registered with the observer.\n\nParameters:\n * `element` - an optional `hs.axuielement` to return a list of registered notifications for.\n\nReturns:\n * a table containing the currently registered notifications\n\nNotes:\n * If an element is specified, then the table returned will contain a list of strings specifying the specific notifications that the observer is watching that element for.\n * If no argument is specified, then the table will contain key-value pairs in which each key will be an `hs.axuielement` that is being observed and the corresponding value will be a table containing a list of strings specifying the specific notifications that the observer is watching for from from that element."
    },
    "Decodes a given base64 string": {
        "prefix": "hs.base64.decode(str) -> val",
        "body": "hs.base64.decode(${1:str})",
        "description": "Decodes a given base64 string\n\nParameters:\n * str - A base64 encoded string\n\nReturns:\n * A string containing the decoded data"
    },
    "Encodes a given string to base64": {
        "prefix": "hs.base64.encode(val[,width]) -> str",
        "body": "hs.base64.encode(${1:val[},${2:width]})",
        "description": "Encodes a given string to base64\n\nParameters:\n * val - A string to encode as base64\n * width - Optional line width to split the string into (usually 64 or 76)\n\nReturns:\n * A string containing the base64 representation of the input string"
    },
    "Returns the amount of current flowing through the battery, in mAh": {
        "prefix": "hs.battery.amperage() -> number",
        "body": "hs.battery.amperage()",
        "description": "Returns the amount of current flowing through the battery, in mAh\n\nParameters:\n * None\n\nReturns:\n * A number containing the amount of current flowing through the battery. The value may be:\n  * Less than zero if the battery is being discharged (i.e. the computer is running on battery power)\n  * Zero if the battery is being neither charged nor discharged\n  * Greater than zero if the battery is being charged"
    },
    "Returns the current capacity of the battery in mAh": {
        "prefix": "hs.battery.capacity() -> number",
        "body": "hs.battery.capacity()",
        "description": "Returns the current capacity of the battery in mAh\n\nParameters:\n * None\n\nReturns:\n * A number containing the current capacity of the battery in mAh\n\nNotes:\n * This is the measure of how charged the battery is, vs the value of `hs.battery.maxCapacity()`"
    },
    "Returns the number of discharge cycles of the battery": {
        "prefix": "hs.battery.cycles() -> number",
        "body": "hs.battery.cycles()",
        "description": "Returns the number of discharge cycles of the battery\n\nParameters:\n * None\n\nReturns:\n * The number of cycles\n\nNotes:\n * One cycle is a full discharge of the battery, followed by a full charge. This may also be an aggregate of many smaller discharge-then-charge cycles (e.g. 10 iterations of discharging the battery from 100% to 90% and then charging back to 100% each time, is considered to be one cycle)"
    },
    "Returns the design capacity of the battery in mAh.": {
        "prefix": "hs.battery.designCapacity() -> number",
        "body": "hs.battery.designCapacity()",
        "description": "Returns the design capacity of the battery in mAh.\n\nParameters:\n * None\n\nReturns:\n * A number containing the rated maximum capacity of the battery"
    },
    "Get all available battery information": {
        "prefix": "hs.battery.getAll() -> table",
        "body": "hs.battery.getAll()",
        "description": "Get all available battery information\n\nParameters:\n * None\n\nReturns:\n * A table containing all the information provided by the separate functions in hs.battery\n\nNotes:\n * If you require multiple pieces of information about a battery, this function may be more efficient than calling several other functions separately"
    },
    "Returns the health status of the battery.": {
        "prefix": "hs.battery.health() -> string",
        "body": "hs.battery.health()",
        "description": "Returns the health status of the battery.\n\nParameters:\n * None\n\nReturns:\n * A string containing one of {Good, Fair, Poor}, as determined by the Apple Smart Battery controller"
    },
    "Returns the health condition status of the battery.": {
        "prefix": "hs.battery.healthCondition() -> string or nil",
        "body": "hs.battery.healthCondition()",
        "description": "Returns the health condition status of the battery.\n\nParameters:\n * None\n\nReturns:\n * Nil if there are no health conditions to report, or a string containing either:\n  * \"Check Battery\"\n  * \"Permanent Battery Failure\""
    },
    "Returns the charged state of the battery": {
        "prefix": "hs.battery.isCharged() -> boolean",
        "body": "hs.battery.isCharged()",
        "description": "Returns the charged state of the battery\n\nParameters:\n * None\n\nReturns:\n * True if the battery is charged, false if not"
    },
    "Returns the charging state of the battery": {
        "prefix": "hs.battery.isCharging() -> boolean",
        "body": "hs.battery.isCharging()",
        "description": "Returns the charging state of the battery\n\nParameters:\n * None\n\nReturns:\n * True if the battery is being charged, false if not"
    },
    "Returns true if battery is finishing its charge": {
        "prefix": "hs.battery.isFinishingCharge() -> boolean or string",
        "body": "hs.battery.isFinishingCharge()",
        "description": "Returns true if battery is finishing its charge\n\nParameters:\n * None\n\nReturns:\n * True if the battery is in its final charging state (i.e. trickle charging), false if not, or \"n/a\" if the battery is not charging at all"
    },
    "Returns the maximum capacity of the battery in mAh": {
        "prefix": "hs.battery.maxCapacity() -> number",
        "body": "hs.battery.maxCapacity()",
        "description": "Returns the maximum capacity of the battery in mAh\n\nParameters:\n * None\n\nReturns:\n * A number containing the observed maximum capacity of the battery in mAh\n\nNotes:\n * This may exceed the value of `hs.battery.designCapacity()` due to small variations in the production chemistry vs the design"
    },
    "Returns the name of the battery": {
        "prefix": "hs.battery.name() -> string",
        "body": "hs.battery.name()",
        "description": "Returns the name of the battery\n\nParameters:\n * None\n\nReturns:\n * A string containing the name of the battery"
    },
    "Returns information about non-PSU batteries (e.g. bluetooth accessories)": {
        "prefix": "hs.battery.otherBatteryInfo() -> table",
        "body": "hs.battery.otherBatteryInfo()",
        "description": "Returns information about non-PSU batteries (e.g. bluetooth accessories)\n\nParameters:\n * None\n\nReturns:\n * A table containing information about other batteries known to the system, or an empty table if no devices were found"
    },
    "Returns the current percentage of battery charge": {
        "prefix": "hs.battery.percentage() -> number",
        "body": "hs.battery.percentage()",
        "description": "Returns the current percentage of battery charge\n\nParameters:\n * None\n\nReturns:\n * A number containing the percentage of battery charge"
    },
    "Returns current source of power": {
        "prefix": "hs.battery.powerSource() -> string",
        "body": "hs.battery.powerSource()",
        "description": "Returns current source of power\n\nParameters:\n * None\n\nReturns:\n * A string containing one of {AC Power, Battery Power, Off Line}."
    },
    "Returns information about Bluetooth devices using Apple Private APIs": {
        "prefix": "hs.battery.privateBluetoothBatteryInfo() -> table",
        "body": "hs.battery.privateBluetoothBatteryInfo()",
        "description": "Returns information about Bluetooth devices using Apple Private APIs\n\nParameters:\n * None\n\nReturns:\n * A table containing information about devices using private Apple APIs.\n\nNotes:\n * This function uses private Apple APIs - that means it can break without notice on any macOS version update. Please report breakage to us!\n * This function will return information for all connected Bluetooth devices, but much of it will be meaningless for most devices\n * The table contains the following keys:\n   * vendorID - Numerical identifier for the vendor of the device (Apple's ID is 76)\n   * productID - Numerical identifier for the device\n   * address - The bluetooth address of the device\n   * isApple - A string containing \"YES\" or \"NO\", depending on whether or not this is an Apple/Beats product, or a third party product\n   * name - A human readable string containing the name of the device\n   * batteryPercentSingle - For some devices this will contain the percentage of the battery (e.g. Beats headphones)\n   * batteryPercentCombined - We do not currently understand what this field represents, please report if you find a non-zero value here\n   * batteryPercentCase - Battery percentage of AirPods cases (note that this will often read 0 - the AirPod case sleeps aggressively)\n   * batteryPercentLeft - Battery percentage of the left AirPod if it is out of the case\n   * batteryPercentRight - Battery percentage of the right AirPod if it is out of the case\n   * buttonMode - We do not currently understand what this field represents, please report if you find a value other than 1\n   * micMode - For AirPods this corresponds to the microphone option in the device's Bluetooth options\n   * leftDoubleTap - For AirPods this corresponds to the left double tap action in the device's Bluetooth options\n   * rightDoubleTap - For AirPods this corresponds to the right double tap action in the device's Bluetooth options\n   * primaryBud - For AirPods this is either \"left\" or \"right\" depending on which bud is currently considered the primary device\n   * primaryInEar - For AirPods this is \"YES\" or \"NO\" depending on whether or not the primary bud is currently in an ear\n   * secondaryInEar - For AirPods this is \"YES\" or \"NO\" depending on whether or not the secondary bud is currently in an ear\n   * isInEarDetectionSupported - Whether or not this device can detect when it is currently in an ear\n   * isEnhancedDoubleTapSupported - Whether or not this device supports double tapping\n   * isANCSupported - We believe this likely indicates whether or not this device supports Active Noise Cancelling (e.g. Beats Solo)\n * Please report any crashes from this function - it's likely that there are Bluetooth devices we haven't tested which may return weird data\n * Many/Most/All non-Apple party products will likely return zeros for all of the battery related fields here, as will Apple HID devices. It seems that these private APIs mostly exist to support Apple/Beats headphones."
    },
    "Returns the serial number of the attached power supply, if present": {
        "prefix": "hs.battery.psuSerial() -> integer",
        "body": "hs.battery.psuSerial()",
        "description": "Returns the serial number of the attached power supply, if present\n\nParameters:\n * None\n\nReturns:\n * An integer containing the power supply's serial number, or 0 if no serial can be found"
    },
    "Returns the serial string of the attached power supply, if present": {
        "prefix": "hs.battery.psuSerialString() -> string",
        "body": "hs.battery.psuSerialString()",
        "description": "Returns the serial string of the attached power supply, if present\n\nParameters:\n * None\n\nReturns:\n * A string containing the power supply's serial, or an empty string if no serial can be found"
    },
    "Returns the battery life remaining, in minutes": {
        "prefix": "hs.battery.timeRemaining() -> number",
        "body": "hs.battery.timeRemaining()",
        "description": "Returns the battery life remaining, in minutes\n\nParameters:\n * None\n\nReturns:\n * A number containing the minutes of battery life remaining. The value may be:\n  * Greater than zero to indicate the number of minutes remaining\n  * -1 if the remaining battery life is still being calculated\n  * -2 if there is unlimited time remaining (i.e. the system is on AC power)"
    },
    "Returns the time remaining for the battery to be fully charged, in minutes": {
        "prefix": "hs.battery.timeToFullCharge() -> number",
        "body": "hs.battery.timeToFullCharge()",
        "description": "Returns the time remaining for the battery to be fully charged, in minutes\n\nParameters:\n * None\n\nReturns:\n * A number containing the time (in minutes) remaining for the battery to be fully charged, or -1 if the remaining time is still being calculated"
    },
    "Returns the current voltage of the battery in mV": {
        "prefix": "hs.battery.voltage() -> number",
        "body": "hs.battery.voltage()",
        "description": "Returns the current voltage of the battery in mV\n\nParameters:\n * None\n\nReturns:\n * A number containing the current voltage of the battery"
    },
    "Returns the power entering or leaving the battery, in W": {
        "prefix": "hs.battery.watts() -> number",
        "body": "hs.battery.watts()",
        "description": "Returns the power entering or leaving the battery, in W\n\nParameters:\n * None\n\nReturns:\n * A number containing the rate of energy conversion in the battery. The value may be:\n  * Less than zero if the battery is being discharged (i.e. the computer is running on battery power)\n  * Zero if the battery is being neither charged nor discharged\n  * Greater than zero if the battery is being charged"
    },
    "Creates a battery watcher": {
        "prefix": "hs.battery.watcher.new(fn) -> watcher",
        "body": "hs.battery.watcher.new(${1:fn})",
        "description": "Creates a battery watcher\n\nParameters:\n * A function that will be called when the battery state changes. The function should accept no arguments.\n\nReturns:\n * An `hs.battery.watcher` object\n\nNotes:\n * Because the callback function accepts no arguments, tracking of state of changing battery attributes is the responsibility of the user (see https://github.com/Hammerspoon/hammerspoon/issues/166 for discussion)"
    },
    "Starts the battery watcher": {
        "prefix": "hs.battery.watcher:start() -> self",
        "body": "hs.battery.watcher:start()",
        "description": "Starts the battery watcher\n\nParameters:\n * None\n\nReturns:\n * The `hs.battery.watcher` object"
    },
    "Stops the battery watcher": {
        "prefix": "hs.battery.watcher:stop() -> self",
        "body": "hs.battery.watcher:stop()",
        "description": "Stops the battery watcher\n\nParameters:\n * None\n\nReturns:\n * The `hs.battery.watcher` object"
    },
    "Return a list of zero-conf and bonjour domains visibile to the users computer.": {
        "prefix": "hs.bonjour:findBrowsableDomains(callback) -> browserObject",
        "body": "hs.bonjour:findBrowsableDomains(${1:callback})",
        "description": "Return a list of zero-conf and bonjour domains visibile to the users computer.\n\nParameters:\n * `callback` - a function which will be invoked as visible domains are discovered. The function should accept the following parameters and return none:\n   * `browserObject`    - the userdata object for the browserObject which initiated the search\n   * `type`             - a string which will be 'domain' or 'error'\n     * if `type` == 'domain', the remaining arguments will be:\n       * `added`        - a boolean value indicating whether this callback invocation represents a newly discovered or added domain (true) or that the domain has been removed from the network (false)\n       * `domain`       - a string specifying the name of the domain discovered or removed\n       * `moreExpected` - a boolean value indicating whether or not the browser expects to discover additional domains or not.\n     * if `type` == 'error', the remaining arguments will be:\n       * `errorString`  - a string specifying the error which has occurred\n\nReturns:\n * the browserObject\n\nNotes:\n * This method returns domains which are visible to your machine; however, your machine may or may not be able to access or publish records within the returned domains. See  [hs.bonjour:findRegistrationDomains](#findRegistrationDomains)\n\n * For most non-coporate network users, it is likely that the callback will only be invoked once for the `local` domain. This is normal. Corporate networks or networks including Linux machines using additional domains defined with Avahi may see additional domains as well, though most Avahi installations now use only 'local' by default unless specifically configured to do otherwise.\n\n * When `moreExpected` becomes false, it is the macOS's best guess as to whether additional records are available.\n   * Generally macOS is fairly accurate in this regard concerning domain searchs, so to reduce the impact on system resources, it is recommended that you use [hs.bonjour:stop](#stop) when this parameter is false"
    },
    "Return a list of zero-conf and bonjour domains this computer can register services in.": {
        "prefix": "hs.bonjour:findRegistrationDomains(callback) -> browserObject",
        "body": "hs.bonjour:findRegistrationDomains(${1:callback})",
        "description": "Return a list of zero-conf and bonjour domains this computer can register services in.\n\nParameters:\n * `callback` - a function which will be invoked as domains are discovered. The function should accept the following parameters and return none:\n   * `browserObject`    - the userdata object for the browserObject which initiated the search\n   * `type`             - a string which will be 'domain' or 'error'\n     * if `type` == 'domain', the remaining arguments will be:\n       * `added`        - a boolean value indicating whether this callback invocation represents a newly discovered or added domain (true) or that the domain has been removed from the network (false)\n       * `domain`       - a string specifying the name of the domain discovered or removed\n       * `moreExpected` - a boolean value indicating whether or not the browser expects to discover additional domains or not.\n     * if `type` == 'error', the remaining arguments will be:\n       * `errorString`  - a string specifying the error which has occurred\n\nReturns:\n * the browserObject\n\nNotes:\n * This is the preferred method for accessing domains as it guarantees that the host machine can connect to services in the returned domains. Access to domains outside this list may be more limited. See also [hs.bonjour:findBrowsableDomains](#findBrowsableDomains)\n\n * For most non-coporate network users, it is likely that the callback will only be invoked once for the `local` domain. This is normal. Corporate networks or networks including Linux machines using additional domains defined with Avahi may see additional domains as well, though most Avahi installations now use only 'local' by default unless specifically configured to do otherwise.\n\n * When `moreExpected` becomes false, it is the macOS's best guess as to whether additional records are available.\n   * Generally macOS is fairly accurate in this regard concerning domain searchs, so to reduce the impact on system resources, it is recommended that you use [hs.bonjour:stop](#stop) when this parameter is false"
    },
    "Find advertised services of the type specified.": {
        "prefix": "hs.bonjour:findServices(type, [domain], [callback]) -> browserObject",
        "body": "hs.bonjour:findServices(${1:type}, ${2:[domain]}, ${3:[callback]})",
        "description": "Find advertised services of the type specified.\n\nParameters:\n * `type`     - a string specifying the type of service to discover on your network. This string should be specified in the format of '_service._protocol.' where _protocol is one of '_tcp' or '_udp'. Examples of common service types can be found in [hs.bonjour.serviceTypes](#serviceTypes).\n * `domain`   - an optional string specifying the domain to look for advertised services in. The domain should end with a period. If you omit this parameter, the default registration domain will be used, usually \"local.\"\n * `callback` - a callback function which will be invoked as service advertisements meeting the specified criteria are discovered. The callback function should expect 2-5 arguments as follows:\n   * if a service is discovered or advertising for the service is terminated, the arguments will be:\n     * the browserObject\n     * the string \"domain\"\n     * a boolean indicating whether the service is being advertised (true) or should be removed because advertisments for the service are being terminated (false)\n     * the serviceObject for the specific advertisement (see `hs.bonjour.service`)\n     * a boolean indicating if more advertisements are expected (true) or if the macOS believes that there are no more advertisements to be discovered (false).\n   * if an error occurs, the callback arguments will be:\n     * the browserObject\n     * the string \"error\"\n     * a string specifying the specific error that occurred\n\nReturns:\n * the browserObject\n\nNotes:\n * macOS will indicate when it believes there are no more advertisements of the type specified by `type` in `domain` by marking the last argument to your callback function as false. This is a best guess and may not always be accurate if your network is slow or some servers on your network are particularly slow to respond.\n * In addition, if you leave the browser running this method, you will get future updates when services are removed because of server shutdowns or added because of new servers being booted up.\n * Leaving the browser running does consume some system resources though, so you will have to determine, based upon your specific requirements, if this is a concern for your specific task or not. To terminate the browser when you have rtrieved all of the infomration you reuqire, you can use the [hs.bonjour:stop](#stop) method.\n\n * The special type \"_services._dns-sd._udp.\" can be used to discover the types of services being advertised on your network. The `hs.bonjour.service` objects returned to the callback function cannot actually be resolved, but you can use the `hs.bonjour.service:name` method to create a list of services that are currently present and being advertised.\n   * this special type is used by the shortcut function [hs.bonjour.networkServices](#networkServices) for this specific purpose.\n\n * The special domain \"dns-sd.org.\" can be specified to find services advertised through Wide-Area Service Discovery as described at http://www.dns-sd.org. This can be used to discover a limited number of globally available sites on the internet, especially with a service type of `_http._tcp.`.\n   * In theory, with additional software, you may be able to publish services on your machine for Wide-Area Service discovery using this domain with `hs.bonjour.service.new` but the local dns server requirements and security implications of doing so are beyond the scope of this documentation. You should refer to http://www.dns-sd.org and your local DNS Server administrator or provider for more details."
    },
    "Get or set whether to also browse over peer-to-peer Bluetooth and Wi-Fi, if available.": {
        "prefix": "hs.bonjour:includesPeerToPeer([value]) -> current value | browserObject",
        "body": "hs.bonjour:includesPeerToPeer(${1:[value]})",
        "description": "Get or set whether to also browse over peer-to-peer Bluetooth and Wi-Fi, if available.\n\nParameters:\n * `value` - an optional boolean, default false, value specifying whether to also browse over peer-to-peer Bluetooth and Wi-Fi, if available.\n\nReturns:\n * if `value` is provided, returns the browserObject; otherwise returns the current value for this property\n\nNotes:\n * This property must be set before initiating a search to have an effect."
    },
    "Polls a host for the service types it is advertising via multicast DNS.": {
        "prefix": "hs.bonjour.machineServices(target, callback) -> none",
        "body": "hs.bonjour.machineServices(${1:target}, ${2:callback})",
        "description": "Polls a host for the service types it is advertising via multicast DNS.\n\nParameters:\n * `target`   - a string specifying the target host to query for advertised service types\n * `callback` - a callback function which will be invoked when the service type query has completed. The callback should expect one argument which will either be an array of strings specifying the service types the target is advertising or a string specifying the error that occurred.\n\nReturns:\n * None\n\nNotes:\n * this function may not work for all clients implementing multicast DNS; it has been successfully tested with macOS and Linux targets running the Avahi Daemon service, but has generally returned an error when used with minimalist implementations found in common IOT devices and embedded electronics."
    },
    "Returns a list of service types being advertised on your local network.": {
        "prefix": "hs.bonjour.networkServices(callback, [timeout]) -> none",
        "body": "hs.bonjour.networkServices(${1:callback}, ${2:[timeout]})",
        "description": "Returns a list of service types being advertised on your local network.\n\nParameters:\n * `callback` - a callback function which will be invoked when the services query has completed. The callback should expect one argument: an array of strings specifying the service types discovered on the local network.\n * `timeout`  - an optional number, default 5, specifying the maximum number of seconds after the most recently received service type Hammerspoon should wait trying to identify advertised service types before finishing its query and invoking the callback.\n\nReturns:\n * None\n\nNotes:\n * This function is a convienence wrapper to [hs.bonjour:findServices](#findServices) which collects the results from multiple callbacks made to `findServices` and returns them all at once to the callback function provided as an argument to this function.\n\n * Because this function collects the results of multiple callbacks before invoking its own callback, the `timeout` value specified indicates the maximum number of seconds to wait after the latest value received by `findServices` unless the macOS specifies that it believes there are no more service types to identify.\n   * This is a best guess made by the macOS which may not always be accurate if your local network is particularly slow or if there are machines on your network which are slow to respond.\n   * See [hs.bonjour:findServices](#findServices) for more details if you need to create your own query which can persist for longer periods of time or require termination logic that ignores the macOS's best guess."
    },
    "Creates a new network service browser that finds published services on a network using multicast DNS.": {
        "prefix": "hs.bonjour.new() -> browserObject",
        "body": "hs.bonjour.new()",
        "description": "Creates a new network service browser that finds published services on a network using multicast DNS.\n\nParameters:\n * None\n\nReturns:\n * a new browserObject or nil if an error occurs"
    },
    "Stops a currently running search or resolution for the browser object": {
        "prefix": "hs.bonjour:stop() -> browserObject",
        "body": "hs.bonjour:stop()",
        "description": "Stops a currently running search or resolution for the browser object\n\nParameters:\n * None\n\nReturns:\n * the browserObject\n\nNotes:\n * This method should be invoked when you have identified the services or hosts you require to reduce the consumption of system resources.\n * Invoking this method on an already idle browser will do nothing\n\n * In general, when your callback function for [hs.bonjour:findBrowsableDomains](#findBrowsableDomains), [hs.bonjour:findRegistrationDomains](#findRegistrationDomains), or [hs.bonjour:findServices](#findServices) receives false for the `moreExpected` paramter, you should invoke this method on the browserObject unless there are specific reasons not to. Possible reasons you might want to extend the life of the browserObject are documented within each method."
    },
    "Returns a table listing the addresses for the service represented by the serviceObject": {
        "prefix": "hs.bonjour.service:addresses() -> table",
        "body": "hs.bonjour.service:addresses()",
        "description": "Returns a table listing the addresses for the service represented by the serviceObject\n\nParameters:\n * None\n\nReturns:\n * an array table of strings representing the IPv4 and IPv6 address of the machine which provides the services represented by the serviceObject\n\nNotes:\n * for remote serviceObjects, the table will be empty if this method is invoked before [hs.bonjour.service:resolve](#resolve).\n * for local (published) serviceObjects, this table will always be empty."
    },
    "Returns the domain the service represented by the serviceObject belongs to.": {
        "prefix": "hs.bonjour.service:domain() -> string",
        "body": "hs.bonjour.service:domain()",
        "description": "Returns the domain the service represented by the serviceObject belongs to.\n\nParameters:\n * None\n\nReturns:\n * a string containing the domain the service represented by the serviceObject belongs to.\n\nNotes:\n * for remote serviceObjects, this domain will be the domain the service was discovered in.\n * for local (published) serviceObjects, this domain will be the domain the service is published in; if you did not specify a domain with [hs.bonjour.service.new](#new) then this will be an empty string until [hs.bonjour.service:publish](#publish) is invoked."
    },
    "Returns the hostname of the machine the service represented by the serviceObject belongs to.": {
        "prefix": "hs.bonjour.service:hostname() -> string",
        "body": "hs.bonjour.service:hostname()",
        "description": "Returns the hostname of the machine the service represented by the serviceObject belongs to.\n\nParameters:\n * None\n\nReturns:\n * a string containing the hostname of the machine the service represented by the serviceObject belongs to.\n\nNotes:\n * for remote serviceObjects, this will be nil if this method is invoked before [hs.bonjour.service:resolve](#resolve).\n * for local (published) serviceObjects, this method will always return nil."
    },
    "Get or set whether the service represented by the service object should be published or resolved over peer-to-peer Bluetooth and Wi-Fi, if available.": {
        "prefix": "hs.bonjour.service:includesPeerToPeer([value]) -> boolean | serviceObject",
        "body": "hs.bonjour.service:includesPeerToPeer(${1:[value]})",
        "description": "Get or set whether the service represented by the service object should be published or resolved over peer-to-peer Bluetooth and Wi-Fi, if available.\n\nParameters:\n * `value` - an optional boolean, default false, specifying whether advertising and resoloving should occur over peer-to-peer Bluetooth and Wi-Fi, if available.\n\nReturns:\n * if `value` is provided, returns the serviceObject; otherwise returns the current value.\n\nNotes:\n * if you are changing the value of this property, you must call this method before invoking [hs.bonjour.service:publish](#publish] or [hs.bonjour.service:resolve](#resolve), or after stopping publishing or resolving with [hs.bonjour.service:stop](#stop).\n\n * for remote serviceObjects, this flag determines if resolution and text record monitoring should occur over peer-to-peer network interfaces.\n * for local (published) serviceObjects, this flag determines if advertising should occur over peer-to-peer network interfaces."
    },
    "Monitor the service for changes to its associated text records.": {
        "prefix": "hs.bonjour.service:monitor([callback]) -> serviceObject",
        "body": "hs.bonjour.service:monitor(${1:[callback]})",
        "description": "Monitor the service for changes to its associated text records.\n\nParameters:\n * `callback` - an optional callback function which should expect 3 arguments:\n   * the serviceObject userdata\n   * the string \"txtRecord\"\n   * a table containing key-value pairs specifying the new text records for the service\n\nReturns:\n * the serviceObject\n\nNotes:\n * When monitoring is active, [hs.bonjour.service:txtRecord](#txtRecord) will return the most recent text records observed. If this is the only method by which you check the text records, but you wish to ensure you have the most recent values, you should invoke this method without specifying a callback.\n\n * When [hs.bonjour.service:resolve](#resolve) is invoked, the text records at the time of resolution are captured for retrieval with [hs.bonjour.service:txtRecord](#txtRecord). Subsequent changes to the text records will not be reflected by [hs.bonjour.service:txtRecord](#txtRecord) unless this method has been invoked (with or without a callback function) and is currently active.\n\n * You *can* monitor for text changes on local serviceObjects that were created by [hs.bonjour.service.new](#new) and that you are publishing. This can be used to invoke a callback when one portion of your code makes changes to the text records you are publishing and you need another portion of your code to be aware of this change."
    },
    "Returns the name of the service represented by the serviceObject.": {
        "prefix": "hs.bonjour.service:name() -> string",
        "body": "hs.bonjour.service:name()",
        "description": "Returns the name of the service represented by the serviceObject.\n\nParameters:\n * None\n\nReturns:\n * a string containing the name of the service represented by the serviceObject."
    },
    "Returns a new serviceObject for advertising a service provided by your computer.": {
        "prefix": "hs.bonjour.service.new(name, service, port, [domain]) -> serviceObject",
        "body": "hs.bonjour.${2:service}.new(${1:name}, service, ${3:port}, ${4:[domain]})",
        "description": "Returns a new serviceObject for advertising a service provided by your computer.\n\nParameters:\n * `name`    - The name of the service being advertised. This does not have to be the hostname of the machine. However, if you specify an empty string, the computers hostname will be used.\n * `service` - a string specifying the service being advertised. This string should be specified in the format of '_service._protocol.' where _protocol is one of '_tcp' or '_udp'. Examples of common service types can be found in `hs.bonjour.serviceTypes`.\n * `port`    - an integer specifying the tcp or udp port the service is provided at\n * `domain`  - an optional string specifying the domain you wish to advertise this service in.\n\nReturns:\n * the newly created service object, or nil if there was an error\n\nNotes:\n * If the name specified is not unique on the network for the service type specified, then a number will be appended to the end of the name. This behavior cannot be overridden and can only be detected by checking [hs.bonjour.service:name](#name) after [hs.bonjour.service:publish](#publish) is invoked to see if the name has been changed from what you originally assigned.\n\n * The service will not be advertised until [hs.bonjour.service:publish](#publish) is invoked on the serviceObject returned.\n\n * If you do not specify the `domain` paramter, your default domain, usually \"local\" will be used."
    },
    "Returns the port the service represented by the serviceObject is available on.": {
        "prefix": "hs.bonjour.service:port() -> integer",
        "body": "hs.bonjour.service:port()",
        "description": "Returns the port the service represented by the serviceObject is available on.\n\nParameters:\n * None\n\nReturns:\n * a number specifying the port the service represented by the serviceObject is available on.\n\nNotes:\n * for remote serviceObjects, this will be -1 if this method is invoked before [hs.bonjour.service:resolve](#resolve).\n * for local (published) serviceObjects, this method will always return the number specified when the serviceObject was created with the [hs.bonjour.service.new](#new) constructor."
    },
    "Begin advertising the specified local service.": {
        "prefix": "hs.bonjour.service:publish([allowRename], [callback]) -> serviceObject",
        "body": "hs.bonjour.service:publish(${1:[allowRename]}, ${2:[callback]})",
        "description": "Begin advertising the specified local service.\n\nParameters:\n * `allowRename` - an optional boolean, default true, specifying whether to automatically rename the service if the name and type combination is already being published in the service's domain. If renaming is allowed and a conflict occurs, the service name will have `-#` appended to it where `#` is an increasing integer starting at 2.\n * `callback`    - an optional callback function which should expect 2 or 3 arguments and return none. The arguments to the callback function will be one of the following sets:\n   * on successfull publishing:\n     * the serviceObject userdata\n     * the string \"published\"\n   * if an error occurs during publishing:\n     * the serviceObject userdata\n     * the string \"error\"\n     * a string specifying the specific error that occurred\n\nReturns:\n * the serviceObject\n\nNotes:\n * this method should only be called on serviceObjects which were created with [hs.bonjour.service.new](#new)."
    },
    "Returns a new serviceObject for a remote machine (i.e. not the users computer) on your network offering the specified service.": {
        "prefix": "hs.bonjour.service.remote(name, service, [domain]) -> serviceObject",
        "body": "hs.bonjour.${2:service}.remote(${1:name}, service, ${3:[domain]})",
        "description": "Returns a new serviceObject for a remote machine (i.e. not the users computer) on your network offering the specified service.\n\nParameters:\n * `name`    - a string specifying the name of the advertised service on the network to locate. Often, but not always, this will be the hostname of the machine providing the desired service.\n * `service` - a string specifying the service type. This string should be specified in the format of '_service._protocol.' where _protocol is one of '_tcp' or '_udp'. Examples of common service types can be found in `hs.bonjour.serviceTypes`.\n * `domain`  - an optional string specifying the domain the service belongs to.\n\nReturns:\n * the newly created service object, or nil if there was an error\n\nNotes:\n * In general you should not need to use this constructor, as they will be created automatically for you in the callbacks to `hs.bonjour:findServices`.\n * This method can be used, however, when you already know that a specific service should exist on the network and you wish to resolve its current IP addresses or text records.\n\n * Resolution of the service ip address, hostname, port, and current text records will not occur until [hs.bonjour.service:publish](#publish) is invoked on the serviceObject returned.\n\n * The macOS API specifies that an empty domain string (i.e. specifying the `domain` parameter as \"\" or leaving it off completely) should result in using the default domain for the computer; in my experience this results in an error when attempting to resolve the serviceObject's ip addresses if I don't specify \"local\" explicitely. In general this shouldn't be an issue if you limit your use of remote serviceObjects to those returned by `hs.bonjour:findServices` as the domain of discovery will be included in the object for you automatically. If you do try to create these objects independantly yourself, be aware that attempting to use the \"default domain\" rather than specifying it explicitely will probably not work as expected."
    },
    "Resolve the address and details for a discovered service.": {
        "prefix": "hs.bonjour.service:resolve([timeout], [callback]) -> serviceObject",
        "body": "hs.bonjour.service:resolve(${1:[timeout]}, ${2:[callback]})",
        "description": "Resolve the address and details for a discovered service.\n\nParameters:\n * `timeout`  - an optional number, default 0.0, specifying the maximum number of seconds to attempt to resolve the details for this service. Specifying 0.0 means that the resolution should not timeout and that resolution should continue indefinately.\n * `callback` - an optional callback function which should expect 2 or 3 arguments and return none.\n   * on successfull resolution:\n     * the serviceObject userdata\n     * the string \"resolved\"\n   * if an error occurs during resolution:\n     * the serviceObject userdata\n     * the string \"error\"\n     * a string specifying the specific error that occurred\n   * if `timeout` is specified and is any number other than 0.0, the following will be sent to the callback when the timeout has been reached:\n     * the serviceObject userdata\n     * the string \"stop\"\n\nReturns:\n * the serviceObject\n\nNotes:\n * this method should only be called on serviceObjects which were returned by an `hs.bonjour` browserObject or created with [hs.bonjour.service.remote](#remote).\n\n * For a remote service, this method must be called in order to retrieve the [addresses](#addresses), the [port](#port), the [hostname](#hostname), and any the associated [text records](#txtRecord) for the service.\n * To reduce the usage of system resources, you should generally specify a timeout value or make sure to invoke [hs.bonjour.service:stop](#stop) after you have verified that you have received the details you require."
    },
    "A list of common service types which can used for discovery through this module.": {
        "prefix": "hs.bonjour.serviceTypes",
        "body": "hs.bonjour.serviceTypes",
        "description": "A list of common service types which can used for discovery through this module.\n\nNotes:\n * This list was generated from the output of `avahi-browse -b` and `avahi-browse -bk` from the avahi-daemon/stable,now 0.7-4+b1 armhf package under Raspbian GNU/Linux 10.\n * This list is by no means complete and is provided solely for the purposes of providing examples. Additional service types can be discovered quite easily using Google or other search engines.\n\n * You can view the contents of this table in the Hammerspoon Console by entering `require(\"hs.bonjour\").serviceTypes` into the input field."
    },
    "Stop advertising or resolving the service specified by the serviceObject": {
        "prefix": "hs.bonjour.service:stop() -> serviceObject",
        "body": "hs.bonjour.service:stop()",
        "description": "Stop advertising or resolving the service specified by the serviceObject\n\nParamters:\n * None\n\nReturns:\n * the serviceObject\n\nNotes:\n * this method will stop the advertising of a service which has been published with [hs.bonjour.service:publish](#publish) or is being resolved with [hs.bonjour.service:resolve](#resolve).\n\n * To reduce the usage of system resources, you should make sure to use this method when resolving a remote service if you did not specify a timeout for [hs.bonjour.service:resolve](#resolve) or specified a timeout of 0.0 once you have verified that you have the details you need."
    },
    "Stop monitoring a service for changes to its text records.": {
        "prefix": "hs.bonjour.service:stopMonitoring() -> serviceObject",
        "body": "hs.bonjour.service:stopMonitoring()",
        "description": "Stop monitoring a service for changes to its text records.\n\nParameters:\n * None\n\nReturns:\n * the serviceObject\n\nNotes:\n * This method will stop updating [hs.bonjour.service:txtRecord](#txtRecord) and invoking the callback, if any, assigned with [hs.bonjour.service:monitor](#monitor)."
    },
    "Get or set the text records associated with the serviceObject.": {
        "prefix": "hs.bonjour.service:txtRecord([records]) -> table | serviceObject | false",
        "body": "hs.bonjour.service:txtRecord(${1:[records]})",
        "description": "Get or set the text records associated with the serviceObject.\n\nParameters:\n * `records` - an optional table specifying the text record for the advertised service as a series of key-value entries. All keys and values must be specified as strings.\n\nReturns:\n * if an argument is provided to this method, returns the serviceObject or false if there was a problem setting the text record for this service. If no argument is provided, returns the current table of text records.\n\nNotes:\n * for remote serviceObjects, this method will return nil if invoked before [hs.bonjour.service:resolve](#resolve)\n * setting the text record for a service replaces the existing records for the serviceObject. If the serviceObject is remote, this change is only visible on the local machine. For a service you are advertising, this change will be advertised to other machines.\n\n * Text records are usually used to provide additional information concerning the service and their purpose and meanings are service dependant; for example, when advertising an `_http._tcp.` service, you can specify a specific path on the server by specifying a table of text records containing the \"path\" key."
    },
    "Returns the type of service represented by the serviceObject.": {
        "prefix": "hs.bonjour.service:type() -> string",
        "body": "hs.bonjour.service:type()",
        "description": "Returns the type of service represented by the serviceObject.\n\nParameters:\n * None\n\nReturns:\n * a string containing the type of service represented by the serviceObject."
    },
    "Gets the current ambient brightness": {
        "prefix": "hs.brightness.ambient() -> number",
        "body": "hs.brightness.ambient()",
        "description": "Gets the current ambient brightness\n\nParameters:\n * None\n\nReturns:\n * A number containing the current ambient brightness, measured in lux. If an error occurred, the number will be -1\n\nNotes:\n * Even though external Apple displays include an ambient light sensor, their data is typically not available, so this function will likely only be useful to MacBook users\n\n * On Silicon based macs, this function uses a method similar to that used by `corebrightnessdiag` to retrieve the aggregate lux as reported to `sysdiagnose`.\n * On Intel based macs, the raw sensor data is converted to lux via an algorithm used by Mozilla Firefox and is not guaranteed to give an accurate lux value."
    },
    "Returns the current brightness of the display": {
        "prefix": "hs.brightness.get() -> number",
        "body": "hs.brightness.get()",
        "description": "Returns the current brightness of the display\n\nParameters:\n * None\n\nReturns:\n * A number containing the brightness of the display, between 0 and 100"
    },
    "Sets the display brightness": {
        "prefix": "hs.brightness.set(brightness) -> boolean",
        "body": "hs.${1:brightness}.set(brightness)",
        "description": "Sets the display brightness\n\nParameters:\n * brightness - A number between 0 and 100\n\nReturns:\n * True if the brightness was set, false if not"
    },
    "Fetches information about processes which are currently asserting display/power sleep restrictions": {
        "prefix": "hs.caffeinate.currentAssertions()",
        "body": "hs.caffeinate.currentAssertions()",
        "description": "Fetches information about processes which are currently asserting display/power sleep restrictions\n\nParameters:\n * None\n\nReturns:\n * A table containing information about current power assertions, with process IDs (PID) as the keys, each of which may contain multiple assertions"
    },
    "Informs the OS that the user performed some activity": {
        "prefix": "hs.caffeinate.declareUserActivity([id])",
        "body": "hs.caffeinate.declareUserActivity(${1:[id]})",
        "description": "Informs the OS that the user performed some activity\n\nParameters:\n * id - An option number containing the assertion ID returned by a previous call of this function\n\nReturns:\n * A number containing the ID of the assertion generated by this function\n\nNotes:\n * This is intended to simulate user activity, for example to prevent displays from sleeping, or to wake them up\n * It is not mandatory to re-use assertion IDs if you are calling this function mulitple times, but it is recommended that you do so if the calls are related"
    },
    "Show the Fast User Switch screen (ie a login screen without logging out first)": {
        "prefix": "hs.caffeinate.fastUserSwitch()",
        "body": "hs.caffeinate.fastUserSwitch()",
        "description": "Show the Fast User Switch screen (ie a login screen without logging out first)\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Queries whether a particular sleep type is being prevented": {
        "prefix": "hs.caffeinate.get(sleepType) -> bool or nil",
        "body": "hs.caffeinate.get(${1:sleepType})",
        "description": "Queries whether a particular sleep type is being prevented\n\nParameters:\n * sleepType - A string containing the type of sleep to inspect (see [hs.caffeinate.set()](#set) for information about the possible values)\n\nReturns:\n * True if the specified type of sleep is being prevented, false if not. nil if sleepType was an invalid value"
    },
    "Locks the displays": {
        "prefix": "hs.caffeinate.lockScreen()",
        "body": "hs.caffeinate.lockScreen()",
        "description": "Locks the displays\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This function uses private Apple APIs and could therefore stop working in any given release of macOS without warning."
    },
    "Request the system log out the current user": {
        "prefix": "hs.caffeinate.logOut()",
        "body": "hs.caffeinate.logOut()",
        "description": "Request the system log out the current user\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Request the system reboot": {
        "prefix": "hs.caffeinate.restartSystem()",
        "body": "hs.caffeinate.restartSystem()",
        "description": "Request the system reboot\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Fetches information from the display server about the current session": {
        "prefix": "hs.caffeinate.sessionProperties()",
        "body": "hs.caffeinate.sessionProperties()",
        "description": "Fetches information from the display server about the current session\n\nParameters:\n * None\n\nReturns:\n * A table containing information about the current session, or nil if an error occurred\n\nNotes:\n * The keys in this dictionary will vary based on the current state of the system (e.g. local vs VNC login, screen locked vs unlocked)."
    },
    "Configures the sleep prevention settings": {
        "prefix": "hs.caffeinate.set(sleepType, aValue, acAndBattery)",
        "body": "hs.caffeinate.set(${1:sleepType}, ${2:aValue}, ${3:acAndBattery})",
        "description": "Configures the sleep prevention settings\n\nParameters:\n * sleepType - A string containing the type of sleep to be configured. The value should be one of:\n  * displayIdle - Controls whether the screen will be allowed to sleep (and also the system) if the user is idle.\n  * systemIdle - Controls whether the system will be allowed to sleep if the user is idle (display may still sleep).\n  * system - Controls whether the system will be allowed to sleep for any reason.\n * aValue - A boolean, true if the specified type of sleep should be prevented, false if it should be allowed\n * acAndBattery - A boolean, true if the sleep prevention should apply to both AC power and battery power, false if it should only apply to AC power.\n\nReturns:\n * None\n\nNotes:\n * These calls are not guaranteed to prevent the system sleep behaviours described above. The OS may override them if it feels it must (e.g. if your CPU temperature becomes dangerously high).\n * The acAndBattery argument only applies to the `system` sleep type.\n * You can toggle the acAndBattery state by calling `hs.caffeinate.set()` again and altering the acAndBattery value.\n * The acAndBattery option does not appear to work anymore - it is based on private API that is not allowed in macOS 10.15 when running with the Hardened Runtime (which Hammerspoon now uses)."
    },
    "Request the system log out and power down": {
        "prefix": "hs.caffeinate.shutdownSystem()",
        "body": "hs.caffeinate.shutdownSystem()",
        "description": "Request the system log out and power down\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Request the system start the screensaver (which may lock the screen if the OS is configured to do so)": {
        "prefix": "hs.caffeinate.startScreensaver()",
        "body": "hs.caffeinate.startScreensaver()",
        "description": "Request the system start the screensaver (which may lock the screen if the OS is configured to do so)\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Requests the system to sleep immediately": {
        "prefix": "hs.caffeinate.systemSleep()",
        "body": "hs.caffeinate.systemSleep()",
        "description": "Requests the system to sleep immediately\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Toggles the current state of the specified type of sleep": {
        "prefix": "hs.caffeinate.toggle(sleepType) -> bool or nil",
        "body": "hs.caffeinate.toggle(${1:sleepType})",
        "description": "Toggles the current state of the specified type of sleep\n\nParameters:\n * sleepType - A string containing the type of sleep to toggle (see [hs.caffeinate.set()](#set) for information about the possible values)\n\nReturns:\n * True if the specified type of sleep is being prevented, false if not. nil if sleepType was an invalid value\n\nNotes:\n * If systemIdle is toggled to on, it will apply to AC only"
    },
    "Creates a watcher object for system and display sleep/wake/power events": {
        "prefix": "hs.caffeinate.watcher.new(fn) -> watcher",
        "body": "hs.caffeinate.watcher.new(${1:fn})",
        "description": "Creates a watcher object for system and display sleep/wake/power events\n\nParameters:\n * fn - A function that will be called when system/display events happen. It should accept one parameter:\n  * An event type (see the constants defined above)\n\nReturns:\n * An `hs.caffeinate.watcher` object"
    },
    "The screensaver started": {
        "prefix": "hs.caffeinate.watcher.screensaverDidStart",
        "body": "hs.caffeinate.watcher.screensaverDidStart",
        "description": "The screensaver started"
    },
    "The screensaver stopped": {
        "prefix": "hs.caffeinate.watcher.screensaverDidStop",
        "body": "hs.caffeinate.watcher.screensaverDidStop",
        "description": "The screensaver stopped"
    },
    "The screensaver is about to stop": {
        "prefix": "hs.caffeinate.watcher.screensaverWillStop",
        "body": "hs.caffeinate.watcher.screensaverWillStop",
        "description": "The screensaver is about to stop"
    },
    "The screen was locked": {
        "prefix": "hs.caffeinate.watcher.screensDidLock",
        "body": "hs.caffeinate.watcher.screensDidLock",
        "description": "The screen was locked"
    },
    "The displays have gone to sleep": {
        "prefix": "hs.caffeinate.watcher.screensDidSleep",
        "body": "hs.caffeinate.watcher.screensDidSleep",
        "description": "The displays have gone to sleep"
    },
    "The screen was unlocked": {
        "prefix": "hs.caffeinate.watcher.screensDidUnlock",
        "body": "hs.caffeinate.watcher.screensDidUnlock",
        "description": "The screen was unlocked"
    },
    "The displays have woken from sleep": {
        "prefix": "hs.caffeinate.watcher.screensDidWake",
        "body": "hs.caffeinate.watcher.screensDidWake",
        "description": "The displays have woken from sleep"
    },
    "The session became active, due to fast user switching": {
        "prefix": "hs.caffeinate.watcher.sessionDidBecomeActive",
        "body": "hs.caffeinate.watcher.sessionDidBecomeActive",
        "description": "The session became active, due to fast user switching"
    },
    "The session is no longer active, due to fast user switching": {
        "prefix": "hs.caffeinate.watcher.sessionDidResignActive",
        "body": "hs.caffeinate.watcher.sessionDidResignActive",
        "description": "The session is no longer active, due to fast user switching"
    },
    "Starts the sleep/wake watcher": {
        "prefix": "hs.caffeinate.watcher:start()",
        "body": "hs.caffeinate.watcher:start()",
        "description": "Starts the sleep/wake watcher\n\nParameters:\n * None\n\nReturns:\n * An `hs.caffeinate.watcher` object"
    },
    "Stops the sleep/wake watcher": {
        "prefix": "hs.caffeinate.watcher:stop()",
        "body": "hs.caffeinate.watcher:stop()",
        "description": "Stops the sleep/wake watcher\n\nParameters:\n * None\n\nReturns:\n * An `hs.caffeinate.watcher` object"
    },
    "The system woke from sleep": {
        "prefix": "hs.caffeinate.watcher.systemDidWake",
        "body": "hs.caffeinate.watcher.systemDidWake",
        "description": "The system woke from sleep"
    },
    "The user requested a logout or shutdown": {
        "prefix": "hs.caffeinate.watcher.systemWillPowerOff",
        "body": "hs.caffeinate.watcher.systemWillPowerOff",
        "description": "The user requested a logout or shutdown"
    },
    "The system is preparing to sleep": {
        "prefix": "hs.caffeinate.watcher.systemWillSleep",
        "body": "hs.caffeinate.watcher.systemWillSleep",
        "description": "The system is preparing to sleep"
    },
    "Get or set the accessibility subrole returned by `hs.canvas` objects.": {
        "prefix": "hs.canvas:_accessibilitySubrole([subrole]) -> canvasObject | current value",
        "body": "hs.canvas:_accessibilitySubrole(${1:[subrole]})",
        "description": "Get or set the accessibility subrole returned by `hs.canvas` objects.\n\nParameters:\n * `subrole` - an optional string or explicit nil wihch specifies what accessibility subrole value should be returned when canvas objects are queried through the macOS accessibility framework. See Notes for a discussion of how this value is interpreted. Defaults to `nil`.\n\nReturns:\n * If an argument is specified, returns the canvasObject; otherwise returns the current value.\n\nNotes:\n * Most people will probably not need to use this method; See [hs.canvas.useCustomAccessibilitySubrole](#useCustomAccessibilitySubrole) for a discussion as to why this method may be of use when Hammerspoon is being controlled through the accessibility framework by other applications.\n\n * If a non empty string is specified as the argument to this method, the string will be returned whenever the canvas object's containing window is queried for its accessibility subrole.\n * The other possible values depend upon the value registerd with [hs.canvas.useCustomAccessibilitySubrole](#useCustomAccessibilitySubrole):\n   * If `useCustomAccessibilitySubrole` is set to true (the default):\n     * If an explicit `nil` (the default) is specified fror this method, the string returned when the canvas object's accessibility is queried will be the default macOS subrole for the canvas's window with the string \".Hammerspoon` appended to it.\n     * If the empty string is specified (e.g. `\"\"`), then the default macOS subrole for the canvas's window will be returned.\n   * If `useCustomAccessibilitySubrole` is set to false:\n     * If an explicit `nil` (the default) is specified fror this method, then the default macOS subrole for the canvas's window will be returned.\n     * If the empty string is specified (e.g. `\"\"`), the string returned when the canvas object's accessibility is queried will be the default macOS subrole for the canvas's window with the string \".Hammerspoon` appended to it."
    },
    "Get or set the alpha level of the window containing the canvasObject.": {
        "prefix": "hs.canvas:alpha([alpha]) -> canvasObject | currentValue",
        "body": "hs.canvas:alpha(${1:[alpha]})",
        "description": "Get or set the alpha level of the window containing the canvasObject.\n\nParameters:\n * `alpha` - an optional number specifying the new alpha level (0.0 - 1.0, inclusive) for the canvasObject\n\nReturns:\n * If an argument is provided, the canvas object; otherwise the current value."
    },
    "Appends the elements specified to the canvas.": {
        "prefix": "hs.canvas:appendElements(element, ...) -> canvasObject",
        "body": "hs.canvas:appendElements(${1:element}, ${2:...})",
        "description": "Appends the elements specified to the canvas.\n\nParameters:\n * `element` - a table containing key-value pairs that define the element to be appended to the canvas.  You can specify one or more elements and they will be appended in the order they are listed.\n\nReturns:\n * the canvas object\n\nNotes:\n * You can also specify multiple elements in a table as an array, where each index in the table contains an element table, and use the array as a single argument to this method if this style works better in your code."
    },
    "Assigns a new element to the canvas at the specified index.": {
        "prefix": "hs.canvas:assignElement(elementTable, [index]) -> canvasObject",
        "body": "hs.canvas:assignElement(${1:elementTable}, ${2:[index]})",
        "description": "Assigns a new element to the canvas at the specified index.\n\nParameters:\n * `elementTable` - a table containing key-value pairs that define the element to be added to the canvas.\n * `index`        - an optional integer between 1 and the canvas element count + 1 specifying the index position to put the new element.  Any element currently at that index will be replaced.  Defaults to the canvas element count + 1 (i.e. after the end of the currently defined elements).\n\nReturns:\n * the canvasObject\n\nNotes:\n * When the index specified is the canvas element count + 1, the behavior of this method is the same as [hs.canvas:insertElement](#insertElement); i.e. it adds the new element to the end of the currently defined element list."
    },
    "Canvas Element Attributes": {
        "prefix": "hs.canvas.attributes",
        "body": "hs.canvas.attributes",
        "description": "Canvas Element Attributes\n\n* `type` - specifies the type of canvas element the table represents. This attribute has no default and must be specified for each element in the canvas array. Valid type strings are:\n  * `arc`           - an arc inscribed on a circle, defined by `radius`, `center`, `startAngle`, and `endAngle`.\n  * `canvas`        - an independent canvas object, displayed as an element within the specified frame. Defined by `canvas` and `frame`.\n  * `circle`        - a circle, defined by `radius` and `center`.\n  * `ellipticalArc` - an arc inscribed on an oval, defined by `frame`, `startAngle`, and `endAngle`.\n  * `image`         - an image as defined by one of the `hs.image` constructors.\n  * `oval`          - an oval, defined by `frame`\n  * `points`        - a list of points defined in `coordinates`.\n  * `rectangle`     - a rectangle, optionally with rounded corners, defined by `frame`.\n  * `resetClip`     - a special type -- indicates that the current clipping shape should be reset to the canvas default (the full canvas area).  See `Clipping Example`.  All other attributes, except `action` are ignored.\n  * `segments`      - a list of line segments or bezier curves with control points, defined in `coordinates`.\n  * `text`          - a string or `hs.styledtext` object, defined by `text` and `frame`.\n\n* The following is a list of all valid attributes.  Not all attributes apply to every type, but you can set them for any type.\n  * `action`              - Default `strokeAndFill`. A string specifying the action to take for the element in the array.  The following actions are recognized:\n    * `clip`          - append the shape to the current clipping region for the canvas. Ignored for `canvas`, `image`, and `text` types.\n    * `build`         - do not render the element -- its shape is preserved and the next element in the canvas array is appended to it.  This can be used to create complex shapes or clipping regions. The stroke and fill settings for a complex object created in this manner will be those of the final object of the group. Ignored for `canvas`, `image`, and `text` types.\n    * `fill`          - fill the canvas element, if it is a shape, or display it normally if it is a `canvas`, `image` or `text`.  Ignored for `resetClip`.\n    * `skip`          - ignore this element or its effects.  Can be used to temporarily \"remove\" an object from the canvas.\n    * `stroke`        - stroke (outline) the canvas element, if it is a shape, or display it normally if it is a `canvas`, `image` or `text`.  Ignored for `resetClip`.\n    * `strokeAndFill` - stroke and fill the canvas element, if it is a shape, or display it normally if it is a `canvas`, `image` or `text`.  Ignored for `resetClip`.\n  * `absolutePosition`    - Default `true`. If false, numeric location and size attributes (`frame`, `center`, `radius`, and `coordinates`) will be automatically adjusted when the canvas is resized with [hs.canvas:size](#size) or [hs.canvas:frame](#frame) so that the element remains in the same relative position in the canvas.\n  * `absoluteSize`        - Default `true`. If false, numeric location and size attributes (`frame`, `center`, `radius`, and `coordinates`) will be automatically adjusted when the canvas is resized with [hs.canvas:size](#size) or [hs.canvas:frame](#frame) so that the element maintains the same relative size in the canvas.\n  * `antialias`           - Default `true`.  Indicates whether or not antialiasing should be enabled for the element.\n  * `arcRadii`            - Default `true`. Used by the `arc` and `ellipticalArc` types to specify whether or not line segments from the element's center to the start and end angles should be included in the element's visible portion.  This affects whether the object's stroke is a pie-shape or an arc with a chord from the start angle to the end angle.\n  * `arcClockwise`        - Default `true`.  Used by the `arc` and `ellipticalArc` types to specify whether the arc should be drawn from the start angle to the end angle in a clockwise (true) direction or in a counter-clockwise (false) direction.\n  * `canvas`                - Defaults to nil. A separate canvas object which is to be displayed as an element in this canvas.  The object must not currently belong to a visible window.  Assign nil to this property to release a previously assigned object for use elsewhere as an element or on its own.\n  * `canvasAlpha`           - Default `1.0`.  Specifies the alpha value to apply to the independant canvas element.\n  * `compositeRule`       - A string, default \"sourceOver\", specifying how this element should be combined with earlier elements of the canvas.  See [hs.canvas.compositeTypes](#compositeTypes) for a list of valid strings and their descriptions.\n  * `center`              - Default `{ x = \"50%\", y = \"50%\" }`.  Used by the `circle` and `arc` types to specify the center of the canvas element.  The `x` and `y` fields can be specified as numbers or as a string. When specified as a string, the value is treated as a percentage of the canvas size.  See the section on [percentages](#percentages) for more information.\n  * `clipToPath`          - Default `false`.   Specifies whether the clipping regions should be temporarily limited to the element's shape while rendering this element or not.  This can be used to produce crisper edges, as seen with `hs.drawing` but reduces stroke width granularity for widths less than 1.0 and causes occasional \"missing\" lines with the `segments` element type. Ignored for the `canvas`, `image`, `point`, and `text` types.\n  * `closed`              - Default `false`.  Used by the `segments` type to specify whether or not the shape defined by the lines and curves defined should be closed (true) or open (false).  When an object is closed, an implicit line is stroked from the final point back to the initial point of the coordinates listed.\n  * `coordinates`         - An array containing coordinates used by the `segments` and `points` types to define the lines and curves or points that make up the canvas element.  The following keys are recognized and may be specified as numbers or strings (see the section on [percentages](#percentages)).\n    * `x`   - required for `segments` and `points`, specifying the x coordinate of a point.\n    * `y`   - required for `segments` and `points`, specifying the y coordinate of a point.\n    * `c1x` - optional for `segments, specifying the x coordinate of the first control point used to draw a bezier curve between this point and the previous point.  Ignored for `points` and if present in the first coordinate in the `coordinates` array.\n    * `c1y` - optional for `segments, specifying the y coordinate of the first control point used to draw a bezier curve between this point and the previous point.  Ignored for `points` and if present in the first coordinate in the `coordinates` array.\n    * `c2x` - optional for `segments, specifying the x coordinate of the second control point used to draw a bezier curve between this point and the previous point.  Ignored for `points` and if present in the first coordinate in the `coordinates` array.\n    * `c2y` - optional for `segments, specifying the y coordinate of the second control point used to draw a bezier curve between this point and the previous point.  Ignored for `points` and if present in the first coordinate in the `coordinates` array.\n  * `endAngle`            - Default `360.0`. Used by the `arc` and `ellipticalArc` to specify the ending angle position for the inscribed arc.\n  * `fillColor`           - Default `{ red = 1.0 }`.  Specifies the color used to fill the canvas element when the `action` is set to `fill` or `strokeAndFill` and `fillGradient` is equal to `none`.  Ignored for the `canvas`, `image`, `points`, and `text` types.\n  * `fillGradient`        - Default \"none\".  A string specifying whether a fill gradient should be used instead of the fill color when the action is `fill` or `strokeAndFill`.  May be \"none\", \"linear\", or \"radial\".\n  * `fillGradientAngle`   - Default 0.0.  Specifies the direction of a linear gradient when `fillGradient` is linear.\n  * `fillGradientCenter`  - Default `{ x = 0.0, y = 0.0 }`. Specifies the relative center point within the elements bounds of a radial gradient when `fillGradient` is `radial`.  The `x` and `y` fields must both be between -1.0 and 1.0 inclusive.\n  * `fillGradientColors`  - Default `{ { white = 0.0 }, { white = 1.0 } }`.  Specifies the colors to use for the gradient when `fillGradient` is not `none`.  You must specify at least two colors, each of which must be convertible into the RGB color space (i.e. they cannot be an image being used as a color pattern).  The gradient will blend from the first to the next, and so on until the last color.  If more than two colors are specified, the \"color stops\" will be placed at evenly spaced intervals within the element.\n  * `flatness`            - Default `0.6`.  A number which specifies the accuracy (or smoothness) with which curves are rendered. It is also the maximum error tolerance (measured in pixels) for rendering curves, where smaller numbers give smoother curves at the expense of more computation.\n  * `flattenPath`         - Default `false`. Specifies whether curved line segments should be converted into straight line approximations. The granularity of the approximations is controlled by the path's current flatness value.\n  * `frame`               - Default `{ x = \"0%\", y = \"0%\", h = \"100%\", w = \"100%\" }`.  Used by the `rectangle`, `oval`, `ellipticalArc`, `text`, `canvas` and `image` types to specify the element's position and size.  When the key value for `x`, `y`, `h`, or `w` are specified as a string, the value is treated as a percentage of the canvas size.  See the section on [percentages](#percentages) for more information.\n  * `id`                  - An optional string or number which is included in mouse callbacks to identify the element which was the target of the mouse event.  If this is not specified for an element, it's index position is used instead.\n  * `image`               - Defaults to a blank image.  Used by the `image` type to specify an `hs.image` object to display as an image.\n  * `imageAlpha`          - Defaults to `1.0`.  A number between 0.0 and 1.0 specifying the alpha value to be applied to the image specified by `image`.  Note that if an image is a template image, then this attribute will internally default to `0.5` unless explicitly set for the element.\n  * `imageAlignment`      - Default \"center\". A string specifying the alignment of the image within the canvas element's frame.  Valid values for this attribute are \"center\", \"bottom\", \"topLeft\", \"bottomLeft\", \"bottomRight\", \"left\", \"right\", \"top\", and \"topRight\".\n  * `imageAnimationFrame` - Default `0`. An integer specifying the image frame to display when the image is from an animated GIF.  This attribute is ignored for other image types.  May be specified as a negative integer indicating that the image frame should be calculated from the last frame and calculated backwards (i.e. specifying `-1` selects the last frame for the GIF.)\n  * `imageAnimates`       - Default `false`. A boolean specifying whether or not an animated GIF should be animated or if only a single frame should be shown.  Ignored for other image types.\n  * `imageScaling`        - Default \"scalePropertionally\".  A string specifying how the image should be scaled within the canvas element's frame.  Valid values for this attribute are:\n    * `scaleToFit`          - shrink the image, preserving the aspect ratio, to fit the drawing frame only if the image is larger than the drawing frame.\n    * `shrinkToFit`         - shrink or expand the image to fully fill the drawing frame.  This does not preserve the aspect ratio.\n    * `none`                - perform no scaling or resizing of the image.\n    * `scaleProportionally` - shrink or expand the image to fully fill the drawing frame, preserving the aspect ration.\n  * `miterLimit`          - Default `10.0`. The limit at which miter joins are converted to bevel join when `strokeJoinStyle` is `miter`.  The miter limit helps you avoid spikes at the junction of two line segments.  When the ratio of the miter length\u2014the diagonal length of the miter join\u2014to the line thickness exceeds the miter limit, the joint is converted to a bevel join. Ignored for the `canvas`, `text`, and `image` types.\n  * `padding`             - Default `0.0`. When an element specifies position information by percentage (i.e. as a string), the actual frame used for calculating position values is inset from the canvas frame on all sides by this amount. If you are using shadows with your elements, the shadow position is not included in the element's size and position specification; this attribute can be used to provide extra space for the shadow to be fully rendered within the canvas.\n  * `radius`              - Default \"50%\". Used by the `arc` and `circle` types to specify the radius of the circle for the element. May be specified as a string or a number.  When specified as a string, the value is treated as a percentage of the canvas size.  See the section on [percentages](#percentages) for more information.\n  * `reversePath`         - Default `false`.  Specifies drawing direction for the canvas element.  By default, canvas elements are drawn from the point nearest the origin (top left corner) in a clockwise direction.  Setting this to true causes the element to be drawn in a counter-clockwise direction. This will mostly affect fill and stroke dash patterns, but can also be used with clipping regions to create cut-outs.  Ignored for `canvas`, `image`, and `text` types.\n  * `roundedRectRadii`    - Default `{ xRadis = 0.0, yRadius = 0.0 }`.\n  * `shadow`              - Default `{ blurRadius = 5.0, color = { alpha = 1/3 }, offset = { h = -5.0, w = 5.0 } }`.  Specifies the shadow blurring, color, and offset to be added to an element which has `withShadow` set to true.\n  * `startAngle`          - Default `0.0`. Used by the `arc` and `ellipticalArc` to specify the starting angle position for the inscribed arc.\n  * `strokeCapStyle`      - Default \"butt\". A string which specifies the shape of the endpoints of an open path when stroked.  Primarily noticeable for lines rendered with the `segments` type.  Valid values for this attribute are \"butt\", \"round\", and \"square\".\n  * `strokeColor`         - Default `{ white = 0 }`.  Specifies the stroke (outline) color for a canvas element when the action is set to `stroke` or `strokeAndFill`.  Ignored for the `canvas`, `text`, and `image` types.\n  * `strokeDashPattern`   - Default `{}`.  Specifies an array of numbers specifying a dash pattern for stroked lines when an element's `action` attribute is set to `stroke` or `strokeAndFill`.  The numbers in the array alternate with the first element specifying a dash length in points, the second specifying a gap length in points, the third a dash length, etc.  The array repeats to fully stroke the element.  Ignored for the `canvas`, `image`, and `text` types.\n  * `strokeDashPhase`     - Default `0.0`.  Specifies an offset, in points, where the dash pattern specified by `strokeDashPattern` should start. Ignored for the `canvas`, `image`, and `text` types.\n  * `strokeJoinStyle`     - Default \"miter\".  A string which specifies the shape of the joints between connected segments of a stroked path.  Valid values for this attribute are \"miter\", \"round\", and \"bevel\".  Ignored for element types of `canvas`, `image`, and `text`.\n  * `strokeWidth`         - Default `1.0`.  Specifies the width of stroked lines when an element's action is set to `stroke` or `strokeAndFill`.  Ignored for the `canvas`, `image`, and `text` element types.\n  * `text`                - Default `\"\"`.  Specifies the text to display for a `text` element.  This may be specified as a string, or as an `hs.styledtext` object.\n  * `textAlignment`       - Default `natural`. A string specifying the alignment of the text within a canvas element of type `text`.  This field is ignored if the text is specified as an `hs.styledtext` object.  Valid values for this attributes are:\n    * `left`      - the text is visually left aligned.\n    * `right`     - the text is visually right aligned.\n    * `center`    - the text is visually center aligned.\n    * `justified` - the text is justified\n    * `natural`   - the natural alignment of the text\u2019s script\n  * `textColor`           - Default `{ white = 1.0 }`.  Specifies the color to use when displaying the `text` element type, if the text is specified as a string.  This field is ignored if the text is specified as an `hs.styledtext` object.\n  * `textFont`            - Defaults to the default system font.  A string specifying the name of thefont to use when displaying the `text` element type, if the text is specified as a string.  This field is ignored if the text is specified as an `hs.styledtext` object.\n  * `textLineBreak`       - Default `wordWrap`. A string specifying how to wrap text which exceeds the canvas element's frame for an element of type `text`.  This field is ignored if the text is specified as an `hs.styledtext` object.  Valid values for this attribute are:\n    * `wordWrap`       - wrap at word boundaries, unless the word itself doesn\u2019t fit on a single line\n    * `charWrap`       - wrap before the first character that doesn\u2019t fit\n    * `clip`           - do not draw past the edge of the drawing object frame\n    * `truncateHead`   - the line is displayed so that the end fits in the frame and the missing text at the beginning of the line is indicated by an ellipsis\n    * `truncateTail`   - the line is displayed so that the beginning fits in the frame and the missing text at the end of the line is indicated by an ellipsis\n    * `truncateMiddle` - the line is displayed so that the beginning and end fit in the frame and the missing text in the middle is indicated by an ellipsis\n  * `textSize`            - Default `27.0`.  Specifies the font size to use when displaying the `text` element type, if the text is specified as a string.  This field is ignored if the text is specified as an `hs.styledtext` object.\n  * `trackMouseByBounds`  - Default `false`. If true, mouse events are based on the element's bounds (smallest rectangle which completely contains the element); otherwise, mouse events are based on the visible portion of the canvas element.\n  * `trackMouseEnterExit` - Default `false`.  Generates a callback when the mouse enters or exits the canvas element.  For `canvas` and `text` types, the `frame` of the element defines the boundaries of the tracking area.\n  * `trackMouseDown`      - Default `false`.  Generates a callback when mouse button is clicked down while the cursor is within the canvas element.  For `canvas` and `text` types, the `frame` of the element defines the boundaries of the tracking area.\n  * `trackMouseUp`        - Default `false`.  Generates a callback when mouse button is released while the cursor is within the canvas element.  For `canvas` and `text` types, the `frame` of the element defines the boundaries of the tracking area.\n  * `trackMouseMove`      - Default `false`.  Generates a callback when the mouse cursor moves within the canvas element.  For `canvas` and `text` types, the `frame` of the element defines the boundaries of the tracking area.\n  * `transformation`      - Default `{ m11 = 1.0, m12 = 0.0, m21 = 0.0, m22 = 1.0, tX = 0.0, tY = 0.0 }`. Specifies a matrix transformation to apply to the element before displaying it.  Transformations may include rotation, translation, scaling, skewing, etc.\n  * `windingRule`         - Default \"nonZero\".  A string specifying the winding rule in effect for the canvas element. May be \"nonZero\" or \"evenOdd\".  The winding rule determines which portions of an element to fill. This setting will only have a visible effect on compound elements (built with the `build` action) or elements of type `segments` when the object is made from lines which cross.\n  * `withShadow`          - Default `false`. Specifies whether a shadow effect should be applied to the canvas element.  Ignored for the `text` type."
    },
    "Get or set the window behavior settings for the canvas object using labels defined in [hs.canvas.windowBehaviors](#windowBehaviors).": {
        "prefix": "hs.canvas:behavior([behavior]) -> canvasObject | currentValue",
        "body": "hs.canvas:behavior(${1:[behavior]})",
        "description": "Get or set the window behavior settings for the canvas object using labels defined in [hs.canvas.windowBehaviors](#windowBehaviors).\n\nParameters:\n * `behavior` - if present, the behavior should be a combination of values found in [hs.canvas.windowBehaviors](#windowBehaviors) describing the window behavior.  The behavior should be specified as one of the following:\n   * integer - a number representing the behavior which can be created by combining values found in [hs.canvas.windowBehaviors](#windowBehaviors) with the logical or operator.\n   * string  - a single key from [hs.canvas.windowBehaviors](#windowBehaviors) which will be toggled in the current window behavior.\n   * table   - a list of keys from [hs.canvas.windowBehaviors](#windowBehaviors) which will be combined to make the final behavior by combining their values with the logical or operator.\n\nReturns:\n * if an argument is provided, then the canvasObject is returned; otherwise the current behavior value is returned."
    },
    "Get or set the window behavior settings for the canvas object using labels defined in [hs.canvas.windowBehaviors](#windowBehaviors)._1": {
        "prefix": "hs.canvas:behaviorAsLabels(behaviorTable) -> canvasObject | currentValue",
        "body": "hs.canvas:behaviorAsLabels(${1:behaviorTable})",
        "description": "Get or set the window behavior settings for the canvas object using labels defined in [hs.canvas.windowBehaviors](#windowBehaviors).\n\nParameters:\n * behaviorTable - an optional table of strings and/or integers specifying the desired window behavior for the canvas object.\n\nReturns:\n * If an argument is provided, the canvas object; otherwise the current value as a table of strings."
    },
    "Places the canvas object on top of normal windows": {
        "prefix": "hs.canvas:bringToFront([aboveEverything]) -> canvasObject",
        "body": "hs.canvas:bringToFront(${1:[aboveEverything]})",
        "description": "Places the canvas object on top of normal windows\n\nParameters:\n * aboveEverything - An optional boolean value that controls how far to the front the canvas should be placed. Defaults to false.\n   * if true, place the canvas on top of all windows (including the dock and menubar and fullscreen windows).\n   * if false, place the canvas above normal windows, but below the dock, menubar and fullscreen windows.\n\nReturns:\n * The canvas object\n\nNotes:\n * As of macOS Sierra and later, if you want a `hs.canvas` object to appear above full-screen windows you must hide the Hammerspoon Dock icon first using: `hs.dockicon.hide()`"
    },
    "Get or set the element default specified by keyName.": {
        "prefix": "hs.canvas:canvasDefaultFor(keyName, [newValue]) -> canvasObject | currentValue",
        "body": "hs.canvas:canvasDefaultFor(${1:keyName}, ${2:[newValue]})",
        "description": "Get or set the element default specified by keyName.\n\nParameters:\n * `keyName` - the element default to examine or modify\n * `value`   - an optional new value to set as the default fot his canvas when not specified explicitly in an element declaration.\n\nReturns:\n * If an argument is provided, the canvas object; otherwise the current value.\n\nNotes:\n * Not all keys will apply to all element types.\n * Currently set and built-in defaults may be retrieved in a table with [hs.canvas:canvasDefaults](#canvasDefaults)."
    },
    "Returns a list of the key names for the attributes set for the canvas defaults.": {
        "prefix": "hs.canvas:canvasDefaultKeys([module]) -> table",
        "body": "hs.canvas:canvasDefaultKeys(${1:[module]})",
        "description": "Returns a list of the key names for the attributes set for the canvas defaults.\n\nParameters:\n * `module` - an optional boolean flag, default false, indicating whether the key names for the module defaults (true) should be included in the list.  If false, only those defaults which have been explicitly set for the canvas are included.\n\nReturns:\n * a table containing the key names for the defaults which are set for this canvas. May also optionally include key names for all attributes which have a default value defined by the module."
    },
    "Get a table of the default key-value pairs which apply to the canvas.": {
        "prefix": "hs.canvas:canvasDefaults([module]) -> table",
        "body": "hs.canvas:canvasDefaults(${1:[module]})",
        "description": "Get a table of the default key-value pairs which apply to the canvas.\n\nParameters:\n * `module` - an optional boolean flag, default false, indicating whether module defaults (true) should be included in the table.  If false, only those defaults which have been explicitly set for the canvas are returned.\n\nReturns:\n * a table containing key-value pairs for the defaults which apply to the canvas.\n\nNotes:\n * Not all keys will apply to all element types.\n * To change the defaults for the canvas, use [hs.canvas:canvasDefaultFor](#canvasDefaultFor)."
    },
    "Returns an array containing the elements defined for this canvas.  Each array entry will be a table containing the key-value pairs which have been set for that canvas element.": {
        "prefix": "hs.canvas:canvasElements() -> table",
        "body": "hs.canvas:canvasElements()",
        "description": "Returns an array containing the elements defined for this canvas.  Each array entry will be a table containing the key-value pairs which have been set for that canvas element.\n\nParameters:\n * None\n\nReturns:\n * an array of element tables which are defined for the canvas."
    },
    "Get or set whether or not regions of the canvas which are not otherwise covered by an element with mouse tracking enabled should generate a callback for mouse events.": {
        "prefix": "hs.canvas:canvasMouseEvents([down], [up], [enterExit], [move]) -> canvasObject | current values",
        "body": "hs.canvas:canvasMouseEvents(${1:[down]}, ${2:[up]}, ${3:[enterExit]}, ${4:[move]})",
        "description": "Get or set whether or not regions of the canvas which are not otherwise covered by an element with mouse tracking enabled should generate a callback for mouse events.\n\nParameters:\n * `down`      - an optional boolean, or nil placeholder, specifying whether or not the mouse button being pushed down should generate a callback for the canvas areas not otherwise covered by an element with mouse tracking enabled.\n * `up`        - an optional boolean, or nil placeholder, specifying whether or not the mouse button being released should generate a callback for the canvas areas not otherwise covered by an element with mouse tracking enabled.\n * `enterExit` - an optional boolean, or nil placeholder, specifying whether or not the mouse pointer entering or exiting the canvas bounds should generate a callback for the canvas areas not otherwise covered by an element with mouse tracking enabled.\n * `move`      - an optional boolean, or nil placeholder, specifying whether or not the mouse pointer moving within the canvas bounds should generate a callback for the canvas areas not otherwise covered by an element with mouse tracking enabled.\n\nReturns:\n * If any arguments are provided, returns the canvas Object, otherwise returns the current values as four separate boolean values (i.e. not in a table).\n\nNotes:\n * Each value that you wish to set must be provided in the order given above, but you may specify a position as `nil` to indicate that whatever it's current state, no change should be applied.  For example, to activate a callback for entering and exiting the canvas without changing the current callback status for up or down button clicks, you could use: `hs.canvas:canvasMouseTracking(nil, nil, true)`.\n\n * Use [hs.canvas:mouseCallback](#mouseCallback) to set the callback function.  The identifier field in the callback's argument list will be \"_canvas_\", but otherwise identical to those specified in [hs.canvas:mouseCallback](#mouseCallback)."
    },
    "Get or set whether or not clicking on a canvas with a click callback defined should bring all of Hammerspoon's open windows to the front.": {
        "prefix": "hs.canvas:clickActivating([flag]) -> canvasObject | currentValue",
        "body": "hs.canvas:clickActivating(${1:[flag]})",
        "description": "Get or set whether or not clicking on a canvas with a click callback defined should bring all of Hammerspoon's open windows to the front.\n\nParameters:\n * `flag` - an optional boolean indicating whether or not clicking on a canvas with a click callback function defined should activate Hammerspoon and bring its windows forward. Defaults to true.\n\nReturns:\n * If an argument is provided, returns the canvas object; otherwise returns the current setting.\n\nNotes:\n * Setting this to false changes a canvas object's AXsubrole value and may affect the results of filters used with `hs.window.filter`, depending upon how they are defined."
    },
    "A table containing the possible compositing rules for elements within the canvas.": {
        "prefix": "hs.canvas.compositeTypes[]",
        "body": "hs.canvas.compositeTypes",
        "description": "A table containing the possible compositing rules for elements within the canvas.\n\nCompositing rules specify how an element assigned to the canvas is combined with the earlier elements of the canvas. The default compositing rule for the canvas is `sourceOver`, but each element of the canvas can be assigned a composite type which overrides this default for the specific element.\n\nThe available types are as follows:\n * `clear`           - Transparent. (R = 0)\n * `copy`            - Source image. (R = S)\n * `sourceOver`      - Source image wherever source image is opaque, and destination image elsewhere. (R = S + D*(1 - Sa))\n * `sourceIn`        - Source image wherever both images are opaque, and transparent elsewhere. (R = S*Da)\n * `sourceOut`       - Source image wherever source image is opaque but destination image is transparent, and transparent elsewhere. (R = S*(1 - Da))\n * `sourceAtop`      - Source image wherever both images are opaque, destination image wherever destination image is opaque but source image is transparent, and transparent elsewhere. (R = S*Da + D*(1 - Sa))\n * `destinationOver` - Destination image wherever destination image is opaque, and source image elsewhere. (R = S*(1 - Da) + D)\n * `destinationIn`   - Destination image wherever both images are opaque, and transparent elsewhere. (R = D*Sa)\n * `destinationOut`  - Destination image wherever destination image is opaque but source image is transparent, and transparent elsewhere. (R = D*(1 - Sa))\n * `destinationAtop` - Destination image wherever both images are opaque, source image wherever source image is opaque but destination image is transparent, and transparent elsewhere. (R = S*(1 - Da) + D*Sa)\n * `XOR`             - Exclusive OR of source and destination images. (R = S*(1 - Da) + D*(1 - Sa)). Works best with black and white images and is not recommended for color contexts.\n * `plusDarker`      - Sum of source and destination images, with color values approaching 0 as a limit. (R = MAX(0, (1 - D) + (1 - S)))\n * `plusLighter`     - Sum of source and destination images, with color values approaching 1 as a limit. (R = MIN(1, S + D))\n\nIn each equation, R is the resulting (premultiplied) color, S is the source color, D is the destination color, Sa is the alpha value of the source color, and Da is the alpha value of the destination color.\n\nThe `source` object is the individual element as it is rendered in order within the canvas, and the `destination` object is the combined state of the previous elements as they have been composited within the canvas."
    },
    "Creates a copy of the canvas.": {
        "prefix": "hs.canvas:copy() -> canvasObject",
        "body": "hs.canvas:copy()",
        "description": "Creates a copy of the canvas.\n\nParameters:\n * None\n\nReturns:\n * a copy of the canvas\n\nNotes:\n * The copy of the canvas will be identical in all respectes except:\n   * The new canvas will not have a callback function assigned, even if the original canvas does.\n   * The new canvas will not initially be visible, even if the original is.\n * The new canvas is an independant entity -- any subsequent changes to either canvas will not be reflected in the other canvas.\n\n * This method allows you to display a canvas in multiple places or use it as a canvas element multiple times."
    },
    "Returns a table containing the default font, size, color, and paragraphStyle used by `hs.canvas` for text drawing objects.": {
        "prefix": "hs.canvas.defaultTextStyle() -> `hs.styledtext` attributes table",
        "body": "hs.canvas.defaultTextStyle()",
        "description": "Returns a table containing the default font, size, color, and paragraphStyle used by `hs.canvas` for text drawing objects.\n\nParameters:\n * None\n\nReturns:\n * a table containing the default style attributes `hs.canvas` uses for text drawing objects in the `hs.styledtext` attributes table format.\n\nNotes:\n * This method is intended to be used in conjunction with `hs.styledtext` to create styledtext objects that are based on, or a slight variation of, the defaults used by `hs.canvas`."
    },
    "Destroys the canvas object, optionally fading it out first (if currently visible).": {
        "prefix": "hs.canvas:delete([fadeOutTime]) -> none",
        "body": "hs.canvas:delete(${1:[fadeOutTime]})",
        "description": "Destroys the canvas object, optionally fading it out first (if currently visible).\n\nParameters:\n * `fadeOutTime` - An optional number of seconds over which to fade out the canvas object. Defaults to zero.\n\nReturns:\n * None\n\nNotes:\n * This method is automatically called during garbage collection, notably during a Hammerspoon termination or reload, with a fade time of 0."
    },
    "Sets or remove a callback for accepting dragging and dropping items onto the canvas.": {
        "prefix": "hs.canvas:draggingCallback(fn | nil) -> canvasObject",
        "body": "hs.canvas:draggingCallback(${1:fn | nil})",
        "description": "Sets or remove a callback for accepting dragging and dropping items onto the canvas.\n\nParameters:\n * `fn`   - A function, can be nil, that will be called when an item is dragged onto the canvas.  An explicit nil, the default, disables drag-and-drop for this canvas.\n\nReturns:\n * The canvas object\n\nNotes:\n * The callback function should expect 3 arguments and optionally return 1: the canvas object itself, a message specifying the type of dragging event, and a table containing details about the item(s) being dragged.  The key-value pairs of the details table will be the following:\n   * `pasteboard` - the name of the pasteboard that contains the items being dragged\n   * `sequence`   - an integer that uniquely identifies the dragging session.\n   * `mouse`      - a point table containing the location of the mouse pointer within the canvas corresponding to when the callback occurred.\n   * `operation`  - a table containing string descriptions of the type of dragging the source application supports. Potentially useful for determining if your callback function should accept the dragged item or not.\n\n* The possible messages the callback function may receive are as follows:\n   * \"enter\"   - the user has dragged an item into the canvas.  When your callback receives this message, you can optionally return false to indicate that you do not wish to accept the item being dragged.\n   * \"exit\"    - the user has moved the item out of the canvas; if the previous \"enter\" callback returned false, this message will also occur when the user finally releases the items being dragged.\n   * \"receive\" - indicates that the user has released the dragged object while it is still within the canvas frame.  When your callback receives this message, you can optionally return false to indicate to the sending application that you do not want to accept the dragged item -- this may affect the animations provided by the sending application.\n\n * You can use the sequence number in the details table to match up an \"enter\" with an \"exit\" or \"receive\" message.\n\n * You should capture the details you require from the drag-and-drop operation during the callback for \"receive\" by using the pasteboard field of the details table and the `hs.pasteboard` module.  Because of the nature of \"promised items\", it is not guaranteed that the items will still be on the pasteboard after your callback completes handling this message.\n\n * A canvas object can only accept drag-and-drop items when its window level is at [hs.canvas.windowLevels.dragging](#windowLevels) or lower.\n * a canvas object can only accept drag-and-drop items when it accepts mouse events.  You must define a [hs.canvas:mouseCallback](#mouseCallback) function, even if it is only a placeholder, e.g. `hs.canvas:mouseCallback(function() end)`"
    },
    "Get or set the attribute `key` for the canvas element at the specified index.": {
        "prefix": "hs.canvas:elementAttribute(index, key, [value]) -> canvasObject | current value",
        "body": "hs.canvas:elementAttribute(${1:index}, ${2:key}, ${3:[value]})",
        "description": "Get or set the attribute `key` for the canvas element at the specified index.\n\nParameters:\n * `index` - the index of the canvas element whose attribute is to be retrieved or set.\n * `key`   - the key name of the attribute to get or set.\n * `value` - an optional value to assign to the canvas element's attribute.\n\nReturns:\n * if a value for the attribute is specified, returns the canvas object; otherwise returns the current value for the specified attribute."
    },
    "Returns the smallest rectangle which can fully contain the canvas element at the specified index.": {
        "prefix": "hs.canvas:elementBounds(index) -> rectTable",
        "body": "hs.canvas:elementBounds(${1:index})",
        "description": "Returns the smallest rectangle which can fully contain the canvas element at the specified index.\n\nParameters:\n * `index` - the index of the canvas element to get the bounds for\n\nReturns:\n * a rect table containing the smallest rectangle which can fully contain the canvas element.\n\nNotes:\n * For many elements, this will be the same as the element frame.  For items without a frame (e.g. `segments`, `circle`, etc.) this will be the smallest rectangle which can fully contain the canvas element as specified by it's attributes."
    },
    "Returns the number of elements currently defined for the canvas object.": {
        "prefix": "hs.canvas:elementCount() -> integer",
        "body": "hs.canvas:elementCount()",
        "description": "Returns the number of elements currently defined for the canvas object.\n\nParameters:\n * None\n\nReturns:\n * the number of elements currently defined for the canvas object."
    },
    "Returns a list of the key names for the attributes set for the canvas element at the specified index.": {
        "prefix": "hs.canvas:elementKeys(index, [optional]) -> table",
        "body": "hs.canvas:elementKeys(${1:index}, ${2:[optional]})",
        "description": "Returns a list of the key names for the attributes set for the canvas element at the specified index.\n\nParameters:\n * `index`    - the index of the element to get the assigned key list from.\n * `optional` - an optional boolean, default false, indicating whether optional, but unset, keys relevant to this canvas object should also be included in the list returned.\n\nReturns:\n * a table containing the keys that are set for this canvas element.  May also optionally include keys which are not specifically set for this element but use inherited values from the canvas or module defaults.\n\nNotes:\n * Any attribute which has been explicitly set for the element will be included in the key list (even if it is ignored for the element type).  If the `optional` flag is set to true, the *additional* attribute names added to the list will only include those which are relevant to the element type."
    },
    "Returns the list of attributes and their specifications that are recognized for canvas elements by this module.": {
        "prefix": "hs.canvas.elementSpec() -> table",
        "body": "hs.canvas.elementSpec()",
        "description": "Returns the list of attributes and their specifications that are recognized for canvas elements by this module.\n\nParameters:\n * None\n\nReturns:\n * A table containing the attributes and specifications defined for this module.\n\nNotes:\n * This is primarily for debugging purposes and may be removed in the future."
    },
    "Get or set the frame of the canvasObject.": {
        "prefix": "hs.canvas:frame([rect]) -> canvasObject | currentValue",
        "body": "hs.canvas:frame(${1:[rect]})",
        "description": "Get or set the frame of the canvasObject.\n\nParameters:\n * rect - An optional rect-table containing the co-ordinates and size the canvas object should be moved and set to\n\nReturns:\n * If an argument is provided, the canvas object; otherwise the current value.\n\nNotes:\n * a rect-table is a table with key-value pairs specifying the new top-left coordinate on the screen of the canvas (keys `x`  and `y`) and the new size (keys `h` and `w`).  The table may be crafted by any method which includes these keys, including the use of an `hs.geometry` object.\n\n * elements in the canvas that have the `absolutePosition` attribute set to false will be moved so that their relative position within the canvas remains the same with respect to the new size.\n * elements in the canvas that have the `absoluteSize` attribute set to false will be resized so that their relative size with respect to the canvas remains the same with respect to the new size."
    },
    "Provides specification information for the recognized attributes, or the specific attribute specified.": {
        "prefix": "hs.canvas.help([attribute]) -> string",
        "body": "hs.canvas.help(${1:[attribute]})",
        "description": "Provides specification information for the recognized attributes, or the specific attribute specified.\n\nParameters:\n * `attribute` - an optional string specifying an element attribute. If this argument is not provided, all attributes are listed.\n\nReturns:\n * a string containing some of the information provided by the [hs.canvas.elementSpec](#elementSpec) in a manner that is easy to reference from the Hammerspoon console."
    },
    "Hides the canvas object": {
        "prefix": "hs.canvas:hide([fadeOutTime]) -> canvasObject",
        "body": "hs.canvas:hide(${1:[fadeOutTime]})",
        "description": "Hides the canvas object\n\nParameters:\n * `fadeOutTime` - An optional number of seconds over which to fade out the canvas object. Defaults to zero.\n\nReturns:\n * The canvas object"
    },
    "Returns an image of the canvas contents as an `hs.image` object.": {
        "prefix": "hs.canvas:imageFromCanvas() -> hs.image object",
        "body": "hs.canvas:imageFromCanvas()",
        "description": "Returns an image of the canvas contents as an `hs.image` object.\n\nParameters:\n * None\n\nReturns:\n * an `hs.image` object\n\nNotes:\n * The canvas does not have to be visible in order for an image to be generated from it."
    },
    "Insert a new element into the canvas at the specified index.": {
        "prefix": "hs.canvas:removeElement([index]) -> canvasObject",
        "body": "hs.canvas:removeElement(${1:[index]})",
        "description": "Insert a new element into the canvas at the specified index.\n\nParameters:\n * `index`        - an optional integer between 1 and the canvas element count specifying the index of the canvas element to remove. Any elements that follow, will be moved one position down in the element array.  Defaults to the canvas element count (i.e. the last element of the currently defined elements).\n\nReturns:\n * the canvasObject"
    },
    "Returns whether or not the canvas is currently occluded (hidden by other windows, off screen, etc).": {
        "prefix": "hs.canvas:isOccluded() -> boolean",
        "body": "hs.canvas:isOccluded()",
        "description": "Returns whether or not the canvas is currently occluded (hidden by other windows, off screen, etc).\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the canvas is currently being occluded.\n\nNotes:\n * If any part of the canvas is visible (even if that portion of the canvas does not contain any canvas elements), then the canvas is not considered occluded.\n * a canvas which is completely covered by one or more opaque windows is considered occluded; however, if the windows covering the canvas are not opaque, then the canvas is not occluded.\n * a canvas that is currently hidden or with a height of 0 or a width of 0 is considered occluded.\n * See also [hs.canvas:isShowing](#isShowing)."
    },
    "Returns whether or not the canvas is currently being shown.": {
        "prefix": "hs.canvas:isShowing() -> boolean",
        "body": "hs.canvas:isShowing()",
        "description": "Returns whether or not the canvas is currently being shown.\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the canvas is currently being shown (true) or is currently hidden (false).\n\nNotes:\n * This method only determines whether or not the canvas is being shown or is hidden -- it does not indicate whether or not the canvas is currently off screen or is occluded by other objects.\n * See also [hs.canvas:isOccluded](#isOccluded)."
    },
    "Returns whether or not the canvas is currently showing and is (at least partially) visible on screen.": {
        "prefix": "hs.canvas:isVisible() -> boolean",
        "body": "hs.canvas:isVisible()",
        "description": "Returns whether or not the canvas is currently showing and is (at least partially) visible on screen.\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the canvas is currently visible.\n\nNotes:\n * This is syntactic sugar for `not hs.canvas:isOccluded()`.\n * See [hs.canvas:isOccluded](#isOccluded) for more details."
    },
    "Sets the window level more precisely than sendToBack and bringToFront.": {
        "prefix": "hs.drawing:setLevel(theLevel) -> drawingObject",
        "body": "hs.drawing:setLevel(${1:theLevel})",
        "description": "Sets the window level more precisely than sendToBack and bringToFront.\n\nParameters:\n * theLevel - the level specified as a number or as a string where this object should be drawn.  If it is a string, it must match one of the keys in `hs.drawing.windowLevels`.\n\nReturns:\n * the drawing object\n\nNotes:\n * see the notes for `hs.drawing.windowLevels`\n * These levels may be unable to explicitly place drawing objects around full-screen macOS windows"
    },
    "Returns a table specifying the size of the rectangle which can fully render the text with the specified style so that is will be completely visible.": {
        "prefix": "hs.canvas:minimumTextSize([index], text) -> table",
        "body": "hs.canvas:minimumTextSize(${1:[index]}, ${2:text})",
        "description": "Returns a table specifying the size of the rectangle which can fully render the text with the specified style so that is will be completely visible.\n\nParameters:\n * `index` - an optional index specifying the element in the canvas which contains the text attributes which should be used when determining the size of the text. If not provided, the canvas defaults will be used instead. Ignored if `text` is an hs.styledtext object.\n * `text`  - a string or hs.styledtext object specifying the text.\n\nReturns:\n * a size table specifying the height and width of a rectangle which could fully contain the text when displayed in the canvas\n\nNotes:\n * Multi-line text (separated by a newline or return) is supported.  The height will be for the multiple lines and the width returned will be for the longest line."
    },
    "Sets a callback for mouse events with respect to the canvas": {
        "prefix": "hs.canvas:mouseCallback(mouseCallbackFn) -> canvasObject",
        "body": "hs.canvas:mouseCallback(${1:mouseCallbackFn})",
        "description": "Sets a callback for mouse events with respect to the canvas\n\nParameters:\n * `mouseCallbackFn`   - A function, can be nil, that will be called when a mouse event occurs within the canvas, and an element beneath the mouse's current position has one of the `trackMouse...` attributes set to true.\n\nReturns:\n * The canvas object\n\nNotes:\n * The callback function should expect 5 arguments: the canvas object itself, a message specifying the type of mouse event, the canvas element `id` (or index position in the canvas if the `id` attribute is not set for the element), the x position of the mouse when the event was triggered within the rendered portion of the canvas element, and the y position of the mouse when the event was triggered within the rendered portion of the canvas element.\n * See also [hs.canvas:canvasMouseEvents](#canvasMouseEvents) for tracking mouse events in regions of the canvas not covered by an element with mouse tracking enabled.\n\n * The following mouse attributes may be set to true for a canvas element and will invoke the callback with the specified message:\n   * `trackMouseDown`      - indicates that a callback should be invoked when a mouse button is clicked down on the canvas element.  The message will be \"mouseDown\".\n   * `trackMouseUp`        - indicates that a callback should be invoked when a mouse button has been released over the canvas element.  The message will be \"mouseUp\".\n   * `trackMouseEnterExit` - indicates that a callback should be invoked when the mouse pointer enters or exits the  canvas element.  The message will be \"mouseEnter\" or \"mouseExit\".\n   * `trackMouseMove`      - indicates that a callback should be invoked when the mouse pointer moves within the canvas element.  The message will be \"mouseMove\".\n\n * The callback mechanism uses reverse z-indexing to determine which element will receive the callback -- the topmost element of the canvas which has enabled callbacks for the specified message will be invoked.\n\n * No distinction is made between the left, right, or other mouse buttons. If you need to determine which specific button was pressed, use `hs.eventtap.checkMouseButtons()` within your callback to check.\n\n * The hit point detection occurs by comparing the mouse pointer location to the rendered content of each individual canvas object... if an object which obscures a lower object does not have mouse tracking enabled, the lower object will still receive the event if it does have tracking enabled.\n\n * Clipping regions which remove content from the visible area of a rendered object are ignored for the purposes of element hit-detection."
    },
    "Create a new canvas object at the specified coordinates": {
        "prefix": "hs.canvas.new(rect) -> canvasObject",
        "body": "hs.canvas.new(${1:rect})",
        "description": "Create a new canvas object at the specified coordinates\n\nParameters:\n * `rect` - A rect-table containing the co-ordinates and size for the canvas object\n\nReturns:\n * a new, empty, canvas object, or nil if the canvas cannot be created with the specified coordinates\n\nNotes:\n * The size of the canvas defines the visible area of the canvas -- any portion of a canvas element which extends past the canvas's edges will be clipped.\n * a rect-table is a table with key-value pairs specifying the top-left coordinate on the screen for the canvas (keys `x`  and `y`) and the size (keys `h` and `w`) of the canvas. The table may be crafted by any method which includes these keys, including the use of an `hs.geometry` object."
    },
    "An array-like method for accessing the attributes for the canvas element at the specified index": {
        "prefix": "hs.canvas.object[index]",
        "body": "hs.canvas.object[index]",
        "description": "An array-like method for accessing the attributes for the canvas element at the specified index\n\nMetamethods are assigned to the canvas object so that you can refer to individual elements of the canvas as if the canvas object was an array.  Each element is represented by a table of key-value pairs, where each key represents an attribute for that element.  Valid index numbers range from 1 to [hs.canvas:elementCount()](#elementCount) when getting an element or getting or setting one of its attributes, and from 1 to [hs.canvas:elementCount()](#elementCount) + 1 when assign an element table to an index in the canvas.  For example:\n\n~~~lua\nc = require(\"hs.canvas\")\na = c.new{ x = 100, y = 100, h = 100, w = 100 }:show()\na:insertElement({ type = \"rectangle\", id = \"part1\", fillColor = { blue = 1 } })\na:insertElement({ type = \"circle\", id = \"part2\", fillColor = { green = 1 } })\n~~~\ncan also be expressed as:\n~~~lua\nc = require(\"hs.canvas\")\na = c.new{ x = 100, y = 100, h = 100, w = 100 }:show()\na[1] = { type = \"rectangle\", id = \"part1\", fillColor = { blue = 1 } }\na[2] = { type = \"circle\", id = \"part2\", fillColor = { green = 1 } }\n~~~\n\nYou can change a canvas element's attributes using this same style: `a[2].fillColor.alpha = .5` will adjust the alpha value for element 2 of the canvas without adjusting any of the other color fields.  To replace the color entirely, assign it like this: `a[2].fillColor = { white = .5, alpha = .25 }`\n\nThe canvas defaults can also be accessed with the `_default` field like this: `a._default.strokeWidth = 5`.\n\nAttributes which have a string specified as their `id` attribute can also be accessed as if the `id` where a `key` in the table-like canvas: e.g. `a.part2.action = \"skip\"`\n\nIt is important to note that these methods are a convenience and that the canvas object is not a true table.  The tables are generated dynamically as needed; as such `hs.inspect` cannot properly display them; however, you can just type in the element or element attribute you wish to see expanded in the Hammerspoon console (or in a `print` command) to see the assigned attributes, e.g. `a[1]` or `a[2].fillColor`, and an inspect-like output will be provided.\n\nAttributes which allow using a string to specify a percentage (see [percentages](#percentages)) can also be retrieved as their actual number for the canvas's current size by appending `_raw` to the attribute name, e.g. `a[2].frame_raw`.\n\nBecause the canvas object is actually a Lua userdata, and not a real table, you cannot use the `table.insert` and `table.remove` functions on it.  For inserting or removing an element in any position except at the end of the canvas, you must still use [hs.canvas:insertElement](#insertElement) and [hs.canvas:removeElement](#removeElement).\n\nYou can, however, remove the last element with `a[#a] = nil`.\n\nTo print out all of the elements in the canvas with: `for i, v in ipairs(a) do print(v) end`.  The `pairs` iterator will also work, and will work on element sub-tables (transformations, fillColor and strokeColor, etc.), but this iterator does not guarantee order."
    },
    "Moves canvas object above canvas2, or all canvas objects in the same presentation level, if canvas2 is not given.": {
        "prefix": "hs.canvas:orderAbove([canvas2]) -> canvasObject",
        "body": "hs.canvas:orderAbove(${1:[canvas2]})",
        "description": "Moves canvas object above canvas2, or all canvas objects in the same presentation level, if canvas2 is not given.\n\nParameters:\n * `canvas2` -An optional canvas object to place the canvas object above.\n\nReturns:\n * The canvas object\n\nNotes:\n * If the canvas object and canvas2 are not at the same presentation level, this method will will move the canvas object as close to the desired relationship as possible without changing the canvas object's presentation level. See [hs.canvas.level](#level)."
    },
    "Moves canvas object below canvas2, or all canvas objects in the same presentation level, if canvas2 is not given.": {
        "prefix": "hs.canvas:orderBelow([canvas2]) -> canvasObject",
        "body": "hs.canvas:orderBelow(${1:[canvas2]})",
        "description": "Moves canvas object below canvas2, or all canvas objects in the same presentation level, if canvas2 is not given.\n\nParameters:\n * `canvas2` -An optional canvas object to place the canvas object below.\n\nReturns:\n * The canvas object\n\nNotes:\n * If the canvas object and canvas2 are not at the same presentation level, this method will will move the canvas object as close to the desired relationship as possible without changing the canvas object's presentation level. See [hs.canvas.level](#level)."
    },
    "Canvas attributes which specify the location and size of canvas elements can be specified with an absolute position or as a percentage of the canvas size.": {
        "prefix": "hs.canvas.percentages",
        "body": "hs.canvas.percentages",
        "description": "Canvas attributes which specify the location and size of canvas elements can be specified with an absolute position or as a percentage of the canvas size.\n\nPercentages may be assigned to the following attributes:\n * `frame`       - the frame used by the `rectangle`, `oval`, `ellipticalArc`, `text`, and `image` types.  The `x` and `w` fields will be a percentage of the canvas's width, and the `y` and `h` fields will be a percentage of the canvas's height.\n * `center`      - the center point for the `circle` and `arc` types.  The `x` field will be a percentage of the canvas's width and the `y` field will be a percentage of the canvas's height.\n * `radius`      - the radius for the `circle` and `arc` types.  The radius will be a percentage of the canvas's width.\n * `coordinates` - the point coordinates used by the `segments` and `points` types.  X coordinates (fields `x`, `c1x`, and `c2x`) will be a percentage of the canvas's width, and Y coordinates (fields `y`, `c1y`, and `c2y`) will be a percentage of the canvas's height.\n\nPercentages are assigned to these fields as a string.  If the number in the string ends with a percent sign (%), then the percentage is the whole number which precedes the percent sign.  If no percent sign is present, the percentage is expected in decimal format (e.g. \"1.0\" is the same as \"100%\").\n\nBecause a shadow applied to a canvas element is not considered as part of the element's bounds, you can also set the `padding` attribute to a positive number of points to inset the calculated values by from each edge of the canvas's frame so that the shadow will be fully visible within the canvas, even when an element is set to a width and height of \"100%\"."
    },
    "Replaces all of the elements in the canvas with the elements specified.  Shortens or lengthens the canvas element count if necessary to accomodate the new canvas elements.": {
        "prefix": "hs.canvas:replaceElements(element, ...) -> canvasObject",
        "body": "hs.canvas:replaceElements(${1:element}, ${2:...})",
        "description": "Replaces all of the elements in the canvas with the elements specified.  Shortens or lengthens the canvas element count if necessary to accomodate the new canvas elements.\n\nParameters:\n * `element` - a table containing key-value pairs that define the element to be assigned to the canvas.  You can specify one or more elements and they will be appended in the order they are listed.\n\nReturns:\n * the canvas object\n\nNotes:\n * You can also specify multiple elements in a table as an array, where each index in the table contains an element table, and use the array as a single argument to this method if this style works better in your code."
    },
    "Rotates an element about the point specified, or the elements center if no point is specified.": {
        "prefix": "hs.canvas:rotateElement(index, angle, [point], [append]) -> canvasObject",
        "body": "hs.canvas:rotateElement(${1:index}, ${2:angle}, ${3:[point]}, ${4:[append]})",
        "description": "Rotates an element about the point specified, or the elements center if no point is specified.\n\nParameters:\n * `index`  - the index of the element to rotate\n * `angle`  - the angle to rotate the object in a clockwise direction\n * `point`  - an optional point table, defaulting to the elements center, specifying the point around which the object should be rotated\n * `append` - an optional boolean, default false, specifying whether or not the rotation transformation matrix should be appended to the existing transformation assigned to the element (true) or replace it (false).\n\nReturns:\n * the canvas object\n\nNotes:\n * a point-table is a table with key-value pairs specifying a coordinate in the canvas (keys `x`  and `y`). The table may be crafted by any method which includes these keys, including the use of an `hs.geometry` object.\n * The center of the object is determined by getting the element's bounds with [hs.canvas:elementBounds](#elementBounds).\n * If the third argument is a boolean value, the `point` argument is assumed to be the element's center and the boolean value is used as the `append` argument.\n\n * This method uses [hs.canvas.matrix](MATRIX.md) to generate the rotation transformation and provides a wrapper for `hs.canvas.matrix.translate(x, y):rotate(angle):translate(-x, -y)` which is then assigned or appended to the element's existing `transformation` attribute."
    },
    "Places the canvas object behind normal windows, between the desktop wallpaper and desktop icons": {
        "prefix": "hs.canvas:sendToBack() -> canvasObject",
        "body": "hs.canvas:sendToBack()",
        "description": "Places the canvas object behind normal windows, between the desktop wallpaper and desktop icons\n\nParameters:\n * None\n\nReturns:\n * The canvas object"
    },
    "Displays the canvas object": {
        "prefix": "hs.canvas:show([fadeInTime]) -> canvasObject",
        "body": "hs.canvas:show(${1:[fadeInTime]})",
        "description": "Displays the canvas object\n\nParameters:\n * `fadeInTime` - An optional number of seconds over which to fade in the canvas object. Defaults to zero.\n\nReturns:\n * The canvas object\n\nNotes:\n * if the canvas is in use as an element in another canvas, this method will result in an error."
    },
    "Get or set the size of a canvas object": {
        "prefix": "hs.canvas:size([size]) -> canvasObject | currentValue",
        "body": "hs.canvas:size(${1:[size]})",
        "description": "Get or set the size of a canvas object\n\nParameters:\n * `size` - An optional size-table specifying the width and height the canvas object should be resized to\n\nReturns:\n * If an argument is provided, the canvas object; otherwise the current value.\n\nNotes:\n * a size-table is a table with key-value pairs specifying the size (keys `h` and `w`) the canvas should be resized to. The table may be crafted by any method which includes these keys, including the use of an `hs.geometry` object.\n\n * elements in the canvas that have the `absolutePosition` attribute set to false will be moved so that their relative position within the canvas remains the same with respect to the new size.\n * elements in the canvas that have the `absoluteSize` attribute set to false will be resized so that their relative size with respect to the canvas remains the same with respect to the new size."
    },
    "Get or set the top-left coordinate of the canvas object": {
        "prefix": "hs.canvas:topLeft([point]) -> canvasObject | currentValue",
        "body": "hs.canvas:topLeft(${1:[point]})",
        "description": "Get or set the top-left coordinate of the canvas object\n\nParameters:\n * `point` - An optional point-table specifying the new coordinate the top-left of the canvas object should be moved to\n\nReturns:\n * If an argument is provided, the canvas object; otherwise the current value.\n\nNotes:\n * a point-table is a table with key-value pairs specifying the new top-left coordinate on the screen of the canvas (keys `x`  and `y`). The table may be crafted by any method which includes these keys, including the use of an `hs.geometry` object."
    },
    "Get or set the matrix transformation which is applied to every element in the canvas before being individually processed and added to the canvas.": {
        "prefix": "hs.canvas:transformation([matrix]) -> canvasObject | current value",
        "body": "hs.canvas:transformation(${1:[matrix]})",
        "description": "Get or set the matrix transformation which is applied to every element in the canvas before being individually processed and added to the canvas.\n\nParameters:\n * `matrix` - an optional table specifying the matrix table, as defined by the [hs.canvas.matrix](MATRIX.md) module, to be applied to every element of the canvas, or an explicit `nil` to reset the transformation to the identity matrix.\n\nReturns:\n * if an argument is provided, returns the canvasObject, otherwise returns the current value\n\nNotes:\n * An example use for this method would be to change the canvas's origin point { x = 0, y = 0 } from the lower left corner of the canvas to somewhere else, like the middle of the canvas."
    },
    "Get or set whether or not canvas objects use a custom accessibility subrole for the contaning system window.": {
        "prefix": "hs.canvas.useCustomAccessibilitySubrole([state]) -> boolean",
        "body": "hs.canvas.useCustomAccessibilitySubrole(${1:[state]})",
        "description": "Get or set whether or not canvas objects use a custom accessibility subrole for the contaning system window.\n\nParameters:\n * `state` - an optional boolean, default true, specifying whether or not canvas containers should use a custom accessibility subrole.\n\nReturns:\n * the current, possibly changed, value as a boolean\n\nNotes:\n * Under some conditions, it has been observed that Hammerspoon's `hs.window.filter` module will misidentify Canvas and Drawing objects as windows of the Hammerspoon application that it should consider when evaluating its filters. To eliminate this, `hs.canvas` objects (and previously `hs.drawing` objects, which are now deprecated and pass through to `hs.canvas`) were given a nonstandard accessibilty subrole to prevent them from being included. This has caused some issues with third party tools, like Yabai, which also use the accessibility subroles for determining what actions it may take with Hammerspoon windows.\n\n * By passing `false` to this function, all canvas objects will revert to specifying the standard subrole for the containing windows by default and should work as expected with third party tools. Note that this may cause issues or slowdowns if you are also using `hs.window.filter`; a more permanent solution is being considered.\n\n * If you need to control the subrole of canvas objects more specifically, or only for some canvas objects, see [hs.canvas:_accessibilitySubrole](#_accessibilitySubrole)."
    },
    "Get or set whether or not the canvas object should be rendered by the view or by Core Animation.": {
        "prefix": "hs.canvas:wantsLayer([flag]) -> canvasObject | currentValue",
        "body": "hs.canvas:wantsLayer(${1:[flag]})",
        "description": "Get or set whether or not the canvas object should be rendered by the view or by Core Animation.\n\nParameters:\n * `flag` - optional boolean (default false) which indicates whether the canvas object should be rendered by the containing view (false) or by Core Animation (true).\n\nReturns:\n * If an argument is provided, the canvas object; otherwise the current value.\n\nNotes:\n * This method can help smooth the display of small text objects on non-Retina monitors."
    },
    "Array of window behavior labels for determining how a canvas or drawing object is handled in Spaces and Expos\u00e9": {
        "prefix": "hs.canvas.windowBehaviors[]",
        "body": "hs.canvas.windowBehaviors",
        "description": "Array of window behavior labels for determining how a canvas or drawing object is handled in Spaces and Expos\u00e9\n\n* `default`                   - The window can be associated to one space at a time.\n* `canJoinAllSpaces`          - The window appears in all spaces. The menu bar behaves this way.\n* `moveToActiveSpace`         - Making the window active does not cause a space switch; the window switches to the active space.\n\nOnly one of these may be active at a time:\n\n* `managed`                   - The window participates in Spaces and Expos\u00e9. This is the default behavior if windowLevel is equal to NSNormalWindowLevel.\n* `transient`                 - The window floats in Spaces and is hidden by Expos\u00e9. This is the default behavior if windowLevel is not equal to NSNormalWindowLevel.\n* `stationary`                - The window is unaffected by Expos\u00e9; it stays visible and stationary, like the desktop window.\n\nThe following have no effect on `hs.canvas` or `hs.drawing` objects, but are included for completness and are expected to be used by future additions.\n\nOnly one of these may be active at a time:\n\n* `participatesInCycle`       - The window participates in the window cycle for use with the Cycle Through Windows Window menu item.\n* `ignoresCycle`              - The window is not part of the window cycle for use with the Cycle Through Windows Window menu item.\n\nOnly one of these may be active at a time:\n\n* `fullScreenPrimary`         - A window with this collection behavior has a fullscreen button in the upper right of its titlebar.\n* `fullScreenAuxiliary`       - Windows with this collection behavior can be shown on the same space as the fullscreen window.\n\nOnly one of these may be active at a time (Available in OS X 10.11 and later):\n\n* `fullScreenAllowsTiling`    - A window with this collection behavior be a full screen tile window and does not have to have `fullScreenPrimary` set.\n* `fullScreenDisallowsTiling` - A window with this collection behavior cannot be made a fullscreen tile window, but it can have `fullScreenPrimary` set.  You can use this setting to prevent other windows from being placed in the window\u2019s fullscreen tile."
    },
    "A table of predefined window levels usable with [hs.canvas:level](#level)": {
        "prefix": "hs.canvas.windowLevels",
        "body": "hs.canvas.windowLevels",
        "description": "A table of predefined window levels usable with [hs.canvas:level](#level)\n\nPredefined levels are:\n * _MinimumWindowLevelKey - lowest allowed window level\n * desktop\n * desktopIcon            - [hs.canvas:sendToBack](#sendToBack) is equivalent to this level - 1\n * normal                 - normal application windows\n * tornOffMenu\n * floating               - equivalent to [hs.canvas:bringToFront(false)](#bringToFront); where \"Always Keep On Top\" windows are usually set\n * modalPanel             - modal alert dialog\n * utility\n * dock                   - level of the Dock\n * mainMenu               - level of the Menubar\n * status\n * popUpMenu              - level of a menu when displayed (open)\n * overlay\n * help\n * dragging\n * screenSaver            - equivalent to [hs.canvas:bringToFront(true)](#bringToFront)\n * assistiveTechHigh\n * cursor\n * _MaximumWindowLevelKey - highest allowed window level\n\nNotes:\n * These key names map to the constants used in CoreGraphics to specify window levels and may not actually be used for what the name might suggest. For example, tests suggest that an active screen saver actually runs at a level of 2002, rather than at 1000, which is the window level corresponding to kCGScreenSaverWindowLevelKey.\n * Each window level is sorted separately and [hs.canvas:orderAbove](#orderAbove) and [hs.canvas:orderBelow](#orderBelow) only arrange windows within the same level.\n * If you use Dock hiding (or in 10.11, Menubar hiding) please note that when the Dock (or Menubar) is popped up, it is done so with an implicit orderAbove, which will place it above any items you may also draw at the Dock (or MainMenu) level.\n\n * A canvas object with a [hs.canvas:draggingCallback](#draggingCallback) function can only accept drag-and-drop items when its window level is at `hs.canvas.windowLevels.dragging` or lower.\n * A canvas object with a [hs.canvas:mouseCallback](#mouseCallback) function can only reliably receive mouse click events when its window level is at `hs.canvas.windowLevels.desktopIcon` + 1 or higher."
    },
    "Appends the specified matrix transformations to the matrix and returns the new matrix.  This method cannot be used as a constructor.": {
        "prefix": "hs.canvas.matrix:append(matrix) -> matrixObject",
        "body": "hs.canvas.${1:matrix}:append(matrix)",
        "description": "Appends the specified matrix transformations to the matrix and returns the new matrix.  This method cannot be used as a constructor.\n\nParameters:\n * `matrix` - the table to append to the current matrix.\n\nReturns:\n * the new matrix\n\nNotes:\n * Mathematically this method multiples the original matrix by the new one and returns the result of the multiplication.\n * You can use this method to \"stack\" additional transformations on top of existing transformations, without having to know what the existing transformations in effect for the canvas element are."
    },
    "Specifies the identity matrix.  Resets all existing transformations when applied as a method to an existing matrixObject.": {
        "prefix": "hs.canvas.matrix.identity() -> matrixObject",
        "body": "hs.canvas.matrix.identity()",
        "description": "Specifies the identity matrix.  Resets all existing transformations when applied as a method to an existing matrixObject.\n\nParameters:\n * None\n\nReturns:\n * the identity matrix.\n\nNotes:\n * The identity matrix can be thought of as \"apply no transformations at all\" or \"render as specified\".\n * Mathematically this is represented as:\n~~~\n[ 1,  0,  0 ]\n[ 0,  1,  0 ]\n[ 0,  0,  1 ]\n~~~"
    },
    "Generates the mathematical inverse of the matrix.  This method cannot be used as a constructor.": {
        "prefix": "hs.canvas.matrix:invert() -> matrixObject",
        "body": "hs.canvas.matrix:invert()",
        "description": "Generates the mathematical inverse of the matrix.  This method cannot be used as a constructor.\n\nParameters:\n * None\n\nReturns:\n * the inverted matrix.\n\nNotes:\n * Inverting a matrix which represents a series of transformations has the effect of reversing or undoing the original transformations.\n * This is useful when used with [hs.canvas.matrix.append](#append) to undo a previously applied transformation without actually replacing all of the transformations which may have been applied to a canvas element."
    },
    "Prepends the specified matrix transformations to the matrix and returns the new matrix.  This method cannot be used as a constructor.": {
        "prefix": "hs.canvas.matrix:prepend(matrix) -> matrixObject",
        "body": "hs.canvas.${1:matrix}:prepend(matrix)",
        "description": "Prepends the specified matrix transformations to the matrix and returns the new matrix.  This method cannot be used as a constructor.\n\nParameters:\n * `matrix` - the table to append to the current matrix.\n\nReturns:\n * the new matrix\n\nNotes:\n * Mathematically this method multiples the new matrix by the original one and returns the result of the multiplication.\n * You can use this method to apply a transformation *before* the currently applied transformations, without having to know what the existing transformations in effect for the canvas element are."
    },
    "Applies a rotation of the specified number of degrees to the transformation matrix.  This method can be used as a constructor or a method.": {
        "prefix": "hs.canvas.matrix:rotate(angle) -> matrixObject",
        "body": "hs.canvas.matrix:rotate(${1:angle})",
        "description": "Applies a rotation of the specified number of degrees to the transformation matrix.  This method can be used as a constructor or a method.\n\nParameters:\n * `angle` - the number of degrees to rotate in a clockwise direction.\n\nReturns:\n * the new matrix\n\nNotes:\n * The rotation of an element this matrix is applied to will be rotated about the origin (zero point).  To rotate an object about another point (its center for example), prepend a translation to the point to rotate about, and append a translation reversing the initial translation.\n   * e.g. `hs.canvas.matrix.translate(x, y):rotate(angle):translate(-x, -y)`"
    },
    "Applies a scaling transformation to the matrix.  This method can be used as a constructor or a method.": {
        "prefix": "hs.canvas.matrix:scale(xFactor, [yFactor]) -> matrixObject",
        "body": "hs.canvas.matrix:scale(${1:xFactor}, ${2:[yFactor]})",
        "description": "Applies a scaling transformation to the matrix.  This method can be used as a constructor or a method.\n\nParameters:\n * `xFactor` - the scaling factor to apply to the object in the horizontal orientation.\n * `yFactor` - an optional argument specifying a different scaling factor in the vertical orientation.  If this argument is not provided, the `xFactor` argument will be used for both orientations.\n\nReturns:\n * the new matrix"
    },
    "Applies a shearing transformation to the matrix.  This method can be used as a constructor or a method.": {
        "prefix": "hs.canvas.matrix:shear(xFactor, [yFactor]) -> matrixObject",
        "body": "hs.canvas.matrix:shear(${1:xFactor}, ${2:[yFactor]})",
        "description": "Applies a shearing transformation to the matrix.  This method can be used as a constructor or a method.\n\nParameters:\n * `xFactor` - the shearing factor to apply to the object in the horizontal orientation.\n * `yFactor` - an optional argument specifying a different shearing factor in the vertical orientation.  If this argument is not provided, the `xFactor` argument will be used for both orientations.\n\nReturns:\n * the new matrix"
    },
    "Applies a translation transformation to the matrix.  This method can be used as a constructor or a method.": {
        "prefix": "hs.canvas.matrix:translate(x, y) -> matrixObject",
        "body": "hs.canvas.matri${1:x}:translate(x, ${2:y})",
        "description": "Applies a translation transformation to the matrix.  This method can be used as a constructor or a method.\n\nParameters:\n * `x` - the distance to translate the object in the horizontal direction.\n * `y` - the distance to translate the object in the vertical direction.\n\nReturns:\n * the new matrix"
    },
    "Get or attach/detach a toolbar to/from the chooser.": {
        "prefix": "hs.chooser:attachedToolbar([toolbar | nil]) -> hs.chooser object | currentValue",
        "body": "hs.chooser:attachedToolbar(${1:[toolbar | nil]})",
        "description": "Get or attach/detach a toolbar to/from the chooser.\n\nParameters:\n * `toolbar` - if an `hs.webview.toolbar` object is specified, it will be attached to the chooser.  If an explicit nil is specified, the current toolbar will be removed from the chooser.\n\nReturns:\n * if a toolbarObject or explicit nil is specified, returns the hs.chooser object; otherwise returns the current toolbarObject or nil, if no toolbar is attached to the chooser.\n\nNotes:\n * this method is a convenience wrapper for the `hs.webview.toolbar.attachToolbar` function.\n\n * If the toolbarObject is currently attached to another window when this method is called, it will be detached from the original window and attached to the chooser.  If you wish to attach the same toolbar to multiple chooser objects, see `hs.webview.toolbar:copy`."
    },
    "Sets the background of the chooser between light and dark": {
        "prefix": "hs.chooser:bgDark([beDark]) -> hs.chooser object or boolean",
        "body": "hs.chooser:bgDark(${1:[beDark]})",
        "description": "Sets the background of the chooser between light and dark\n\nParameters:\n * beDark - A optional boolean, true to be dark, false to be light. If this parameter is omitted, the current setting will be returned\n\nReturns:\n * The `hs.chooser` object or a boolean, true if the window is dark, false if it is light\n\nNotes:\n * The text colors will not automatically change when you toggle the darkness of the chooser window, you should also set appropriate colors with `hs.chooser:fgColor()` and `hs.chooser:subTextColor()`"
    },
    "Cancels the chooser": {
        "prefix": "hs.chooser:cancel() -> hs.chooser object",
        "body": "hs.chooser:cancel()",
        "description": "Cancels the chooser\n\nParameters:\n * None\n\nReturns:\n * The `hs.chooser` object"
    },
    "Sets the choices for a chooser": {
        "prefix": "hs.chooser:choices(choices) -> hs.chooser object",
        "body": "hs.chooser:${1:choices}(choices)",
        "description": "Sets the choices for a chooser\n\nParameters:\n * choices - Either a function to call when the list of choices is needed, or nil to remove any existing choices/callback, or a table containing static choices.\n\nReturns:\n * The `hs.chooser` object\n\nNotes:\n * The table of choices (be it provided statically, or returned by the callback) must contain at least the following keys for each choice:\n  * text - A string or hs.styledtext object that will be shown as the main text of the choice\n * Each choice may also optionally contain the following keys:\n  * subText - A string or hs.styledtext object that will be shown underneath the main text of the choice\n  * image - An `hs.image` image object that will be displayed next to the choice\n  * valid - A boolean that defaults to `true`, if set to `false` selecting the choice will invoke the `invalidCallback` method instead of dismissing the chooser\n * Any other keys/values in each choice table will be retained by the chooser and returned to the completion callback when a choice is made. This is useful for storing UUIDs or other non-user-facing information, however, it is important to note that you should not store userdata objects in the table - it is run through internal conversion functions, so only basic Lua types should be stored.\n * If a function is given, it will be called once, when the chooser window is displayed. The results are then cached until this method is called again, or `hs.chooser:refreshChoicesCallback()` is called.\n * If you're using a hs.styledtext object for text or subText choices, make sure you specify a color, otherwise your text could appear transparent depending on the bgDark setting.\n\nExample:\n ```\nlocal choices = {\n {\n  [\"text\"] = \"First Choice\",\n  [\"subText\"] = \"This is the subtext of the first choice\",\n  [\"uuid\"] = \"0001\"\n },\n { [\"text\"] = \"Second Option\",\n   [\"subText\"] = \"I wonder what I should type here?\",\n   [\"uuid\"] = \"Bbbb\"\n },\n { [\"text\"] = hs.styledtext.new(\"Third Possibility\", {font={size=18}, color=hs.drawing.color.definedCollections.hammerspoon.green}),\n   [\"subText\"] = \"What a lot of choosing there is going on here!\",\n   [\"uuid\"] = \"III3\"\n },\n}\n ```"
    },
    "Deletes a chooser": {
        "prefix": "hs.chooser:delete()",
        "body": "hs.chooser:delete()",
        "description": "Deletes a chooser\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Sets the foreground color of the chooser": {
        "prefix": "hs.chooser:fgColor(color) -> hs.chooser object",
        "body": "hs.chooser:fgColor(${1:color})",
        "description": "Sets the foreground color of the chooser\n\nParameters:\n * color - An optional table containing a color specification (see `hs.drawing.color`), or nil to restore the default color. If this parameter is omitted, the existing color will be returned\n\nReturns:\n * The `hs.chooser` object or a color table"
    },
    "A global callback function used for various hs.chooser events": {
        "prefix": "hs.chooser.globalCallback",
        "body": "hs.chooser.globalCallback",
        "description": "A global callback function used for various hs.chooser events\n\nNotes:\n * This callback should accept two parameters:\n  * An `hs.chooser` object\n  * A string containing the name of the event to handle. Possible values are:\n   * `willOpen` - An hs.chooser is about to be shown on screen\n   * `didClose` - An hs.chooser has just been removed from the screen\n * There is a default global callback that uses the `willOpen` event to remember which window has focus, and the `didClose` event to restore focus back to the original window. If you want to use this in addition to your own callback, you can call it as `hs.chooser._defaultGlobalCallback(event)`"
    },
    "Hides the chooser": {
        "prefix": "hs.chooser:hide() -> hs.chooser object",
        "body": "hs.chooser:hide()",
        "description": "Hides the chooser\n\nParameters:\n * None\n\nReturns:\n * The `hs.chooser` object"
    },
    "Sets/clears a callback for when the chooser window is hidden": {
        "prefix": "hs.chooser:hideCallback([fn]) -> hs.chooser object",
        "body": "hs.chooser:hideCallback(${1:[fn]})",
        "description": "Sets/clears a callback for when the chooser window is hidden\n\nParameters:\n * fn - An optional function that will be called when the chooser window is hidden. If this parameter is omitted, the existing callback will be removed.\n\nReturns:\n * The hs.chooser object\n\nNotes:\n * This callback is called *after* the chooser is hidden.\n * This callback is called *after* hs.chooser.globalCallback."
    },
    "Sets/clears a callback for invalid choices": {
        "prefix": "hs.chooser:invalidCallback([fn]) -> hs.chooser object",
        "body": "hs.chooser:invalidCallback(${1:[fn]})",
        "description": "Sets/clears a callback for invalid choices\n\nParameters:\n * fn - An optional function that will be called whenever the user select an choice set as invalid. If this parameter is omitted, the existing callback will be removed.\n\nReturns:\n * The `hs.chooser` object\n\nNotes:\n  * The callback may accept one argument, it will be a table containing whatever information you supplied for the item the user chose.\n  * To display a context menu, see `hs.menubar`, specifically the `:popupMenu()` method"
    },
    "Checks if the chooser is currently displayed": {
        "prefix": "hs.chooser:isVisible() -> boolean",
        "body": "hs.chooser:isVisible()",
        "description": "Checks if the chooser is currently displayed\n\nParameters:\n * None\n\nReturns:\n * A boolean, true if the chooser is displayed on screen, false if not"
    },
    "Creates a new chooser object": {
        "prefix": "hs.chooser.new(completionFn) -> hs.chooser object",
        "body": "hs.chooser.new(${1:completionFn})",
        "description": "Creates a new chooser object\n\nParameters:\n * completionFn - A function that will be called when the chooser is dismissed. It should accept one parameter, which will be nil if the user dismissed the chooser window, otherwise it will be a table containing whatever information you supplied for the item the user chose.\n\nReturns:\n * An `hs.chooser` object\n\nNotes:\n * As of macOS Sierra and later, if you want a `hs.chooser` object to appear above full-screen windows you must hide the Hammerspoon Dock icon first using: `hs.dockicon.hide()`"
    },
    "Sets/gets placeholder text that is shown in the query text field when no other text is present": {
        "prefix": "hs.chooser:placeholderText([placeholderText]) -> hs.chooser object or string",
        "body": "hs.chooser:placeholderText(${1:[placeholderText]})",
        "description": "Sets/gets placeholder text that is shown in the query text field when no other text is present\n\nParameters:\n * placeholderText - An optional string for placeholder text. If this parameter is omitted, the existing placeholder text will be returned.\n\nReturns:\n * The hs.chooser object, or the existing placeholder text"
    },
    "Sets/gets the search string": {
        "prefix": "hs.chooser:query([queryString]) -> hs.chooser object or string",
        "body": "hs.chooser:query(${1:[queryString]})",
        "description": "Sets/gets the search string\n\nParameters:\n * queryString - An optional string to search for, or an explicit nil to clear the query. If omitted, the current contents of the search box are returned\n\nReturns:\n * The `hs.chooser` object or a string\n\nNotes:\n * You can provide an explicit nil or empty string to clear the current query string."
    },
    "Sets/clears a callback for when the search query changes": {
        "prefix": "hs.chooser:queryChangedCallback([fn]) -> hs.chooser object",
        "body": "hs.chooser:queryChangedCallback(${1:[fn]})",
        "description": "Sets/clears a callback for when the search query changes\n\nParameters:\n * fn - An optional function that will be called whenever the search query changes. If this parameter is omitted, the existing callback will be removed.\n\nReturns:\n * The hs.chooser object\n\nNotes:\n * As the user is typing, the callback function will be called for every keypress. You may wish to do filtering on each call, or you may wish to use a delayed `hs.timer` object to only react when they have finished typing.\n * The callback function should accept a single argument:\n  * A string containing the new search query"
    },
    "Refreshes the choices data from a callback": {
        "prefix": "hs.chooser:refreshChoicesCallback([reload]) -> hs.chooser object",
        "body": "hs.chooser:refreshChoicesCallback(${1:[reload]})",
        "description": "Refreshes the choices data from a callback\n\nParameters:\n * reload - An optional parameter that reloads the chooser results to take into account the current query string (defaults to `false`)\n\nReturns:\n * The `hs.chooser` object\n\nNotes:\n * This method will do nothing if you have not set a function with `hs.chooser:choices()`"
    },
    "Sets/clears a callback for right clicking on choices": {
        "prefix": "hs.chooser:rightClickCallback([fn]) -> hs.chooser object",
        "body": "hs.chooser:rightClickCallback(${1:[fn]})",
        "description": "Sets/clears a callback for right clicking on choices\n\nParameters:\n * fn - An optional function that will be called whenever the user right clicks on a choice. If this parameter is omitted, the existing callback will be removed.\n\nReturns:\n * The `hs.chooser` object\n\nNotes:\n  * The callback may accept one argument, the row the right click occurred in or 0 if there is currently no selectable row where the right click occurred. To determine the location of the mouse pointer at the right click, see `hs.mouse`.\n  * To display a context menu, see `hs.menubar`, specifically the `:popupMenu()` method"
    },
    "Gets/Sets the number of rows that will be shown": {
        "prefix": "hs.chooser:rows([numRows]) -> hs.chooser object or number",
        "body": "hs.chooser:rows(${1:[numRows]})",
        "description": "Gets/Sets the number of rows that will be shown\n\nParameters:\n * numRows - An optional number of choices to show (i.e. the vertical height of the chooser window). If this parameter is omitted, the current value will be returned\n\nReturns:\n * The `hs.chooser` object or a number"
    },
    "Gets/Sets whether the chooser should search in the sub-text of each item": {
        "prefix": "hs.chooser:searchSubText([searchSubText]) -> hs.chooser object or boolean",
        "body": "hs.chooser:searchSubText(${1:[searchSubText]})",
        "description": "Gets/Sets whether the chooser should search in the sub-text of each item\n\nParameters:\n * searchSubText - An optional boolean, true to search sub-text, false to not search sub-text. If this parameter is omitted, the current configuration value will be returned\n\nReturns:\n * The `hs.chooser` object if a value was set, or a boolean if no parameter was passed\n\nNotes:\n * This should be used before a chooser has been displayed"
    },
    "Closes the chooser by selecting the specified row, or the currently selected row if not given": {
        "prefix": "hs.chooser:select([row]) -> hs.chooser object",
        "body": "hs.chooser:select(${1:[row]})",
        "description": "Closes the chooser by selecting the specified row, or the currently selected row if not given\n\nParameters:\n * `row` - an optional integer specifying the row to select.\n\nReturns:\n * The `hs.chooser` object"
    },
    "Get or set the currently selected row": {
        "prefix": "hs.chooser:selectedRow([row]) -> number",
        "body": "hs.chooser:selectedRow(${1:[row]})",
        "description": "Get or set the currently selected row\n\nParameters:\n * `row` - an optional integer specifying the row to select.\n\nReturns:\n * If an argument is provided, returns the hs.chooser object; otherwise returns a number containing the row currently selected (i.e. the one highlighted in the UI)"
    },
    "Returns the contents of the currently selected or specified row": {
        "prefix": "hs.chooser:selectedRowContents([row]) -> table",
        "body": "hs.chooser:selectedRowContents(${1:[row]})",
        "description": "Returns the contents of the currently selected or specified row\n\nParameters:\n * `row` - an optional integer specifying the specific row to return the contents of\n\nReturns:\n * a table containing whatever information was supplied for the row currently selected or an empty table if no row is selected or the specified row does not exist."
    },
    "Displays the chooser": {
        "prefix": "hs.chooser:show([topLeftPoint]) -> hs.chooser object",
        "body": "hs.chooser:show(${1:[topLeftPoint]})",
        "description": "Displays the chooser\n\nParameters:\n * An optional `hs.geometry` point object describing the absolute screen co-ordinates for the top left point of the chooser window. Defaults to centering the window on the primary screen\n\nReturns:\n * The hs.chooser object"
    },
    "Sets/clears a callback for when the chooser window is shown": {
        "prefix": "hs.chooser:showCallback([fn]) -> hs.chooser object",
        "body": "hs.chooser:showCallback(${1:[fn]})",
        "description": "Sets/clears a callback for when the chooser window is shown\n\nParameters:\n * fn - An optional function that will be called when the chooser window is shown. If this parameter is omitted, the existing callback will be removed.\n\nReturns:\n * The hs.chooser object\n\nNotes:\n * This callback is called *after* the chooser is shown. To execute code just before it's shown (and/or after it's removed) see `hs.chooser.globalCallback`"
    },
    "Sets the sub-text color of the chooser": {
        "prefix": "hs.chooser:subTextColor(color) -> hs.chooser object or hs.color object",
        "body": "hs.chooser:subTextColor(${1:color})",
        "description": "Sets the sub-text color of the chooser\n\nParameters:\n * color - An optional table containing a color specification (see `hs.drawing.color`), or nil to restore the default color. If this parameter is omitted, the existing color will be returned\n\nReturns:\n * The `hs.chooser` object or a color table"
    },
    "Gets/Sets the width of the chooser": {
        "prefix": "hs.chooser:width([percent]) -> hs.chooser object or number",
        "body": "hs.chooser:width(${1:[percent]})",
        "description": "Gets/Sets the width of the chooser\n\nParameters:\n * percent - An optional number indicating the percentage of the width of the screen that the chooser should occupy. If this parameter is omitted, the current width will be returned\n\nReturns:\n * The `hs.chooser` object or a number\n\nNotes:\n * This should be used before a chooser has been displayed"
    },
    "Get or set the alpha level of the console window.": {
        "prefix": "hs.console.alpha([alpha]) -> currentValue",
        "body": "hs.console.alpha(${1:[alpha]})",
        "description": "Get or set the alpha level of the console window.\n\nParameters:\n * `alpha` - an optional number between 0.0 and 1.0 specifying the new alpha level for the Hammerspoon console.\n\nReturns:\n * the current, possibly new, value."
    },
    "Because use of this function can easily lead to a crash, useful methods from `hs.drawing` have been added to the `hs.console` module itself.  If you believe that a useful method has been overlooked, please submit an issue.": {
        "prefix": "hs.console.asHSDrawing() -> hs.drawing object",
        "body": "hs.console.asHSDrawing()",
        "description": "Because use of this function can easily lead to a crash, useful methods from `hs.drawing` have been added to the `hs.console` module itself.  If you believe that a useful method has been overlooked, please submit an issue.\n\nParameters:\n * None\n\nReturns:\n * a placeholder object"
    },
    "Returns an hs.window object for the console so that you can use hs.window methods on it.": {
        "prefix": "hs.console.asHSWindow() -> hs.window object",
        "body": "hs.console.asHSWindow()",
        "description": "Returns an hs.window object for the console so that you can use hs.window methods on it.\n\nThis function is identical to [hs.console.hswindow](#hswindow).  It is included for reasons of backwards compatibility, but use of the new name is recommended for clarity."
    },
    "Get or set the window behavior settings for the console.": {
        "prefix": "hs.console.behavior([behavior]) -> currentValue",
        "body": "hs.console.behavior(${1:[behavior]})",
        "description": "Get or set the window behavior settings for the console.\n\nParameters:\n * `behavior` - an optional number representing the desired window behaviors for the Hammerspoon console.\n\nReturns:\n * the current, possibly new, value.\n\nNotes:\n * Window behaviors determine how the webview object is handled by Spaces and Expos\u00e9. See `hs.drawing.windowBehaviors` for more information."
    },
    "Get or set the window behavior settings for the console using labels defined in `hs.drawing.windowBehaviors`.": {
        "prefix": "hs.console.behaviorAsLabels(behaviorTable) -> currentValue",
        "body": "hs.console.behaviorAsLabels(${1:behaviorTable})",
        "description": "Get or set the window behavior settings for the console using labels defined in `hs.drawing.windowBehaviors`.\n\nParameters:\n * behaviorTable - an optional table of strings and/or numbers specifying the desired window behavior for the Hammerspoon console.\n\nReturns:\n * the current (possibly new) value.\n\nNotes:\n * Window behaviors determine how the console is handled by Spaces and Expos\u00e9. See `hs.drawing.windowBehaviors` for more information."
    },
    "Clear the Hammerspoon console output window.": {
        "prefix": "hs.console.setConsole([styledText]) -> none",
        "body": "hs.console.setConsole(${1:[styledText]})",
        "description": "Clear the Hammerspoon console output window.\n\nParameters:\n * styledText - an optional `hs.styledtext` object containing the text you wish to replace the Hammerspoon console output with.  If you do not provide an argument, the console is cleared of all content.\n\nReturns:\n * None\n\nNotes:\n * You can specify the console content as a string or as an `hs.styledtext` object in either userdata or table format."
    },
    "Get or set the color that commands displayed in the Hammerspoon console are displayed with.": {
        "prefix": "hs.console.consoleCommandColor([color]) -> color",
        "body": "hs.console.consoleCommandColor(${1:[color]})",
        "description": "Get or set the color that commands displayed in the Hammerspoon console are displayed with.\n\nParameters:\n* color - an optional table containing color keys as described in `hs.drawing.color`\n\nReturns:\n* the current color setting as a table\n\nNotes:\n * See the `hs.drawing.color` entry in the Dash documentation, or type `help.hs.drawing.color` in the Hammerspoon console to get more information on how to specify a color.\n * Note this only affects future output -- anything already in the console will remain its current color."
    },
    "Get or set the font used in the Hammerspoon console.": {
        "prefix": "hs.console.consoleFont([font]) -> fontTable",
        "body": "hs.console.consoleFont(${1:[font]})",
        "description": "Get or set the font used in the Hammerspoon console.\n\nParameters:\n* font - an optional string or table describing the font to use in the console. If a string is specified, then the default system font size will be used.  If a table is specified, it should contain a `name` key-value pair and a `size` key-value pair describing the font to be used.\n\nReturns:\n* the current font setting as a table containing a `name` key and a `size` key.\n\nNotes:\n * See the `hs.drawing.color` entry in the Dash documentation, or type `help.hs.drawing.color` in the Hammerspoon console to get more information on how to specify a color.\n * Note this only affects future output -- anything already in the console will remain its current font."
    },
    "Get or set the color that regular output displayed in the Hammerspoon console is displayed with.": {
        "prefix": "hs.console.consolePrintColor([color]) -> color",
        "body": "hs.console.consolePrintColor(${1:[color]})",
        "description": "Get or set the color that regular output displayed in the Hammerspoon console is displayed with.\n\nParameters:\n* color - an optional table containing color keys as described in `hs.drawing.color`\n\nReturns:\n* the current color setting as a table\n\nNotes:\n * See the `hs.drawing.color` entry in the Dash documentation, or type `help.hs.drawing.color` in the Hammerspoon console to get more information on how to specify a color.\n * Note this only affects future output -- anything already in the console will remain its current color."
    },
    "Get or set the color that function results displayed in the Hammerspoon console are displayed with.": {
        "prefix": "hs.console.consoleResultColor([color]) -> color",
        "body": "hs.console.consoleResultColor(${1:[color]})",
        "description": "Get or set the color that function results displayed in the Hammerspoon console are displayed with.\n\nParameters:\n* color - an optional table containing color keys as described in `hs.drawing.color`\n\nReturns:\n* the current color setting as a table\n\nNotes:\n * See the `hs.drawing.color` entry in the Dash documentation, or type `help.hs.drawing.color` in the Hammerspoon console to get more information on how to specify a color.\n * Note this only affects future output -- anything already in the console will remain its current color."
    },
    "Set or display whether or not the Console window should display in dark mode.": {
        "prefix": "hs.console.darkMode([state]) -> bool",
        "body": "hs.console.darkMode(${1:[state]})",
        "description": "Set or display whether or not the Console window should display in dark mode.\n\nParameters:\n * state - an optional boolean which will set whether or not the Console window should display in dark mode.\n\nReturns:\n * A boolean, true if dark mode is enabled otherwise false.\n\nNotes:\n * Enabling Dark Mode for the Console only affects the window background, and doesn't automatically change the Console's Background Color, so you will need to add something similar to:\n   ```lua\n   if hs.console.darkMode() then\n       hs.console.outputBackgroundColor{ white = 0 }\n       hs.console.consoleCommandColor{ white = 1 }\n       hs.console.alpha(.8)\n   end\n.   ```"
    },
    "Default toolbar for the Console window": {
        "prefix": "hs.console.defaultToolbar",
        "body": "hs.console.defaultToolbar",
        "description": "Default toolbar for the Console window\n\nNotes:\n * This is an `hs.toolbar` object that is shown by default in the Hammerspoon Console\n * You can remove this toolbar by adding `hs.console.toolbar(nil)` to your config, or you can replace it with your own `hs.webview.toolbar` object"
    },
    "Get the text of the Hammerspoon console output window.": {
        "prefix": "hs.console.getConsole([styled]) -> text | styledText",
        "body": "hs.console.getConsole(${1:[styled]})",
        "description": "Get the text of the Hammerspoon console output window.\n\nParameters:\n * styled - an optional boolean indicating whether the console text is returned as a string or a styledText object.  Defaults to false.\n\nReturns:\n * The text currently in the Hammerspoon console output window as either a string or an `hs.styledtext` object.\n\nNotes:\n * If the text of the console is retrieved as a string, no color or style information in the console output is retrieved - only the raw text."
    },
    "Get the Hammerspoon console history as an array.": {
        "prefix": "hs.console.getHistory() -> array",
        "body": "hs.console.getHistory()",
        "description": "Get the Hammerspoon console history as an array.\n\nParameters:\n * None\n\nReturns:\n * an array containing the history of commands entered into the Hammerspoon console."
    },
    "Get an hs.window object which represents the Hammerspoon console window": {
        "prefix": "hs.console.hswindow() -> hs.window object",
        "body": "hs.console.hswindow()",
        "description": "Get an hs.window object which represents the Hammerspoon console window\n\nParameters:\n * None\n\nReturns:\n * an hs.window object"
    },
    "Get or set the color for the background of the Hammerspoon Console's input field.": {
        "prefix": "hs.console.inputBackgroundColor([color]) -> color",
        "body": "hs.console.inputBackgroundColor(${1:[color]})",
        "description": "Get or set the color for the background of the Hammerspoon Console's input field.\n\nParameters:\n* color - an optional table containing color keys as described in `hs.drawing.color`\n\nReturns:\n* the current color setting as a table\n\nNotes:\n * See the `hs.drawing.color` entry in the Dash documentation, or type `help.hs.drawing.color` in the Hammerspoon console to get more information on how to specify a color."
    },
    "Get or set the console window level": {
        "prefix": "hs.console.level([theLevel]) -> currentValue",
        "body": "hs.console.level(${1:[theLevel]})",
        "description": "Get or set the console window level\n\nParameters:\n * `theLevel` - an optional parameter specifying the desired level as an integer, which can be obtained from `hs.drawing.windowLevels`.\n\nReturns:\n * the current, possibly new, value\n\nNotes:\n * see the notes for `hs.drawing.windowLevels`"
    },
    "Get or set the color for the background of the Hammerspoon Console's output view.": {
        "prefix": "hs.console.outputBackgroundColor([color]) -> color",
        "body": "hs.console.outputBackgroundColor(${1:[color]})",
        "description": "Get or set the color for the background of the Hammerspoon Console's output view.\n\nParameters:\n* color - an optional table containing color keys as described in `hs.drawing.color`\n\nReturns:\n* the current color setting as a table\n\nNotes:\n * See the `hs.drawing.color` entry in the Dash documentation, or type `help.hs.drawing.color` in the Hammerspoon console to get more information on how to specify a color."
    },
    "A print function which recognizes `hs.styledtext` objects and renders them as such in the Hammerspoon console.": {
        "prefix": "hs.console.printStyledtext(...) -> none",
        "body": "hs.console.printStyledtext(${1:...})",
        "description": "A print function which recognizes `hs.styledtext` objects and renders them as such in the Hammerspoon console.\n\nParameters:\n * Any number of arguments can be specified, just like the builtin Lua `print` command.  If an argument matches the userdata type of `hs.styledtext`, the text is rendered as defined by its style attributes in the Hammerspoon console; otherwise it is rendered as it would be via the traditional `print` command within Hammerspoon.\n\nReturns:\n * None\n\nNotes:\n * This has been made as close to the Lua `print` command as possible.  You can replace the existing print command with this by adding the following to your `init.lua` file:\n\n~~~\n   print = function(...)\n       hs.rawprint(...)\n       hs.console.printStyledtext(...)\n   end\n~~~"
    },
    "Set the Hammerspoon console history to the items specified in the given array.": {
        "prefix": "hs.console.setHistory(array) -> nil",
        "body": "hs.console.setHistory(${1:array})",
        "description": "Set the Hammerspoon console history to the items specified in the given array.\n\nParameters:\n * array - the list of commands to set the Hammerspoon console history to.\n\nReturns:\n * None\n\nNotes:\n * You can clear the console history by using an empty array (e.g. `hs.console.setHistory({})`"
    },
    "Determine whether or not objects copied from the console window insert or delete space around selected words to preserve proper spacing and punctuation.": {
        "prefix": "hs.console.smartInsertDeleteEnabled([flag]) -> bool",
        "body": "hs.console.smartInsertDeleteEnabled(${1:[flag]})",
        "description": "Determine whether or not objects copied from the console window insert or delete space around selected words to preserve proper spacing and punctuation.\n\nParameters:\n * flag - an optional boolean value indicating whether or not \"smart\" space behavior is enabled when copying from the Hammerspoon console.\n\nReturns:\n * the current value\n\nNotes:\n * this only applies to future copy operations from the Hammerspoon console -- anything already in the clipboard is not affected."
    },
    "Get or set whether or not the \"Hammerspoon Console\" text appears in the Hammerspoon console titlebar.": {
        "prefix": "hs.console.titleVisibility([state]) -> current value",
        "body": "hs.console.titleVisibility(${1:[state]})",
        "description": "Get or set whether or not the \"Hammerspoon Console\" text appears in the Hammerspoon console titlebar.\n\nParameters:\n * state - an optional string containing the text \"visible\" or \"hidden\", specifying whether or not the console window's title text appears.\n\nReturns:\n * a string of \"visible\" or \"hidden\" specifying the current (possibly changed) state of the window title's visibility.\n\nNotes:\n * When a toolbar is attached to the Hammerspoon console (see the `hs.webview.toolbar` module documentation), this function can be used to specify whether the Toolbar appears underneath the console window's title (\"visible\") or in the window's title bar itself, as seen in applications like Safari (\"hidden\"). When the title is hidden, the toolbar will only display the toolbar items as icons without labels, and ignores changes made with `hs.webview.toolbar:displayMode`.\n\n * If a toolbar is attached to the console, you can achieve the same effect as this function with `hs.console.toolbar():inTitleBar(boolean)`"
    },
    "Get or attach/detach a toolbar to/from the Hammerspoon console.": {
        "prefix": "hs.console.toolbar([toolbar | nil]) -> toolbarObject | currentValue",
        "body": "hs.console.toolbar(${1:[toolbar | nil]})",
        "description": "Get or attach/detach a toolbar to/from the Hammerspoon console.\n\nParameters:\n * `toolbar` - if an `hs.webview.toolbar` object is specified, it will be attached to the Hammerspoon console.  If an explicit nil is specified, the current toolbar will be removed from the console.\n\nReturns:\n * if a toolbarObject or explicit nil is specified, returns the toolbarObject; otherwise returns the current toolbarObject or nil, if no toolbar is attached to the console.\n\nNotes:\n * this method is a convenience wrapper for the `hs.webview.toolbar.attachToolbar` function.\n\n * If the toolbar is currently attached to another window when this function is called, it will be detached from the original window and attached to the console."
    },
    "Get or set the color for the background of the Hammerspoon Console's window.": {
        "prefix": "hs.console.windowBackgroundColor([color]) -> color",
        "body": "hs.console.windowBackgroundColor(${1:[color]})",
        "description": "Get or set the color for the background of the Hammerspoon Console's window.\n\nParameters:\n* color - an optional table containing color keys as described in `hs.drawing.color`\n\nReturns:\n* the current color setting as a table\n\nNotes:\n * See the `hs.drawing.color` entry in the Dash documentation, or type `help.hs.drawing.color` in the Hammerspoon console to get more information on how to specify a color."
    },
    "Attempts to reduce RAM usage of Hammerspoon": {
        "prefix": "hs.crash.attemptMemoryRelease()",
        "body": "hs.crash.attemptMemoryRelease()",
        "description": "Attempts to reduce RAM usage of Hammerspoon\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This function will print some memory usage numbers (in bytes) to the Hammerspoon Console before and after forcing Lua's garbage collector"
    },
    "Causes Hammerspoon to immediately crash": {
        "prefix": "hs.crash.crash()",
        "body": "hs.crash.crash()",
        "description": "Causes Hammerspoon to immediately crash\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This is for testing purposes only, you are extremely unlikely to need this in normal Hammerspoon usage"
    },
    "Sets a key/value pair in any Sentry crash dump generated by this Hamerspoon session": {
        "prefix": "hs.crash.crashKV(key, value)",
        "body": "hs.crash.crashKV(${1:key}, ${2:value})",
        "description": "Sets a key/value pair in any Sentry crash dump generated by this Hamerspoon session\n\nParameters:\n * key - A string containing the key name of the pair\n * value - A string containing the value of the pair\n\nReturns:\n * None"
    },
    "Leaves a breadcrumb log message in any Sentry crash dump generated by this Hammerspoon session": {
        "prefix": "hs.crash.crashLog(logMessage)",
        "body": "hs.crash.crashLog(${1:logMessage})",
        "description": "Leaves a breadcrumb log message in any Sentry crash dump generated by this Hammerspoon session\n\nParameters:\n * logMessage - A string containing a message to log\n\nReturns:\n * None\n\nNotes:\n * This is probably only useful to extension developers. If you are trying to track down a confusing crash, and you have access to the Sentry project for Hammerspoon (or access to someone who has access!), this can be a useful way to leave breadcrumbs from Lua in the crash dump"
    },
    "Dumps the contents of Lua's CLIBS registry": {
        "prefix": "hs.crash.dumpCLIBS() -> table",
        "body": "hs.crash.dumpCLIBS()",
        "description": "Dumps the contents of Lua's CLIBS registry\n\nParameters:\n * None\n\nReturns:\n * A table containing all the paths of C libraries that have been loaded into the Lua runtime\n\nNotes:\n * This is probably only useful to extension developers as a useful way of ensuring that you are loading C libraries from the places you expect."
    },
    "Gets the resident size of the Hammerspoon process": {
        "prefix": "hs.crash.residentSize() -> integer or nil",
        "body": "hs.crash.residentSize()",
        "description": "Gets the resident size of the Hammerspoon process\n\nParameters:\n * None\n\nReturns:\n * An integer containing the amount of RAM in use by Hammerspoon (in bytes), or nil if an error occurred"
    },
    "Causes Hammerspoon to generate an Objective C exception": {
        "prefix": "hs.crash.throwObjCException(name, message)",
        "body": "hs.crash.throwObjCException(${1:name}, ${2:message})",
        "description": "Causes Hammerspoon to generate an Objective C exception\n\nParameters:\n * name - A string containing the name of the exception\n * message - A human readabke string explaining the exception\n\nReturns:\n * None\n\nNotes:\n * Outside of a context of a Lua pcall() (or a C lua_pcall()), this will cause Hammerspoon to exit. We follow the safe behaviour of terminating the app on any unhandled Objective C exception."
    },
    "Displays information for current track on screen": {
        "prefix": "hs.vox.trackInfo()",
        "body": "hs.vox.trackInfo()",
        "description": "Displays information for current track on screen\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Skips the playback position forwards by 5 seconds": {
        "prefix": "hs.spotify.ff()",
        "body": "hs.spotify.ff()",
        "description": "Skips the playback position forwards by 5 seconds\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Gets the name of the album of the current track": {
        "prefix": "hs.vox.getCurrentAlbum()",
        "body": "hs.vox.getCurrentAlbum()",
        "description": "Gets the name of the album of the current track\n\nParameters:\n * None\n\nReturns:\n * A string containing the Album of the current track, or nil if an error occurred"
    },
    "Gets the name of the artist of the current track": {
        "prefix": "hs.vox.getCurrentArtist()",
        "body": "hs.vox.getCurrentArtist()",
        "description": "Gets the name of the artist of the current track\n\nParameters:\n * None\n\nReturns:\n * A string containing the Artist of the current track, or nil if an error occurred"
    },
    "Gets the name of the current track": {
        "prefix": "hs.spotify.getCurrentTrack()",
        "body": "hs.spotify.getCurrentTrack()",
        "description": "Gets the name of the current track\n\nParameters:\n * None\n\nReturns:\n * A string containing the name of the current track, or nil if an error occurred"
    },
    "Gets the current playback state of deezer": {
        "prefix": "hs.deezer.getPlaybackState()",
        "body": "hs.deezer.getPlaybackState()",
        "description": "Gets the current playback state of deezer\n\nParameters:\n * None\n\nReturns:\n * A string containing one of the following constants:\n   - `hs.deezer.state_stopped`\n   - `hs.deezer.state_paused`\n   - `hs.deezer.state_playing`"
    },
    "Gets the playback position (in seconds) in the current song": {
        "prefix": "hs.spotify.getPosition()",
        "body": "hs.spotify.getPosition()",
        "description": "Gets the playback position (in seconds) in the current song\n\nParameters:\n * None\n\nReturns:\n * A number indicating the current position in the song"
    },
    "Gets the deezer volume setting": {
        "prefix": "hs.deezer.getVolume()",
        "body": "hs.deezer.getVolume()",
        "description": "Gets the deezer volume setting\n\nParameters:\n * None\n\nReturns:\n * A number containing the volume deezer is set to between 1 and 100"
    },
    "Returns whether deezer is currently playing": {
        "prefix": "hs.deezer.isPlaying()",
        "body": "hs.deezer.isPlaying()",
        "description": "Returns whether deezer is currently playing\n\nParameters:\n * None\n\nReturns:\n * A boolean value indicating whether deezer is currently playing a track, or nil if an error occurred (unknown player state). Also returns false if the application is not running"
    },
    "Returns whether deezer is currently open. Most other functions in hs.deezer will automatically start the application, so this function can be used to guard against that.": {
        "prefix": "hs.deezer.isRunning()",
        "body": "hs.deezer.isRunning()",
        "description": "Returns whether deezer is currently open. Most other functions in hs.deezer will automatically start the application, so this function can be used to guard against that.\n\nParameters:\n * None\n\nReturns:\n * A boolean value indicating whether the deezer application is running."
    },
    "Skips to the next deezer track": {
        "prefix": "hs.deezer.next()",
        "body": "hs.deezer.next()",
        "description": "Skips to the next deezer track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Pauses the current deezer track": {
        "prefix": "hs.deezer.pause()",
        "body": "hs.deezer.pause()",
        "description": "Pauses the current deezer track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Plays the current deezer track": {
        "prefix": "hs.deezer.play()",
        "body": "hs.deezer.play()",
        "description": "Plays the current deezer track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Toggles play/pause of current deezer track": {
        "prefix": "hs.deezer.playpause()",
        "body": "hs.deezer.playpause()",
        "description": "Toggles play/pause of current deezer track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Skips to previous deezer track": {
        "prefix": "hs.deezer.previous()",
        "body": "hs.deezer.previous()",
        "description": "Skips to previous deezer track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Skips the playback position backwards by 5 seconds": {
        "prefix": "hs.spotify.rw()",
        "body": "hs.spotify.rw()",
        "description": "Skips the playback position backwards by 5 seconds\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Sets the playback position in the current song": {
        "prefix": "hs.spotify.setPosition(pos)",
        "body": "hs.spotify.setPosition(${1:pos})",
        "description": "Sets the playback position in the current song\n\nParameters:\n * pos - A number containing the position (in seconds) to jump to in the current song\n\nReturns:\n * None"
    },
    "Sets the deezer volume setting": {
        "prefix": "hs.deezer.setVolume(vol)",
        "body": "hs.deezer.setVolume(${1:vol})",
        "description": "Sets the deezer volume setting\n\nParameters:\n * vol - A number between 1 and 100\n\nReturns:\n * None"
    },
    "Returned by `hs.deezer.getPlaybackState()` to indicates deezer is paused": {
        "prefix": "hs.deezer.state_paused",
        "body": "hs.deezer.state_paused",
        "description": "Returned by `hs.deezer.getPlaybackState()` to indicates deezer is paused"
    },
    "Returned by `hs.deezer.getPlaybackState()` to indicates deezer is playing": {
        "prefix": "hs.deezer.state_playing",
        "body": "hs.deezer.state_playing",
        "description": "Returned by `hs.deezer.getPlaybackState()` to indicates deezer is playing"
    },
    "Returned by `hs.deezer.getPlaybackState()` to indicates deezer is stopped": {
        "prefix": "hs.deezer.state_stopped",
        "body": "hs.deezer.state_stopped",
        "description": "Returned by `hs.deezer.getPlaybackState()` to indicates deezer is stopped"
    },
    "Reduces the volume by 5": {
        "prefix": "hs.spotify.volumeDown()",
        "body": "hs.spotify.volumeDown()",
        "description": "Reduces the volume by 5\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Increases the volume by 5": {
        "prefix": "hs.spotify.volumeUp()",
        "body": "hs.spotify.volumeUp()",
        "description": "Increases the volume by 5\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Displays a simple non-blocking dialog box using `NSAlert` and a hidden `hs.webview` that's automatically destroyed when the alert is closed.": {
        "prefix": "hs.dialog.alert(x, y, callbackFn, message, [informativeText], [buttonOne], [buttonTwo], [style]) -> string",
        "body": "hs.dialog.alert(${1:x}, ${2:y}, ${3:callbackFn}, ${4:message}, ${5:[informativeText]}, ${6:[buttonOne]}, ${7:[buttonTwo]}, ${8:[style]})",
        "description": "Displays a simple non-blocking dialog box using `NSAlert` and a hidden `hs.webview` that's automatically destroyed when the alert is closed.\n\nParameters:\n * x - A number containing the horizontal co-ordinate of the top-left point of the dialog box. Defaults to 1.\n * y - A number containing the vertical co-ordinate of the top-left point of the dialog box. Defaults to 1.\n * callbackFn - The callback function that's called when a button is pressed.\n * message - The message text to display.\n * [informativeText] - Optional informative text to display.\n * [buttonOne] - An optional value for the first button as a string. Defaults to \"OK\".\n * [buttonTwo] - An optional value for the second button as a string. If `nil` is used, no second button will be displayed.\n * [style] - An optional style of the dialog box as a string. Defaults to \"warning\".\n\nReturns:\n * nil\n\nNotes:\n * The optional values must be entered in order (i.e. you can't supply `style` without also supplying `buttonOne` and `buttonTwo`).\n * [style] can be \"warning\", \"informational\" or \"critical\". If something other than these string values is given, it will use \"informational\".\n * Example:\n     ```testCallbackFn = function(result) print(\"Callback Result: \" .. result) end\n     hs.dialog.alert(100, 100, testCallbackFn, \"Message\", \"Informative Text\", \"Button One\", \"Button Two\", \"NSCriticalAlertStyle\")\n     hs.dialog.alert(200, 200, testCallbackFn, \"Message\", \"Informative Text\", \"Single Button\")```"
    },
    "Displays a simple dialog box using `NSAlert` that will halt Lua code processing until the alert is closed.": {
        "prefix": "hs.dialog.blockAlert(message, informativeText, [buttonOne], [buttonTwo], [style]) -> string",
        "body": "hs.dialog.blockAlert(${1:message}, ${2:informativeText}, ${3:[buttonOne]}, ${4:[buttonTwo]}, ${5:[style]})",
        "description": "Displays a simple dialog box using `NSAlert` that will halt Lua code processing until the alert is closed.\n\nParameters:\n * message - The message text to display.\n * informativeText - The informative text to display.\n * [buttonOne] - An optional value for the first button as a string. Defaults to \"OK\".\n * [buttonTwo] - An optional value for the second button as a string. If `nil` is used, no second button will be displayed.\n * [style] - An optional style of the dialog box as a string. Defaults to \"informational\".\n\nReturns:\n * The value of the button as a string.\n\nNotes:\n * The optional values must be entered in order (i.e. you can't supply `style` without also supplying `buttonOne` and `buttonTwo`).\n * [style] can be \"warning\", \"informational\" or \"critical\". If something other than these string values is given, it will use \"informational\".\n * Example:\n     `hs.dialog.blockAlert(\"Message\", \"Informative Text\", \"Button One\", \"Button Two\", \"NSCriticalAlertStyle\")`"
    },
    "Displays a file and/or folder selection dialog box using NSOpenPanel.": {
        "prefix": "hs.dialog.chooseFileOrFolder([message], [defaultPath], [canChooseFiles], [canChooseDirectories], [allowsMultipleSelection], [allowedFileTypes], [resolvesAliases]) -> string",
        "body": "hs.dialog.chooseFileOrFolder(${1:[message]}, ${2:[defaultPath]}, ${3:[canChooseFiles]}, ${4:[canChooseDirectories]}, ${5:[allowsMultipleSelection]}, ${6:[allowedFileTypes]}, ${7:[resolvesAliases]})",
        "description": "Displays a file and/or folder selection dialog box using NSOpenPanel.\n\nParameters:\n * [message] - The optional message text to display.\n * [defaultPath] - The optional path you want to dialog to open to.\n * [canChooseFiles] - Whether or not the user can select files. Defaults to `true`.\n * [canChooseDirectories] - Whether or not the user can select folders. Default to `false`.\n * [allowsMultipleSelection] - Allow multiple selections of files and/or folders. Defaults to `false`.\n * [allowedFileTypes] - An optional table of allowed file types. Defaults to `true`.\n * [resolvesAliases] - An optional boolean that indicates whether the panel resolves aliases.\n\nReturns:\n * The selected files in a table or `nil` if cancel was pressed.\n\nNotes:\n * The optional values must be entered in order (i.e. you can't supply `allowsMultipleSelection` without also supplying `canChooseFiles` and `canChooseDirectories`).\n * Example:\n     `hs.inspect(hs.dialog.chooseFileOrFolder(\"Please select a file:\", \"~/Desktop\", true, false, true, {\"jpeg\", \"pdf\"}, true))`"
    },
    "Displays a simple text input dialog box.": {
        "prefix": "hs.dialog.textPrompt(message, informativeText, [defaultText], [buttonOne], [buttonTwo], [secureField]) -> string, string",
        "body": "hs.dialog.textPrompt(${1:message}, ${2:informativeText}, ${3:[defaultText]}, ${4:[buttonOne]}, ${5:[buttonTwo]}, ${6:[secureField]})",
        "description": "Displays a simple text input dialog box.\n\nParameters:\n * message - The message text to display\n * informativeText - The informative text to display\n * [defaultText] - The informative text to display\n * [buttonOne] - An optional value for the first button as a string\n * [buttonTwo] - An optional value for the second button as a string\n * [secureField] - An optional boolean. If true, PasswordField instead of TextField. Defaults to false.\n\nReturns:\n * The value of the button as a string\n * The value of the text input as a string\n\nNotes:\n * `buttonOne` defaults to \"OK\" if no value is supplied.\n * `buttonOne` will also be triggered by pressing `ENTER`, whereas `buttonTwo` will be triggered by pressing `ESC`.\n * Examples:\n     `hs.dialog.textPrompt(\"Main message.\", \"Please enter something:\")`\n     `hs.dialog.textPrompt(\"Main message.\", \"Please enter something:\", \"Default Value\", \"OK\")`\n     `hs.dialog.textPrompt(\"Main message.\", \"Please enter something:\", \"Default Value\", \"OK\", \"Cancel\")`\n     `hs.dialog.textPrompt(\"Main message.\", \"Please enter something:\", \"\", \"OK\", \"Cancel\", true)`"
    },
    "Displays a simple dialog box using `NSAlert` in a `hs.webview`.": {
        "prefix": "hs.dialog.webviewAlert(webview, callbackFn, message, [informativeText], [buttonOne], [buttonTwo], [style]) -> string",
        "body": "hs.dialog.${1:webview}Alert(webview, ${2:callbackFn}, ${3:message}, ${4:[informativeText]}, ${5:[buttonOne]}, ${6:[buttonTwo]}, ${7:[style]})",
        "description": "Displays a simple dialog box using `NSAlert` in a `hs.webview`.\n\nParameters:\n * webview - The `hs.webview` to display the alert on.\n * callbackFn - The callback function that's called when a button is pressed.\n * message - The message text to display.\n * [informativeText] - Optional informative text to display.\n * [buttonOne] - An optional value for the first button as a string. Defaults to \"OK\".\n * [buttonTwo] - An optional value for the second button as a string. If `nil` is used, no second button will be displayed.\n * [style] - An optional style of the dialog box as a string. Defaults to \"warning\".\n\nReturns:\n * nil\n\nNotes:\n * This alert is will prevent the user from interacting with the `hs.webview` until a button is pressed on the alert.\n * The optional values must be entered in order (i.e. you can't supply `style` without also supplying `buttonOne` and `buttonTwo`).\n * [style] can be \"warning\", \"informational\" or \"critical\". If something other than these string values is given, it will use \"informational\".\n * Example:\n     ```testCallbackFn = function(result) print(\"Callback Result: \" .. result) end\n     testWebviewA = hs.webview.newBrowser(hs.geometry.rect(250, 250, 250, 250)):show()\n     testWebviewB = hs.webview.newBrowser(hs.geometry.rect(450, 450, 450, 450)):show()\n     hs.dialog.webviewAlert(testWebviewA, testCallbackFn, \"Message\", \"Informative Text\", \"Button One\", \"Button Two\", \"warning\")\n     hs.dialog.webviewAlert(testWebviewB, testCallbackFn, \"Message\", \"Informative Text\", \"Single Button\")```"
    },
    "Set or display the selected opacity.": {
        "prefix": "hs.dialog.color.alpha([value]) -> number",
        "body": "hs.dialog.color.alpha(${1:[value]})",
        "description": "Set or display the selected opacity.\n\nParameters:\n * [value] - A opacity value as a number between 0 and 1, where 0 is 100% transparent/see-through.\n\nReturns:\n * The current alpha value as a number.\n\nNotes:\n * Example:\n     `hs.dialog.color.alpha(0.5)`"
    },
    "Sets or removes the callback function for the color panel.": {
        "prefix": "hs.dialog.color.callback([callbackFn]) -> function or nil",
        "body": "hs.dialog.color.callback(${1:[callbackFn]})",
        "description": "Sets or removes the callback function for the color panel.\n\nParameters:\n * a function, or `nil` to remove the current function, which will be invoked as a callback for messages generated by this color panel. The callback function should expect 2 arguments as follows:\n   ** A table containing the color values from the color panel.\n   ** A boolean which returns `true` if the color panel has been closed otherwise `false` indicating that the color panel is still open (i.e. it may change color again).\n\nReturns:\n * The last callbackFn or `nil` so you can save it and re-attach it if something needs to temporarily take the callbacks.\n\nNotes:\n * Example:\n     `hs.dialog.color.callback(function(a,b) print(\"COLOR CALLBACK:\\nSelected Color: \" .. hs.inspect(a) .. \"\\nPanel Closed: \" .. hs.inspect(b)) end)`"
    },
    "Set or display the currently selected color in a color wheel.": {
        "prefix": "hs.dialog.color.color([value]) -> table",
        "body": "hs.dialog.color.color(${1:[value]})",
        "description": "Set or display the currently selected color in a color wheel.\n\nParameters:\n * [value] - The color values in a table (as described in `hs.drawing.color`).\n\nReturns:\n * A table of the currently selected color in the form of `hs.drawing.color`.\n\nNotes:\n * Example:\n     `hs.dialog.color.color(hs.drawing.color.blue)`"
    },
    "Set or display whether or not the callback should be continiously updated when a user drags a color slider or control.": {
        "prefix": "hs.dialog.color.continuous([value]) -> boolean",
        "body": "hs.dialog.color.continuous(${1:[value]})",
        "description": "Set or display whether or not the callback should be continiously updated when a user drags a color slider or control.\n\nParameters:\n * [value] - `true` if you want to continiously trigger the callback, otherwise `false`.\n\nReturns:\n * `true` if continuous is enabled otherwise `false`\n\nNotes:\n * Example:\n     `hs.dialog.color.continuous(true)`"
    },
    "Hides the Color Panel.": {
        "prefix": "hs.dialog.color.hide() -> none",
        "body": "hs.dialog.color.hide()",
        "description": "Hides the Color Panel.\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * Example:\n     `hs.dialog.color.hide()`"
    },
    "Set or display the currently selected color panel mode.": {
        "prefix": "hs.dialog.color.mode([value]) -> table",
        "body": "hs.dialog.color.mode(${1:[value]})",
        "description": "Set or display the currently selected color panel mode.\n\nParameters:\n * [value] - The mode you wish to use as a string from the following options:\n   ** \"wheel\" - Color Wheel\n   ** \"gray\" - Gray Scale Slider\n   ** \"RGB\" - RGB Sliders\n   ** \"CMYK\" - CMYK Sliders\n   ** \"HSB\" - HSB Sliders\n   ** \"list\" - Color Palettes\n   ** \"custom\" - Image Palettes\n   ** \"crayon\" - Pencils\n   ** \"none\"\n\nReturns:\n * The current mode as a string.\n\nNotes:\n * Example:\n     `hs.dialog.color.mode(\"RGB\")`"
    },
    "Shows the Color Panel.": {
        "prefix": "hs.dialog.color.show() -> none",
        "body": "hs.dialog.color.show()",
        "description": "Shows the Color Panel.\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * Example:\n     `hs.dialog.color.show()`"
    },
    "Set or display whether or not the color panel should display an opacity slider.": {
        "prefix": "hs.dialog.color.showsAlpha([value]) -> boolean",
        "body": "hs.dialog.color.showsAlpha(${1:[value]})",
        "description": "Set or display whether or not the color panel should display an opacity slider.\n\nParameters:\n * [value] - `true` if you want to display an opacity slider, otherwise `false`.\n\nReturns:\n * `true` if the opacity slider is displayed otherwise `false`\n\nNotes:\n * Example:\n     `hs.dialog.color.showsAlpha(true)`"
    },
    "Creates a new NSDistributedNotificationCenter watcher": {
        "prefix": "hs.distributednotifications.new(callback[, name[, object]]) -> object",
        "body": "hs.distributednotifications.new(${1:callback[}, ${2:name[}, ${3:object]]})",
        "description": "Creates a new NSDistributedNotificationCenter watcher\n\nParameters:\n * callback - A function to be called when a matching notification arrives. The function should accept one argument:\n  * notificationName - A string containing the name of the notification\n * name - An optional string containing the name of notifications to watch for. A value of `nil` will cause all notifications to be watched on macOS versions earlier than Catalina. Defaults to `nil`.\n * object - An optional string containing the name of sending objects to watch for. A value of `nil` will cause all sending objects to be watched. Defaults to `nil`.\n\nReturns:\n * An `hs.distributednotifications` object\n\nNotes:\n * On Catalina and above, it is no longer possible to observe all notifications - the `name` parameter is effectively now required. See https://mjtsai.com/blog/2019/10/04/nsdistributednotificationcenter-no-longer-supports-nil-names"
    },
    "Sends a distributed notification": {
        "prefix": "hs.distributednotifications.post(name[, sender[, userInfo]])",
        "body": "hs.distributednotifications.post(${1:name[}, ${2:sender[}, ${3:userInfo]]})",
        "description": "Sends a distributed notification\n\nParameters:\n * name - A string containing the name of the notification\n * sender - An optional string containing the name of the sender of the notification (in the form `com.domain.application.foo`). Defaults to nil.\n * userInfo - An optional table containing additional information to post with the notification. Defaults to nil."
    },
    "Starts a NSDistributedNotificationCenter watcher": {
        "prefix": "hs.distributednotifications:start() -> object",
        "body": "hs.distributednotifications:start()",
        "description": "Starts a NSDistributedNotificationCenter watcher\n\nParameters:\n * None\n\nReturns:\n * The `hs.distributednotifications` object"
    },
    "Stops a NSDistributedNotificationCenter watcher": {
        "prefix": "hs.distributednotifications:stop() -> object",
        "body": "hs.distributednotifications:stop()",
        "description": "Stops a NSDistributedNotificationCenter watcher\n\nParameters:\n * None\n\nReturns:\n * The `hs.distributednotifications` object"
    },
    "Prints the documentation for some part of Hammerspoon's API and Lua 5.3.  This function has also been aliased as `hs.help` and `help` as a shorthand for use within the Hammerspoon console.": {
        "prefix": "hs.doc.help(identifier)",
        "body": "hs.doc.help(${1:identifier})",
        "description": "Prints the documentation for some part of Hammerspoon's API and Lua 5.3.  This function has also been aliased as `hs.help` and `help` as a shorthand for use within the Hammerspoon console.\n\nParameters:\n * identifier - A string containing the signature of some part of Hammerspoon's API (e.g. `\"hs.reload\"`)\n\nReturns:\n * None\n\nNotes:\n * This function is mainly for runtime API help while using Hammerspoon's Console\n\n * Documentation files registered with [hs.doc.registerJSONFile](#registerJSONFile) or [hs.doc.preloadSpoonDocs](#preloadSpoonDocs) that have not yet been actually loaded will be loaded when this command is invoked in any of the forms described below.\n\n * You can also access the results of this function by the following methods from the console:\n   * help(\"prefix.path\") -- quotes are required, e.g. `help(\"hs.reload\")`\n   * help.prefix.path -- no quotes are required, e.g. `help.hs.reload`\n     * `prefix` can be one of the following:\n       * `hs`    - provides documentation for Hammerspoon's builtin commands and modules\n       * `spoon` - provides documentation for the Spoons installed on your system\n       * `lua`   - provides documentation for the version of lua Hammerspoon is using, currently 5.3\n         * `lua._man` - provides the table of contents for the Lua 5.3 manual.  You can pull up a specific section of the lua manual by including the chapter (and subsection) like this: `lua._man._3_4_8`.\n         * `lua._C`   - provides documentation specifically about the Lua C API for use when developing modules which require external libraries.\n     * `path` is one or more components, separated by a period specifying the module, submodule, function, or moethod you wish to view documentation for."
    },
    "Locates the JSON file corresponding to the specified third-party module or Spoon by searching package.path and package.cpath.": {
        "prefix": "hs.doc.locateJSONFile(module) -> path | false, message",
        "body": "hs.doc.locateJSONFile(${1:module})",
        "description": "Locates the JSON file corresponding to the specified third-party module or Spoon by searching package.path and package.cpath.\n\nParameters:\n * module - the name of the module to locate a JSON file for\n\nReturns:\n * the path to the JSON file, or `false, error` if unable to locate a corresponding JSON file.\n\nNotes:\n * The JSON should be named 'docs.json' and located in the same directory as the `lua` or `so` file which is used when the module is loaded via `require`.\n\n * The documentation for core modules is stored in the JSON file specified by the `hs.docstrings_json_file` variable; this function is intended for use in locating the documentation file for third party modules and Spoons."
    },
    "Locates all installed Spoon documentation files and and marks them for loading the next time the [hs.doc.help](#help) function is invoked.": {
        "prefix": "hs.doc.preloadSpoonDocs()",
        "body": "hs.doc.preloadSpoonDocs()",
        "description": "Locates all installed Spoon documentation files and and marks them for loading the next time the [hs.doc.help](#help) function is invoked.\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Returns the list of registered JSON files.": {
        "prefix": "hs.doc.registeredFiles() -> table",
        "body": "hs.doc.registeredFiles()",
        "description": "Returns the list of registered JSON files.\n\nParameters:\n * None\n\nReturns:\n * a table containing the list of registered JSON files\n\nNotes:\n * The table returned by this function has a metatable including a __tostring method which allows you to see the list of registered files by simply typing `hs.doc.registeredFiles()` in the Hammerspoon Console.\n\n * By default, the internal core documentation and portions of the Lua 5.3 manual, located at http://www.lua.org/manual/5.3/manual.html, are already registered for inclusion within this documentation object.\n\n * You can unregister these defaults if you wish to start with a clean slate with the following commands:\n   * `hs.doc.unregisterJSONFile(hs.docstrings_json_file)` -- to unregister the Hammerspoon API docs\n   * `hs.doc.unregisterJSONFile((hs.docstrings_json_file:gsub(\"/docs.json$\",\"/extensions/hs/doc/lua.json\")))` -- to unregister the Lua 5.3 Documentation."
    },
    "Register a JSON file for inclusion when Hammerspoon generates internal documentation.": {
        "prefix": "hs.doc.registerJSONFile(jsonfile, [isSpoon]) -> status[, message]",
        "body": "hs.doc.registerJSONFile(${1:jsonfile}, ${2:[isSpoon]})",
        "description": "Register a JSON file for inclusion when Hammerspoon generates internal documentation.\n\nParameters:\n * jsonfile - A string containing the location of a JSON file\n * isSpoon  - an optional boolean, default false, specifying that the documentation should be added to the `spoons` sub heading in the documentation hierarchy.\n\nReturns:\n * status - Boolean flag indicating if the file was registered or not.  If the file was not registered, then a message indicating the error is also returned.\n\nNotes:\n * this function just registers the documentation file; it won't actually be loaded and parsed until [hs.doc.help](#help) is invoked."
    },
    "Remove a JSON file from the list of registered files.": {
        "prefix": "hs.doc.unregisterJSONFile(jsonfile) -> status[, message]",
        "body": "hs.doc.unregisterJSONFile(${1:jsonfile})",
        "description": "Remove a JSON file from the list of registered files.\n\nParameters:\n * jsonfile - A string containing the location of a JSON file\n\nReturns:\n * status - Boolean flag indicating if the file was unregistered or not.  If the file was not unregistered, then a message indicating the error is also returned.\n\nNotes:\n * This function requires the rebuilding of the entire documentation tree for all remaining registered files, so the next time help is queried with [hs.doc.help](#help), there may be a slight one-time delay."
    },
    "Generates a documentation table for Hammerspoon modules or Spoon bundles from the source files located in the path(s) provided.": {
        "prefix": "hs.doc.builder.genComments(path, [recurse]) -> table",
        "body": "hs.doc.builder.genComments(${1:path}, ${2:[recurse]})",
        "description": "Generates a documentation table for Hammerspoon modules or Spoon bundles from the source files located in the path(s) provided.\n\nParameters:\n * where - a string specifying a single path, or a table containing multiple strings specifying paths where source files should be examined to generate the documentation table.\n * recurse - an optional boolean, default true, specifying whether or not files in sub-directories of the specified path should be examined for comment strings as well.\n\nReturns:\n * table - a table containing the documentation broken out into the key-value pairs used to generate documentation displayed by `hs.doc` and `hs.doc.hsdocs`.\n\nNotes:\n * Because Hammerspoon and all known currently available modules are coded in Objective-C and/or Lua, only files with the .m or .lua extension are examined in the provided path(s).  Please submit an issue (or pull request, if you modify this submodule yourself) at https://github.com/Hammerspoon if you need this to be changed for your addition."
    },
    "Generates a JSON string representation of the documentation source specified. This is the format expected by `hs.doc` and `hs.doc.hsdoc` and is used to provide the built in documentation for Hammerspoon.": {
        "prefix": "hs.doc.builder.genJSON(source) -> string",
        "body": "hs.doc.builder.genJSON(${1:source})",
        "description": "Generates a JSON string representation of the documentation source specified. This is the format expected by `hs.doc` and `hs.doc.hsdoc` and is used to provide the built in documentation for Hammerspoon.\n\nParameters:\n * source - the source to generate the JSON string for.  If this is provided as a string, it is passed to [hs.doc.builder.genComments](#genComments) and the result is used.  If it is a table, then it is assumed to have already been generated by a call to [hs.doc.builder.genComments](#genComments).\n\nReturns:\n * string - the JSON string representation of the documentation\n\nNotes:\n * If you have installed the `hs` command line tool (see `hs.ipc`), you can use the following to generate the `docs.json` file that is used to provide documentation for Hammerspoon Spoon bundles: `hs -c \"hs.doc.builder.genJSON(\\\"$(pwd)\\\")\" > docs.json`\n * You can also use this to generate documentation for any third-party-modules you build, but you will have to register the documentation with `hs.doc.registerJSONFile` yourself -- it is not automatically loaded for you like it is for Spoons."
    },
    "Generates the SQL commands required for creating the search index when creating a docset of the documentation.": {
        "prefix": "hs.doc.builder.genSQL(source) -> string",
        "body": "hs.doc.builder.genSQL(${1:source})",
        "description": "Generates the SQL commands required for creating the search index when creating a docset of the documentation.\n\nParameters:\n * source - the source to generate the SQL commands for.  If this is provided as a string, it is passed to [hs.doc.builder.genComments](#genComments) and the result is used.  If it is a table, then it is assumed to have already been generated by a call to [hs.doc.builder.genComments](#genComments).\n\nReturns:\n * string - the relevant SQL commands as a string"
    },
    "Get or set whether or not the Hammerspoon browser renders output in Dark mode.": {
        "prefix": "hs.doc.hsdocs.browserDarkMode([value]) -> currentValue",
        "body": "hs.doc.hsdocs.browserDarkMode(${1:[value]})",
        "description": "Get or set whether or not the Hammerspoon browser renders output in Dark mode.\n\nParameters:\n * value - an optional boolean, number, or nil specifying whether or not the documentation browser renders in Dark mode.\n   * if value is `true`, then the HTML output will always be inverted\n   * if value is `false`, then the HTML output will never be inverted\n   * if value is `nil`, then the output will be inverted only when the OS X theme is set to Dark mode\n   * if the value is a number between 0 and 100, the number specifies the inversion ratio, where 0 means no inversion, 100 means full inversion, and 50 is completely unreadable because the foreground and background are equally adjusted.\n\nReturns:\n * the current, possibly new, value\n\nNotes:\n * Inversion is applied through the use of CSS filtering, so while numeric values other than 0 (false) and 100 (true) are allowed, the result is generally not what is desired.\n\n * Changes made with this function are saved with `hs.settings` with the label \"_documentationServer.invertDocs\" and will persist through a reload or restart of Hammerspoon."
    },
    "Get or set the currently saved initial frame location for the documentation browser.": {
        "prefix": "hs.doc.hsdocs.browserFrame([frameTable]) -> currentValue",
        "body": "hs.doc.hsdocs.browserFrame(${1:[frameTable]})",
        "description": "Get or set the currently saved initial frame location for the documentation browser.\n\nParameters:\n * frameTable - a frame table containing x, y, h, and w values specifying the browser's initial position when Hammerspoon starts.\n\nReturns:\n * the current, possibly new, value\n\nNotes:\n * If [hs.doc.hsdocs.trackBrowserFrame](#trackBrowserFrame) is false or nil (the default), then you can use this function to specify the initial position of the documentation browser.\n * If [hs.doc.hsdocs.trackBrowserFrame](#trackBrowserFrame) is true, then this any value set with this function will be overwritten whenever the browser window is moved or resized.\n\n * Changes made with this function are saved with `hs.settings` with the label \"_documentationServer.browserFrame\" and will persist through a reload or restart of Hammerspoon."
    },
    "Get or set whether or not [hs.doc.hsdocs.help](#help) uses an external browser.": {
        "prefix": "hs.doc.hsdocs.forceExternalBrowser([value]) -> currentValue",
        "body": "hs.doc.hsdocs.forceExternalBrowser(${1:[value]})",
        "description": "Get or set whether or not [hs.doc.hsdocs.help](#help) uses an external browser.\n\nParameters:\n * value - an optional boolean or string, default false, specifying whether or not documentation requests will be displayed in an external browser or the internal one handled by `hs.webview`.\n\nReturns:\n * the current, possibly new, value\n\nNotes:\n * If this value is set to true, help requests invoked by [hs.doc.hsdocs.help](#help) will be invoked by your system's default handler for the `http` scheme.\n * If this value is set to a string, the string specifies the bundle ID of an application which will be used to handle the url request for the documentation.  The string should match one of the items returned by `hs.urlevent.getAllHandlersForScheme(\"http\")`.\n\n * This behavior is triggered automatically, regardless of this setting, if you are running with a version of OS X prior to 10.10, since `hs.webview` requires OS X 10.10 or later.\n\n * Changes made with this function are saved with `hs.settings` with the label \"_documentationServer.forceExternalBrowser\" and will persist through a reload or restart of Hammerspoon."
    },
    "Display the documentation for the specified Hammerspoon function, or the Table of Contents for the Hammerspoon documentation in a built-in mini browser.": {
        "prefix": "hs.doc.hsdocs.help([identifier]) -> nil",
        "body": "hs.doc.hsdocs.help(${1:[identifier]})",
        "description": "Display the documentation for the specified Hammerspoon function, or the Table of Contents for the Hammerspoon documentation in a built-in mini browser.\n\nParameters:\n * an optional string specifying a Hammerspoon module, function, or method to display documentation for. If you leave out this parameter, the table of contents for the Hammerspoon built-in documentation is displayed instead.\n\nReturns:\n * None"
    },
    "Get or set the network interface that the Hammerspoon documentation web server will be served on": {
        "prefix": "hs.doc.hsdocs.interface([interface]) -> currentValue",
        "body": "hs.doc.hsdocs.interface(${1:[interface]})",
        "description": "Get or set the network interface that the Hammerspoon documentation web server will be served on\n\nParameters:\n * interface - an optional string, or nil, specifying the network interface the Hammerspoon documentation web server will be served on.  An explicit nil specifies that the web server should listen on all active interfaces for the machine.  Defaults to \"localhost\".\n\nReturns:\n * the current, possibly new, value\n\nNotes:\n * See `hs.httpserver.setInterface` for a description of valid values that can be specified as the `interface` argument to this function.\n * A change to the interface can only occur when the documentation server is not running. If the server is currently active when you call this function with an argument, the server will be temporarily stopped and then restarted after the interface has been changed.\n\n * Changes made with this function are saved with `hs.settings` with the label \"_documentationServer.interface\" and will persist through a reload or restart of Hammerspoon."
    },
    "Get or set whether or not a module's entity list is displayed as a column on the left of the rendered page.": {
        "prefix": "hs.doc.hsdocs.moduleEntitiesInSidebar([value]) -> currentValue",
        "body": "hs.doc.hsdocs.moduleEntitiesInSidebar(${1:[value]})",
        "description": "Get or set whether or not a module's entity list is displayed as a column on the left of the rendered page.\n\nParameters:\n * value - an optional boolean specifying whether or not a module's entity list is displayed inline in the documentation (false) or in a sidebar on the left (true).\n\nReturns:\n * the current, possibly new, value\n\nNotes:\n * This is experimental and is disabled by default. It was inspired by a Userscript written by krasnovpro.  The original can be found at https://openuserjs.org/scripts/krasnovpro/hammerspoon.org_Documentation/source.\n\n * Changes made with this function are saved with `hs.settings` with the label \"_documentationServer.entitiesInSidebar\" and will persist through a reload or restart of Hammerspoon."
    },
    "Get or set the Hammerspoon documentation server HTTP port.": {
        "prefix": "hs.doc.hsdocs.port([value]) -> currentValue",
        "body": "hs.doc.hsdocs.port(${1:[value]})",
        "description": "Get or set the Hammerspoon documentation server HTTP port.\n\nParameters:\n * value - an optional number specifying the port for the Hammerspoon documentation web server\n\nReturns:\n * the current, possibly new, value\n\nNotes:\n * The default port number is 12345.\n\n * Changes made with this function are saved with `hs.settings` with the label \"_documentationServer.serverPort\" and will persist through a reload or restart of Hammerspoon."
    },
    "Start the Hammerspoon internal documentation web server.": {
        "prefix": "hs.doc.hsdocs.start() -> `hs.doc.hsdocs`",
        "body": "hs.doc.hsdocs.start()",
        "description": "Start the Hammerspoon internal documentation web server.\n\nParameters:\n * None\n\nReturns:\n * the table representing the `hs.doc.hsdocs` module\n\nNotes:\n * This function is automatically called, if necessary, when [hs.doc.hsdocs.help](#help) is invoked.\n * The documentation web server can be viewed from a web browser by visiting \"http://localhost:port\" where `port` is the port the server is running on, 12345 by default -- see [hs.doc.hsdocs.port](#port)."
    },
    "Stop the Hammerspoon internal documentation web server.": {
        "prefix": "hs.doc.hsdocs.stop() -> `hs.doc.hsdocs`",
        "body": "hs.doc.hsdocs.stop()",
        "description": "Stop the Hammerspoon internal documentation web server.\n\nParameters:\n * None\n\nReturns:\n * the table representing the `hs.doc.hsdocs` module"
    },
    "Get or set whether or not changes in the documentation browsers location and size persist through launches of Hammerspoon.": {
        "prefix": "hs.doc.hsdocs.trackBrowserFrame([value]) -> currentValue",
        "body": "hs.doc.hsdocs.trackBrowserFrame(${1:[value]})",
        "description": "Get or set whether or not changes in the documentation browsers location and size persist through launches of Hammerspoon.\n\nParameters:\n * value - an optional boolean specifying whether or not the browsers location should be saved across launches of Hammerspoon.\n\nReturns:\n * the current, possibly new, value\n\nNotes:\n * Changes made with this function are saved with `hs.settings` with the label \"_documentationServer.trackBrowserFrameChanges\" and will persist through a reload or restart of Hammerspoon."
    },
    "Converts markdown encoded text to html or plaintext.": {
        "prefix": "hs.doc.markdown.convert(markdown, [type]) -> output",
        "body": "hs.doc.${1:markdown}.convert(markdown, ${2:[type]})",
        "description": "Converts markdown encoded text to html or plaintext.\n\nParameters:\n * markdown - a string containing the input text encoded using markdown tags\n * type     - an optional string specifying the conversion options and output type.  Defaults to \"gfm\".  The currently recognized types are:\n   * \"markdown\"  - specfies that the output should be HTML with the standard GitHub/Markdown extensions enabled.\n   * \"gfm\"       - specifies that the output should be HTML with additional GitHub extensions enabled.\n   * \"plaintext\" - specifies that the output should plain text with the standard GitHub/Markdown extensions enabled.\n\nReturns:\n * an HTML or plaintext representation of the markdown encoded text provided.\n\nNotes:\n * The standard GitHub/Markdown extensions enabled for all conversions are:\n   * NO_INTRA_EMPHASIS -  disallow emphasis inside of words\n   * LAX_SPACING       - supports spacing like in Markdown 1.0.0 (i.e. do not require an empty line between two different blocks in a paragraph)\n   * STRIKETHROUGH     - support strikethrough with double tildes (~)\n   * TABLES            - support Markdown tables\n   * FENCED_CODE       - supports fenced code blocks surround by three back-ticks (`) or three tildes (~)\n   * AUTOLINK          - HTTP URL's are treated as links, even if they aren't marked as such with Markdown tags\n\n * The \"gfm\" type also includes the following extensions:\n  * HARD_WRAP     - line breaks are replaced with <br> entities\n  * SPACE_HEADERS - require a space between the `#` and the name of a header (prevents collisions with the Issues filter)"
    },
    "Bounce Hammerspoon's dock icon": {
        "prefix": "hs.dockicon.bounce(indefinitely)",
        "body": "hs.dockicon.bounce(${1:indefinitely})",
        "description": "Bounce Hammerspoon's dock icon\n\nParameters:\n * indefinitely - A boolean value, true if the dock icon should bounce until the dock icon is clicked, false if the dock icon should only bounce briefly"
    },
    "Hide Hammerspoon's dock icon": {
        "prefix": "hs.dockicon.hide()",
        "body": "hs.dockicon.hide()",
        "description": "Hide Hammerspoon's dock icon\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Set Hammerspoon's dock icon badge": {
        "prefix": "hs.dockicon.setBadge(badge)",
        "body": "hs.dockicon.setBadge(${1:badge})",
        "description": "Set Hammerspoon's dock icon badge\n\nParameters:\n * badge - A string containing the label to place inside the dock icon badge. If the string is empty, the badge will be cleared"
    },
    "Make Hammerspoon's dock icon visible": {
        "prefix": "hs.dockicon.show()",
        "body": "hs.dockicon.show()",
        "description": "Make Hammerspoon's dock icon visible\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Get or set a canvas object to be displayed as the Hamemrspoon dock icon": {
        "prefix": "hs.dockicon.tileCanvas([canvas]) -> canvasObject | nil",
        "body": "hs.dockicon.tileCanvas(${1:[canvas]})",
        "description": "Get or set a canvas object to be displayed as the Hamemrspoon dock icon\n\nParameters:\n * `canvas` - an optional `hs.canvas` object specifying the canvas to be displayed as the dock icon for Hammerspoon. If an explicit `nil` is specified, the dock icon will revert to the Hammerspoon application icon.\n\nReturns:\n * If the dock icon is assigned a canvas object, that canvas object will be returned, otherwise returns nil.\n\nNotes:\n * If you update the canvas object by changing any of its components, it will not be reflected in the dock icon until you invoke [hs.dockicon.tileUpdate](#tileUpdate)."
    },
    "Returns a table containing the size of the tile representing the dock icon.": {
        "prefix": "hs.dockicon.tileSize() -> size table",
        "body": "hs.dockicon.tileSize()",
        "description": "Returns a table containing the size of the tile representing the dock icon.\n\nParameters:\n * None\n\nReturns:\n * a table containing the size of the tile representing the dock icon for Hammerspoon. This table will contain `h` and `w` keys specifying the tile height and width as numbers.\n\nNotes:\n * the size returned specifies the display size of the dock icon tile. If your canvas item is larger than this, then only the top left portion corresponding to the size returned will be displayed."
    },
    "Force an update of the dock icon.": {
        "prefix": "hs.dockicon.tileUpdate() -> none",
        "body": "hs.dockicon.tileUpdate()",
        "description": "Force an update of the dock icon.\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * Changes made to a canvas object are not reflected automatically like they are when a canvas is being displayed on the screen; you must invoke this method after making changes to the canvas for the updates to be reflected in the dock icon."
    },
    "Determine whether Hammerspoon's dock icon is visible": {
        "prefix": "hs.dockicon.visible() -> bool",
        "body": "hs.dockicon.visible()",
        "description": "Determine whether Hammerspoon's dock icon is visible\n\nParameters:\n * None\n\nReturns:\n * A boolean, true if the dock icon is visible, false if not"
    },
    "Get the alpha level of the window containing the hs.drawing object.": {
        "prefix": "hs.drawing:alpha() -> number",
        "body": "hs.drawing:alpha()",
        "description": "Get the alpha level of the window containing the hs.drawing object.\n\nParameters:\n * None\n\nReturns:\n * The current alpha level for the hs.drawing object"
    },
    "Creates a new image object with the icon of a given app": {
        "prefix": "hs.drawing.appImage(sizeRect, bundleID) -> drawingObject or nil",
        "body": "hs.drawing.appImage(${1:sizeRect}, ${2:bundleID})",
        "description": "Creates a new image object with the icon of a given app\n\nParameters:\n * sizeRect - A rect-table containing the location/size of the image. If the size values are -1 then the image will be displayed at the icon's native size\n * bundleID - A string containing the bundle identifier of an app (e.g. \"com.apple.Safari\")\n\nReturns:\n * An `hs.drawing` object, or nil if an error occurs"
    },
    "Creates a new arc object": {
        "prefix": "hs.drawing.arc(centerPoint, radius, startAngle, endAngle) -> drawingObject or nil",
        "body": "hs.drawing.arc(${1:centerPoint}, ${2:radius}, ${3:startAngle}, ${4:endAngle})",
        "description": "Creates a new arc object\n\nParameters:\n * centerPoint - A point-table containing the center of the circle used to define the arc\n * radius      - The radius of the circle used to define the arc\n * startAngle  - The starting angle of the arc, measured in degrees clockwise from the y-axis.\n * endAngle    - The ending angle of the arc, measured in degrees clockwise from the y-axis.\n\nReturns:\n * An `hs.drawing` object, or nil if an error occurs\n\nNotes:\n * This constructor is actually a wrapper for the `hs.drawing.ellipticalArc` constructor."
    },
    "Returns the current behavior of the hs.drawing object with respect to Spaces and Expos\u00e9 for the object.": {
        "prefix": "hs.drawing:behavior() -> number",
        "body": "hs.drawing:behavior()",
        "description": "Returns the current behavior of the hs.drawing object with respect to Spaces and Expos\u00e9 for the object.\n\nParameters:\n * None\n\nReturns:\n * The numeric representation of the current behaviors for the hs.drawing object"
    },
    "Returns a table of the labels for the current behaviors of the object.": {
        "prefix": "hs.drawing:behaviorAsLabels() -> table",
        "body": "hs.drawing:behaviorAsLabels()",
        "description": "Returns a table of the labels for the current behaviors of the object.\n\nParameters:\n * None\n\nReturns:\n * Returns a table of the labels for the current behaviors with respect to Spaces and Expos\u00e9 for the object."
    },
    "Places the drawing object on top of normal windows": {
        "prefix": "hs.webview:bringToFront([aboveEverything]) -> webviewObject",
        "body": "hs.webview:bringToFront(${1:[aboveEverything]})",
        "description": "Places the drawing object on top of normal windows\n\nParameters:\n * `aboveEverything` - An optional boolean value that controls how far to the front the webview should be placed. True to place the webview on top of all windows (including the dock and menubar and fullscreen windows), false to place the webview above normal windows, but below the dock, menubar and fullscreen windows. Defaults to false.\n\nReturns:\n * The webview object"
    },
    "Creates a new circle object": {
        "prefix": "hs.drawing.circle(sizeRect) -> drawingObject or nil",
        "body": "hs.drawing.circle(${1:sizeRect})",
        "description": "Creates a new circle object\n\nParameters:\n * sizeRect - A rect-table containing the location/size of the circle\n\nReturns:\n * An `hs.drawing` object, or nil if an error occurs"
    },
    "Get or set whether or not clicking on a drawing with a click callback defined should bring all of Hammerspoon's open windows to the front.": {
        "prefix": "hs.drawing:clickCallbackActivating([false]) -> drawingObject or current value",
        "body": "hs.drawing:clickCallbackActivating(${1:[false]})",
        "description": "Get or set whether or not clicking on a drawing with a click callback defined should bring all of Hammerspoon's open windows to the front.\n\nParameters:\n * flag - an optional boolean indicating whether or not clicking on a drawing with a click callback function defined should activate Hammerspoon and bring its windows forward.  Defaults to true.\n\nReturns:\n * If a setting value is provided, the drawing object is returned; if no argument is provided, the current setting is returned.\n\nNotes:\n * Setting this to false changes a drawing object's AXsubrole value and may affect the results of filters defined for hs.window.filter, depending upon how they are defined."
    },
    "Set the screen area in which the drawing contents are visible.": {
        "prefix": "hs.drawing:clippingRectangle([rect | nil]) -> drawingObject or current value",
        "body": "hs.drawing:clippingRectangle(${1:[rect | nil]})",
        "description": "Set the screen area in which the drawing contents are visible.\n\nParameters:\n * rect - an optional rectangle specifying the visible area of the screen where the drawing's contents are visible.  If an explicit `nil` is specified, no clipping rectangle is set.  Defaults to nil\n\nReturns:\n * if an argument is provided, returns the drawing object; otherwise the current value is returned.\n\nNotes:\n * This method can be used to specify the area of the display where this drawing should be visible.  If any portion of the drawing extends beyond this rectangle, the image is clipped so that only the portion within this rectangle is visible.\n * The rectangle defined by this method is independant of the drawing's actual frame -- if you move the drawing with [hs.drawing:setFrame](#setFrame) or [hs.drawing:setTopLeft](#setTopLeft), this rectangle retains its current value.\n\n * This method does not work for image objects at present."
    },
    "Returns a table containing the default font, size, color, and paragraphStyle used by `hs.drawing` for text drawing objects.": {
        "prefix": "hs.drawing.defaultTextStyle() -> `hs.styledtext` attributes table",
        "body": "hs.drawing.defaultTextStyle()",
        "description": "Returns a table containing the default font, size, color, and paragraphStyle used by `hs.drawing` for text drawing objects.\n\nParameters:\n * None\n\nReturns:\n * a table containing the default style attributes `hs.drawing` uses for text drawing objects in the `hs.styledtext` attributes table format.\n\nNotes:\n * This method returns the default font, size, color, and paragraphStyle used by `hs.drawing` for text objects.  If you modify a drawing object's defaults with `hs.drawing:setColor`, `hs.drawing:setTextFont`, or `hs.drawing:setTextSize`, the changes will not be reflected by this function."
    },
    "Destroys the drawing object": {
        "prefix": "hs.drawing:delete()",
        "body": "hs.drawing:delete()",
        "description": "Destroys the drawing object\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This method immediately destroys the drawing object. If you want it to fade out, use `:hide()` first, with some suitable time, and `hs.timer.doAfter()` to schedule the `:delete()` call"
    },
    "Tells the OS X window server to pause updating the physical displays for a short while.": {
        "prefix": "hs.drawing.disableScreenUpdates() -> None",
        "body": "hs.drawing.disableScreenUpdates()",
        "description": "Tells the OS X window server to pause updating the physical displays for a short while.\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This method can be used to allow multiple changes which are being made to the users display appear as if they all occur simultaneously by holding off on updating the screen on the regular schedule.\n * This method should always be balanced with a call to [hs.drawing.enableScreenUpdates](#enableScreenUpdates) when your updates have been completed.  Failure to do so will be logged in the system logs.\n * The window server will only allow you to pause updates for up to 1 second.  This prevents a rogue or hung process from locking the systems display completely.  Updates will be resumed when [hs.drawing.enableScreenUpdates](#enableScreenUpdates) is encountered or after 1 second, whichever comes first.\n * The underlying OS function for disabling screen updates is deprecated."
    },
    "Creates a new elliptical arc object": {
        "prefix": "hs.drawing.ellipticalArc(sizeRect, startAngle, endAngle) -> drawingObject or nil",
        "body": "hs.drawing.ellipticalArc(${1:sizeRect}, ${2:startAngle}, ${3:endAngle})",
        "description": "Creates a new elliptical arc object\n\nParameters:\n * sizeRect    - A rect-table containing the location and size of the ellipse used to define the arc\n * startAngle  - The starting angle of the arc, measured in degrees clockwise from the y-axis.\n * endAngle    - The ending angle of the arc, measured in degrees clockwise from the y-axis.\n\nReturns:\n * An `hs.drawing` object, or nil if an error occurs"
    },
    "Tells the OS X window server to resume updating the physical displays after a previous pause.": {
        "prefix": "hs.drawing.enableScreenUpdates() -> None",
        "body": "hs.drawing.enableScreenUpdates()",
        "description": "Tells the OS X window server to resume updating the physical displays after a previous pause.\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * In conjunction with [hs.drawing.disableScreenUpdates](#disableScreenUpdates), this method can be used to allow multiple changes which are being made to the users display appear as if they all occur simultaneously by holding off on updating the screen on the regular schedule.\n * The window server will only allow you to pause updates for up to 1 second.  This prevents a rogue or hung process from locking the systems display completely.  Updates will be resumed when this function is encountered  or after 1 second, whichever comes first.\n * The underlying OS function for enabling screen updates is deprecated."
    },
    "Gets the frame of a drawingObject in absolute coordinates": {
        "prefix": "hs.drawing:frame() -> hs.geometry object",
        "body": "hs.drawing:frame()",
        "description": "Gets the frame of a drawingObject in absolute coordinates\n\nParameters:\n * None\n\nReturns:\n * An `hs.geometry` object containing the frame of the drawing object"
    },
    "Gets the text of a drawing object as an `hs.styledtext` object": {
        "prefix": "hs.drawing:getStyledText() -> `hs.styledtext` object",
        "body": "hs.drawing:getStyledText()",
        "description": "Gets the text of a drawing object as an `hs.styledtext` object\n\nParameters:\n * None\n\nReturns:\n * an `hs.styledtext` object\n\nNotes:\n * This method should only be used on text drawing objects"
    },
    "Get the size of the rectangle necessary to fully render the text with the specified style so that is will be completely visible.": {
        "prefix": "hs.drawing.getTextDrawingSize(styledTextObject or theText, [textStyle]) -> sizeTable | nil",
        "body": "hs.drawing.getTextDrawingSize(${1:styledTextObject or theText}, ${2:[textStyle]})",
        "description": "Get the size of the rectangle necessary to fully render the text with the specified style so that is will be completely visible.\n\nParameters:\n * styledTextObject - an object created with the hs.styledtext module or its table representation (see `hs.styledtext`).\n\n The following simplified style format is supported for use with `hs.drawing:setText` and `hs.drawing.setTextStyle`.\n\n * theText   - the text which is to be displayed.\n * textStyle - a table containing one or more of the following keys to set for the text of the drawing object (if textStyle is nil or missing, the `hs.drawing` defaults are used):\n   * font      - the name of the font to use (default: the system font)\n   * size      - the font point size to use (default: 27.0)\n   * color     - ignored, but accepted for compatibility with `hs.drawing:setTextStyle()`\n   * alignment - a string of one of the following indicating the texts alignment within the drawing objects frame:\n     * \"left\"      - the text is visually left aligned.\n     * \"right\"     - the text is visually right aligned.\n     * \"center\"    - the text is visually center aligned.\n     * \"justified\" - the text is justified\n     * \"natural\"   - (default) the natural alignment of the text\u2019s script\n   * lineBreak - a string of one of the following indicating how to wrap text which exceeds the drawing object's frame:\n     * \"wordWrap\"       - (default) wrap at word boundaries, unless the word itself doesn\u2019t fit on a single line\n     * \"charWrap\"       - wrap before the first character that doesn\u2019t fit\n     * \"clip\"           - do not draw past the edge of the drawing object frame\n     * \"truncateHead\"   - the line is displayed so that the end fits in the frame and the missing text at the beginning of the line is indicated by an ellipsis\n     * \"truncateTail\"   - the line is displayed so that the beginning fits in the frame and the missing text at the end of the line is indicated by an ellipsis\n     * \"truncateMiddle\" - the line is displayed so that the beginning and end fit in the frame and the missing text in the middle is indicated by an ellipsis\n\nReturns:\n * sizeTable - a table containing the Height and Width necessary to fully display the text drawing object, or nil if an error occurred\n\nNotes:\n * This function assumes the default values specified for any key which is not included in the provided textStyle.\n * The size returned is an approximation and may return a width that is off by about 4 points.  Use the returned size as a minimum starting point. Sometimes using the \"clip\" or \"truncateMiddle\" lineBreak modes or \"justified\" alignment will fit, but its safest to add in your own buffer if you have the space in your layout.\n * Multi-line text (separated by a newline or return) is supported.  The height will be for the multiple lines and the width returned will be for the longest line."
    },
    "Hides the drawing object": {
        "prefix": "hs.drawing:hide([fadeOutTime]) -> drawingObject",
        "body": "hs.drawing:hide(${1:[fadeOutTime]})",
        "description": "Hides the drawing object\n\nParameters:\n * fadeOut - An optional number of seconds over which to fade out the drawing object. Defaults to zero\n\nReturns:\n * The drawing object"
    },
    "Creates a new image object": {
        "prefix": "hs.drawing.image(sizeRect, imageData) -> drawingObject or nil",
        "body": "hs.drawing.image(${1:sizeRect}, ${2:imageData})",
        "description": "Creates a new image object\n\nParameters:\n * sizeRect - A rect-table containing the location/size of the image\n * imageData - This can be either:\n  * An `hs.image` object\n  * A string containing a path to an image file\n  * A string beginning with `ASCII:` which signifies that the rest of the string is interpreted as a special form of ASCII diagram, which will be rendered to an image. See the notes below for information about the special format of ASCII diagram.\n\nReturns:\n * An `hs.drawing` object, or nil if an error occurs\n * Paths relative to the PWD of Hammerspoon (typically ~/.hammerspoon/) will work, but paths relative to the UNIX homedir character, `~` will not\n * Animated GIFs are supported. They're not super friendly on your CPU, but they work\n\nNotes:\n * To use the ASCII diagram image support, see http://cocoamine.net/blog/2015/03/20/replacing-photoshop-with-nsstring/ and be sure to preface your ASCII diagram with the special string `ASCII:`"
    },
    "Get or set the alignment of an image that doesn't fully fill the drawing objects frame.": {
        "prefix": "hs.drawing:imageAlignment([type]) -> drawingObject or current value",
        "body": "hs.drawing:imageAlignment(${1:[type]})",
        "description": "Get or set the alignment of an image that doesn't fully fill the drawing objects frame.\n\nParameters:\n * type - an optional string value which should match one of the following (default is center):\n   * topLeft      - the image's top left corner will match the drawing frame's top left corner\n   * top          - the image's top match the drawing frame's top and will be centered horizontally\n   * topRight     - the image's top right corner will match the drawing frame's top right corner\n   * left         - the image's left side will match the drawing frame's left side and will be centered vertically\n   * center       - the image will be centered vertically and horizontally within the drawing frame\n   * right        - the image's right side will match the drawing frame's right side and will be centered vertically\n   * bottomLeft   - the image's bottom left corner will match the drawing frame's bottom left corner\n   * bottom       - the image's bottom match the drawing frame's bottom and will be centered horizontally\n   * bottomRight  - the image's bottom right corner will match the drawing frame's bottom right corner\n\nReturns:\n * If a setting value is provided, the drawing object is returned; if no argument is provided, the current setting is returned."
    },
    "Get or set whether or not an animated GIF image should cycle through its animation.": {
        "prefix": "hs.drawing:imageAnimates([flag]) -> drawingObject or current value",
        "body": "hs.drawing:imageAnimates(${1:[flag]})",
        "description": "Get or set whether or not an animated GIF image should cycle through its animation.\n\nParameters:\n * flag - an optional boolean flag indicating whether or not an animated GIF image should cycle through its animation.  Defaults to true.\n\nReturns:\n * If a setting value is provided, the drawing object is returned; if no argument is provided, the current setting is returned."
    },
    "Get or set what type of frame should be around the drawing frame of the image.": {
        "prefix": "hs.drawing:imageFrame([type]) -> drawingObject or current value",
        "body": "hs.drawing:imageFrame(${1:[type]})",
        "description": "Get or set what type of frame should be around the drawing frame of the image.\n\nParameters:\n * type - an optional string value which should match one of the following (default is none):\n   * none   - no frame is drawing around the drawingObject's frameRect\n   * photo  - a thin black outline with a white background and a dropped shadow.\n   * bezel  - a gray, concave bezel with no background that makes the image look sunken.\n   * groove - a thin groove with a gray background that looks etched around the image.\n   * button - a convex bezel with a gray background that makes the image stand out in relief, like a button.\n\nReturns:\n * If a setting value is provided, the drawing object is returned; if no argument is provided, the current setting is returned.\n\nNotes:\n * Apple considers the photo, groove, and button style frames \"stylistically obsolete\" and if a frame is required, recommend that you use the bezel style or draw your own to more closely match the OS look and feel."
    },
    "Get or set how an image is scaled within the frame of a drawing object containing an image.": {
        "prefix": "hs.drawing:imageScaling([type]) -> drawingObject or current value",
        "body": "hs.drawing:imageScaling(${1:[type]})",
        "description": "Get or set how an image is scaled within the frame of a drawing object containing an image.\n\nParameters:\n * type - an optional string value which should match one of the following (default is scaleProportionally):\n   * shrinkToFit         - shrink the image, preserving the aspect ratio, to fit the drawing frame only if the image is larger than the drawing frame.\n   * scaleToFit          - shrink or expand the image to fully fill the drawing frame.  This does not preserve the aspect ratio.\n   * none                - perform no scaling or resizing of the image.\n   * scalePropertionally - shrink or expand the image to fully fill the drawing frame, preserving the aspect ration.\n\nReturns:\n * If a setting value is provided, the drawing object is returned; if no argument is provided, the current setting is returned."
    },
    "Creates a new line object": {
        "prefix": "hs.drawing.line(originPoint, endPoint) -> drawingObject or nil",
        "body": "hs.drawing.line(${1:originPoint}, ${2:endPoint})",
        "description": "Creates a new line object\n\nParameters:\n * originPoint - A point-table containing the co-ordinates of the starting point of the line\n * endPoint - A point-table containing the co-ordinates of the end point of the line\n\nReturns:\n * An `hs.drawing` object, or nil if an error occurs"
    },
    "Moves drawing object above drawing object2, or all drawing objects in the same presentation level, if object2 is not provided.": {
        "prefix": "hs.drawing:orderAbove([object2]) -> object",
        "body": "hs.drawing:orderAbove(${1:[object2]})",
        "description": "Moves drawing object above drawing object2, or all drawing objects in the same presentation level, if object2 is not provided.\n\nParameters:\n * Optional drawing object to place the drawing object above.\n\nReturns:\n * The `hs.drawing` object"
    },
    "Moves drawing object below drawing object2, or all drawing objects in the same presentation level, if object2 is not provided.": {
        "prefix": "hs.drawing:orderBelow([object2]) -> object1",
        "body": "hs.drawing:orderBelow(${1:[object2]})",
        "description": "Moves drawing object below drawing object2, or all drawing objects in the same presentation level, if object2 is not provided.\n\nParameters:\n * Optional drawing object to place the drawing object below.\n\nReturns:\n * The `hs.drawing` object"
    },
    "Creates a new rectangle object": {
        "prefix": "hs.drawing.rectangle(sizeRect) -> drawingObject or nil",
        "body": "hs.drawing.rectangle(${1:sizeRect})",
        "description": "Creates a new rectangle object\n\nParameters:\n * sizeRect - A rect-table containing the location/size of the rectangle\n\nReturns:\n * An `hs.drawing` object, or nil if an error occurs"
    },
    "Rotates an image clockwise around its center": {
        "prefix": "hs.drawing:rotateImage(angle) -> drawingObject",
        "body": "hs.drawing:rotateImage(${1:angle})",
        "description": "Rotates an image clockwise around its center\n\nParameters:\n * angle - the angle in degrees to rotate the image around its center in a clockwise direction.\n\nReturns:\n * The drawing object\n\nNotes:\n* This method works by rotating the image view within its drawing window.  This means that an image which completely fills its viewing area will most likely be cropped in some places.  Best results are achieved with images that have clear space around their edges or with `hs.drawing.imageScaling` set to \"none\"."
    },
    "Places the drawing object behind normal windows, between the desktop wallpaper and desktop icons": {
        "prefix": "hs.drawing:sendToBack() -> drawingObject",
        "body": "hs.drawing:sendToBack()",
        "description": "Places the drawing object behind normal windows, between the desktop wallpaper and desktop icons\n\nParameters:\n * None\n\nReturns:\n * The drawing object"
    },
    "Sets the alpha level of the window containing the hs.drawing object.": {
        "prefix": "hs.drawing:setAlpha(level) -> object",
        "body": "hs.drawing:setAlpha(${1:level})",
        "description": "Sets the alpha level of the window containing the hs.drawing object.\n\nParameters:\n * level - the alpha level (0.0 - 1.0) to set the object to\n\nReturns:\n * The `hs.drawing` object"
    },
    "Changes the starting and ending angles for an arc drawing object": {
        "prefix": "hs.drawing:setArcAngles(startAngle, endAngle) -> drawingObject",
        "body": "hs.drawing:setArcAngles(${1:startAngle}, ${2:endAngle})",
        "description": "Changes the starting and ending angles for an arc drawing object\n\nParameters:\n * startAngle  - The starting angle of the arc, measured in degrees clockwise from the y-axis.\n * endAngle    - The ending angle of the arc, measured in degrees clockwise from the y-axis.\n\nReturns:\n * The drawing object\n\nNotes:\n * This method should only be used on arc drawing objects"
    },
    "Sets the window behaviors represented by the number provided for the window containing the hs.drawing object.": {
        "prefix": "hs.drawing:setBehavior(behavior) -> object",
        "body": "hs.drawing:setBehavior(${1:behavior})",
        "description": "Sets the window behaviors represented by the number provided for the window containing the hs.drawing object.\n\nParameters:\n * behavior - the numeric representation of the behaviors to set for the window of the object\n\nReturns:\n * The `hs.drawing` object"
    },
    "Sets the window behaviors based upon the labels specified in the table provided.": {
        "prefix": "hs.drawing:setBehaviorByLabels(table) -> object",
        "body": "hs.drawing:setBehaviorByLabels(${1:table})",
        "description": "Sets the window behaviors based upon the labels specified in the table provided.\n\nParameters:\n * a table of label strings or numbers.  Recognized values can be found in `hs.drawing.windowBehaviors`.\n\nReturns:\n * The `hs.drawing` object"
    },
    "Sets a callback for mouseUp and mouseDown click events": {
        "prefix": "hs.drawing:setClickCallback(mouseUpFn, mouseDownFn) -> drawingObject",
        "body": "hs.drawing:setClickCallback(${1:mouseUpFn}, ${2:mouseDownFn})",
        "description": "Sets a callback for mouseUp and mouseDown click events\n\nParameters:\n * mouseUpFn - A function, can be nil, that will be called when the drawing object is clicked on and the mouse button is released. If this argument is nil, any existing callback is removed.\n * mouseDownFn - A function, can be nil, that will be called when the drawing object is clicked on and the mouse button is first pressed down. If this argument is nil, any existing callback is removed.\n\nReturns:\n * The drawing object\n\nNotes:\n * No distinction is made between the left, right, or other mouse buttons -- they all invoke the same up or down function.  If you need to determine which specific button was pressed, use `hs.eventtap.checkMouseButtons()` within your callback to check."
    },
    "Sets whether or not to fill a drawing object": {
        "prefix": "hs.drawing:setFill(doFill) -> drawingObject",
        "body": "hs.drawing:setFill(${1:doFill})",
        "description": "Sets whether or not to fill a drawing object\n\nParameters:\n * doFill - A boolean, true to fill the drawing object, false to not fill\n\nReturns:\n * The drawing object\n\nNotes:\n * This method should only be used on line, rectangle, circle, or arc drawing objects"
    },
    "Sets the fill color of a drawing object": {
        "prefix": "hs.drawing:setFillColor(color) -> drawingObject",
        "body": "hs.drawing:setFillColor(${1:color})",
        "description": "Sets the fill color of a drawing object\n\nParameters:\n * color - a color table as described in `hs.drawing.color`\n\nReturns:\n * The drawing object\n\nNotes:\n * This method should only be used on rectangle, circle, or arc drawing objects\n * Calling this method will remove any gradient fill colors previously set with `hs.drawing:setFillGradient()`"
    },
    "Sets the fill gradient of a drawing object": {
        "prefix": "hs.drawing:setFillGradient(startColor, endColor, angle) -> drawingObject",
        "body": "hs.drawing:setFillGradient(${1:startColor}, ${2:endColor}, ${3:angle})",
        "description": "Sets the fill gradient of a drawing object\n\nParameters:\n * startColor - A table containing color component values between 0.0 and 1.0 for each of the keys:\n   * red (default 0.0)\n   * green (default 0.0)\n   * blue (default 0.0)\n   * alpha (default 1.0)\n * endColor - A table containing color component values between 0.0 and 1.0 for each of the keys:\n   * red (default 0.0)\n   * green (default 0.0)\n   * blue (default 0.0)\n   * alpha (default 1.0)\n * angle - A number representing the angle of the gradient, measured in degrees, counter-clockwise, from the left of the drawing object\n\nReturns:\n * The drawing object\n\nNotes:\n * This method should only be used on rectangle, circle, or arc drawing objects\n * Calling this method will remove any fill color previously set with `hs.drawing:setFillColor()`"
    },
    "Sets the frame of the drawingObject in absolute coordinates": {
        "prefix": "hs.drawing:setFrame(rect) -> drawingObject",
        "body": "hs.drawing:setFrame(${1:rect})",
        "description": "Sets the frame of the drawingObject in absolute coordinates\n\nParameters:\n * rect - A rect-table containing the co-ordinates and size that should be applied to the drawingObject\n\nReturns:\n * The drawing object"
    },
    "Sets the image of a drawing object": {
        "prefix": "hs.drawing:setImage(image) -> drawingObject",
        "body": "hs.drawing:setImage(${1:image})",
        "description": "Sets the image of a drawing object\n\nParameters:\n * image - An `hs.image` object\n\nReturns:\n * The drawing object"
    },
    "Sets the image of a drawing object from an ASCII representation": {
        "prefix": "hs.drawing:setImageASCII(ascii) -> drawingObject",
        "body": "hs.drawing:setImageASCII(${1:ascii})",
        "description": "Sets the image of a drawing object from an ASCII representation\n\nParameters:\n * ascii - A string containing the ASCII image to render\n\nReturns:\n * The drawing object\n\nNotes:\n * To use the ASCII diagram image support, see http://cocoamine.net/blog/2015/03/20/replacing-photoshop-with-nsstring"
    },
    "Sets the image path of a drawing object": {
        "prefix": "hs.drawing:setImageFromPath(imagePath) -> drawingObject",
        "body": "hs.drawing:setImageFromPath(${1:imagePath})",
        "description": "Sets the image path of a drawing object\n\nParameters:\n * imagePath - A string containing the path to an image file\n\nReturns:\n * The drawing object\n\nNotes:\n * This method should only be used on an image drawing object\n * Paths relative to the PWD of Hammerspoon (typically ~/.hammerspoon/) will work, but paths relative to the UNIX homedir character, `~` will not\n * Animated GIFs are supported. They're not super friendly on your CPU, but they work"
    },
    "Sets the radii of the corners of a rectangle drawing object": {
        "prefix": "hs.drawing:setRoundedRectRadii(xradius, yradius) -> drawingObject",
        "body": "hs.drawing:setRoundedRectRadii(${1:xradius}, ${2:yradius})",
        "description": "Sets the radii of the corners of a rectangle drawing object\n\nParameters:\n * xradius - A number containing the radius of each corner along the x-axis\n * yradius - A number containing the radius of each corner along the y-axis\n\nReturns:\n * The drawing object\n\nNotes:\n * This method should only be used on rectangle drawing objects\n * If either radius value is greater than half the width/height (as appropriate) of the rectangle, the value will be clamped at half the width/height\n * If either (or both) radius values are 0, the rectangle will be drawn without rounded corners"
    },
    "Resizes a drawing object": {
        "prefix": "hs.drawing:setSize(size) -> drawingObject",
        "body": "hs.drawing:setSize(${1:size})",
        "description": "Resizes a drawing object\n\nParameters:\n * size - A size-table containing the width and height the drawing object should be resized to\n\nReturns:\n * The drawing object\n\nNotes:\n * If this is called on an `hs.drawing.text` object, only its window will be resized. If you also want to change the font size, use `:setTextSize()`"
    },
    "Sets whether or not to stroke a drawing object": {
        "prefix": "hs.drawing:setStroke(doStroke) -> drawingObject",
        "body": "hs.drawing:setStroke(${1:doStroke})",
        "description": "Sets whether or not to stroke a drawing object\n\nParameters:\n * doStroke - A boolean, true to stroke the drawing object, false to not stroke\n\nReturns:\n * The drawing object\n\nNotes:\n * This method should only be used on line, rectangle, circle, or arc drawing objects"
    },
    "Sets the stroke color of a drawing object": {
        "prefix": "hs.drawing:setStrokeColor(color) -> drawingObject",
        "body": "hs.drawing:setStrokeColor(${1:color})",
        "description": "Sets the stroke color of a drawing object\n\nParameters:\n * color - a color table as described in `hs.drawing.color`\n\nReturns:\n * The drawing object\n\nNotes:\n * This method should only be used on line, rectangle, circle, or arc drawing objects"
    },
    "Sets the stroke width of a drawing object": {
        "prefix": "hs.drawing:setStrokeWidth(width) -> drawingObject",
        "body": "hs.drawing:setStrokeWidth(${1:width})",
        "description": "Sets the stroke width of a drawing object\n\nParameters:\n * width - A number containing the width in points to stroke a drawing object\n\nReturns:\n * The drawing object\n\nNotes:\n * This method should only be used on line, rectangle, circle, or arc drawing objects"
    },
    "Sets the text of a drawing object from an `hs.styledtext` object": {
        "prefix": "hs.drawing:setStyledText(message) -> drawingObject",
        "body": "hs.drawing:setStyledText(${1:message})",
        "description": "Sets the text of a drawing object from an `hs.styledtext` object\n\nParameters:\n * message - Any of the types supported by `hs.styledtext`.  See `hs.styledtext` for more details.\n\nReturns:\n * The drawing object\n\nNotes:\n * This method should only be used on text drawing objects"
    },
    "Sets the text of a drawing object": {
        "prefix": "hs.drawing:setText(message) -> drawingObject",
        "body": "hs.drawing:setText(${1:message})",
        "description": "Sets the text of a drawing object\n\nParameters:\n * message - A string containing the text to display\n\nReturns:\n * The drawing object\n\nNotes:\n * This method should only be used on text drawing objects\n * If the text of the drawing object is emptied (i.e. \"\") then style changes may be lost.  Use a placeholder such as a space (\" \") or hide the object if style changes need to be saved but the text should disappear for a while."
    },
    "Sets the default text color for a drawing object": {
        "prefix": "hs.drawing:setTextColor(color) -> drawingObject",
        "body": "hs.drawing:setTextColor(${1:color})",
        "description": "Sets the default text color for a drawing object\n\nParameters:\n * color - a color table as described in `hs.drawing.color`\n\nReturns:\n * The drawing object\n\nNotes:\n * This method should only be called on text drawing objects\n * This method changes the font color for portions of an `hs.drawing` text object which do not have a specific font set in their attributes list (see `hs.styledtext` for more details)."
    },
    "Sets the default font for a drawing object": {
        "prefix": "hs.drawing:setTextFont(fontname) -> drawingObject",
        "body": "hs.drawing:setTextFont(${1:fontname})",
        "description": "Sets the default font for a drawing object\n\nParameters:\n * fontname - A string containing the name of the font to use\n\nReturns:\n * The drawing object\n\nNotes:\n * This method should only be used on text drawing objects\n * This method changes the font for portions of an `hs.drawing` text object which do not have a specific font set in their attributes list (see `hs.styledtext` for more details)."
    },
    "Sets the default text size for a drawing object": {
        "prefix": "hs.drawing:setTextSize(size) -> drawingObject",
        "body": "hs.drawing:setTextSize(${1:size})",
        "description": "Sets the default text size for a drawing object\n\nParameters:\n * size - A number containing the font size to use\n\nReturns:\n * The drawing object\n\nNotes:\n * This method should only be used on text drawing objects\n * This method changes the font size for portions of an `hs.drawing` text object which do not have a specific font set in their attributes list (see `hs.styledtext` for more details)."
    },
    "Sets some simple style parameters for the entire text of a drawing object.  For more control over style including having multiple styles within a single text object, use `hs.styledtext` and `hs.drawing:setStyledText` instead.": {
        "prefix": "hs.drawing:setTextStyle([textStyle]) -> drawingObject",
        "body": "hs.drawing:setTextStyle(${1:[textStyle]})",
        "description": "Sets some simple style parameters for the entire text of a drawing object.  For more control over style including having multiple styles within a single text object, use `hs.styledtext` and `hs.drawing:setStyledText` instead.\n\nParameters:\n * textStyle - an optional table containing one or more of the following keys to set for the text of the drawing object (if the table is nil or left out, the style is reset to the `hs.drawing` defaults):\n   * font      - the name of the font to use (default: the system font)\n   * size      - the font point size to use (default: 27.0)\n   * color     - a color table as described in `hs.drawing.color`\n   * alignment - a string of one of the following indicating the texts alignment within the drawing objects frame:\n     * \"left\"      - the text is visually left aligned.\n     * \"right\"     - the text is visually right aligned.\n     * \"center\"    - the text is visually center aligned.\n     * \"justified\" - the text is justified\n     * \"natural\"   - (default) the natural alignment of the text\u2019s script\n   * lineBreak - a string of one of the following indicating how to wrap text which exceeds the drawing object's frame:\n     * \"wordWrap\"       - (default) wrap at word boundaries, unless the word itself doesn\u2019t fit on a single line\n     * \"charWrap\"       - wrap before the first character that doesn\u2019t fit\n     * \"clip\"           - do not draw past the edge of the drawing object frame\n     * \"truncateHead\"   - the line is displayed so that the end fits in the frame and the missing text at the beginning of the line is indicated by an ellipsis\n     * \"truncateTail\"   - the line is displayed so that the beginning fits in the frame and the missing text at the end of the line is indicated by an ellipsis\n     * \"truncateMiddle\" - the line is displayed so that the beginning and end fit in the frame and the missing text in the middle is indicated by an ellipsis\n\nReturns:\n * The drawing object\n\nNotes:\n * This method should only be used on text drawing objects\n * If the text of the drawing object is currently empty (i.e. \"\") then style changes may be lost.  Use a placeholder such as a space (\" \") or hide the object if style changes need to be saved but the text should disappear for a while.\n * Only the keys specified are changed.  To reset an object to all of its defaults, call this method with an explicit nil as its only parameter (e.g. `hs.drawing:setTextStyle(nil)`\n * The font, font size, and font color can also be set by their individual specific methods as well; this method is provided so that style components can be stored and applied collectively, as well as used by `hs.drawing.getTextDrawingSize()` to determine the proper rectangle size for a textual drawing object."
    },
    "Moves the drawingObject to a given point": {
        "prefix": "hs.drawing:setTopLeft(point) -> drawingObject",
        "body": "hs.drawing:setTopLeft(${1:point})",
        "description": "Moves the drawingObject to a given point\n\nParameters:\n * point - A point-table containing the absolute co-ordinates the drawing object should be moved to\n\nReturns:\n * The drawing object"
    },
    "Displays the drawing object": {
        "prefix": "hs.drawing:show([fadeInTime]) -> drawingObject",
        "body": "hs.drawing:show(${1:[fadeInTime]})",
        "description": "Displays the drawing object\n\nParameters:\n * fadeInTime - An optional number of seconds over which to fade in the drawing object. Defaults to zero\n\nReturns:\n * The drawing object"
    },
    "Creates a new text object": {
        "prefix": "hs.drawing.text(sizeRect, message) -> drawingObject or nil",
        "body": "hs.drawing.text(${1:sizeRect}, ${2:message})",
        "description": "Creates a new text object\n\nParameters:\n * sizeRect - A rect-table containing the location/size of the text\n * message - A string containing the text to be displayed.   May also be any of the types supported by `hs.styledtext`.  See `hs.styledtext` for more details.\n\nReturns:\n * An `hs.drawing` object, or nil if an error occurs"
    },
    "Array of window behavior labels for determining how an hs.drawing object is handled in Spaces and Expos\u00e9": {
        "prefix": "hs.drawing.windowBehaviors[]",
        "body": "hs.drawing.windowBehaviors",
        "description": "Array of window behavior labels for determining how an hs.drawing object is handled in Spaces and Expos\u00e9\n\n* default           -- The window can be associated to one space at a time.\n* canJoinAllSpaces  -- The window appears in all spaces. The menu bar behaves this way.\n* moveToActiveSpace -- Making the window active does not cause a space switch; the window switches to the active space.\n\nOnly one of these may be active at a time:\n\n* managed           -- The window participates in Spaces and Expos\u00e9. This is the default behavior if windowLevel is equal to NSNormalWindowLevel.\n* transient         -- The window floats in Spaces and is hidden by Expos\u00e9. This is the default behavior if windowLevel is not equal to NSNormalWindowLevel.\n* stationary        -- The window is unaffected by Expos\u00e9; it stays visible and stationary, like the desktop window.\n\nNotes:\n * This table has a __tostring() metamethod which allows listing it's contents in the Hammerspoon console by typing `hs.drawing.windowBehaviors`."
    },
    "A table of predefined window levels usable with `hs.drawing:setLevel(...)`": {
        "prefix": "hs.drawing.windowLevels",
        "body": "hs.drawing.windowLevels",
        "description": "A table of predefined window levels usable with `hs.drawing:setLevel(...)`\n\nPredefined levels are:\n * _MinimumWindowLevelKey - lowest allowed window level\n * desktop\n * desktopIcon            - `hs.drawing:sendToBack()` is equivalent to this - 1\n * normal                 - normal application windows\n * tornOffMenu\n * floating               - equivalent to `hs.drawing:bringToFront(false)`, where \"Always Keep On Top\" windows are usually set\n * modalPanel             - modal alert dialog\n * utility\n * dock                   - level of the Dock\n * mainMenu               - level of the Menubar\n * status\n * popUpMenu              - level of a menu when displayed (open)\n * overlay\n * help\n * dragging\n * screenSaver            - equivalent to `hs.drawing:bringToFront(true)`\n * assistiveTechHigh\n * cursor\n * _MaximumWindowLevelKey - highest allowed window level\n\nNotes:\n * This table has a __tostring() metamethod which allows listing it's contents in the Hammerspoon console by typing `hs.drawing.windowLevels`.\n * These key names map to the constants used in CoreGraphics to specify window levels and may not actually be used for what the name might suggest. For example, tests suggest that an active screen saver actually runs at a level of 2002, rather than at 1000, which is the window level corresponding to kCGScreenSaverWindowLevelKey.\n * Each drawing level is sorted separately and `hs.drawing:orderAbove(...)` and hs.drawing:orderBelow(...)` only arrange windows within the same level.\n * If you use Dock hiding (or in 10.11, Menubar hiding) please note that when the Dock (or Menubar) is popped up, it is done so with an implicit orderAbove, which will place it above any items you may also draw at the Dock (or MainMenu) level.\n\n * A drawing object with a [hs.drawing:setClickCallback](#setClickCallback) function can only reliably receive mouse click events when its window level is at `hs.drawing.windowLevels.desktopIcon` + 1 or higher."
    },
    "A collection of colors representing the ANSI Terminal color sequences.  The color definitions are based upon code found at https://github.com/balthamos/geektool-3 in the /NerdTool/classes/ANSIEscapeHelper.m file.": {
        "prefix": "hs.drawing.color.ansiTerminalColors",
        "body": "hs.drawing.color.ansiTerminalColors",
        "description": "A collection of colors representing the ANSI Terminal color sequences.  The color definitions are based upon code found at https://github.com/balthamos/geektool-3 in the /NerdTool/classes/ANSIEscapeHelper.m file.\n\nNotes:\n * This is not a constant, so you can adjust the colors at run time for your installation if desired."
    },
    "Returns a table containing the HSB representation of the specified color.": {
        "prefix": "hs.drawing.color.asHSB(color) -> table | string",
        "body": "hs.drawing.${1:color}.asHSB(color)",
        "description": "Returns a table containing the HSB representation of the specified color.\n\nParameters:\n * color - a table specifying a color as described in the module definition (see `hs.drawing.color` in the online help or Dash documentation)\n\nReturns:\n * a table containing the hue, saturation, brightness, and alpha keys representing the specified color as HSB or a string describing the color's colorspace if conversion is not possible.\n\nNotes:\n * See also `hs.drawing.color.asRGB`"
    },
    "Returns a table containing the RGB representation of the specified color.": {
        "prefix": "hs.drawing.color.asRGB(color) -> table | string",
        "body": "hs.drawing.${1:color}.asRGB(color)",
        "description": "Returns a table containing the RGB representation of the specified color.\n\nParameters:\n * color - a table specifying a color as described in the module definition (see `hs.drawing.color` in the online help or Dash documentation)\n\nReturns:\n * a table containing the red, blue, green, and alpha keys representing the specified color as RGB or a string describing the color's colorspace if conversion is not possible.\n\nNotes:\n * See also `hs.drawing.color.asHSB`"
    },
    "Returns a table containing the colors for the specified system color list or hs.drawing.color collection.": {
        "prefix": "hs.drawing.color.colorsFor(list) -> table",
        "body": "hs.drawing.color.colorsFor(${1:list})",
        "description": "Returns a table containing the colors for the specified system color list or hs.drawing.color collection.\n\nParameters:\n * list - the name of the list to provide colors for\n\nReturns:\n * a table whose keys are made from the colors provided by the color list or nil if the list does not exist.\n\nNotes:\n * Where possible, each color node is provided as its RGB color representation.  Where this is not possible, the color node contains the keys `list` and `name` which identify the indicated color.  This means that you can use the following wherever a color parameter is expected: `hs.drawing.color.colorsFor(list)[\"color-name\"]`\n * This function provides a tostring metatable method which allows listing the defined colors in the list in the Hammerspoon console with: `hs.drawing.colorsFor(list)`\n * See also `hs.drawing.color.lists`"
    },
    "This table contains this list of defined color collections provided by the `hs.drawing.color` module.  Collections differ from the system color lists in that you can modify the color values their members contain by modifying the table at `hs.drawing.color.<collection>.<color>` and future references to that color will reflect the new changes, thus allowing you to customize the palettes for your installation.": {
        "prefix": "hs.drawing.color.definedCollections",
        "body": "hs.drawing.color.definedCollections",
        "description": "This table contains this list of defined color collections provided by the `hs.drawing.color` module.  Collections differ from the system color lists in that you can modify the color values their members contain by modifying the table at `hs.drawing.color.<collection>.<color>` and future references to that color will reflect the new changes, thus allowing you to customize the palettes for your installation.\n\nNotes:\n * This list is a constant, but the members it refers to are not."
    },
    "This table contains a collection of various useful pre-defined colors:": {
        "prefix": "hs.drawing.color.hammerspoon",
        "body": "hs.drawing.color.hammerspoon",
        "description": "This table contains a collection of various useful pre-defined colors:\n * osx_red - The same red used for OS X window close buttons\n * osx_green - The same green used for OS X window zoom buttons\n * osx_yellow - The same yellow used for OS X window minimize buttons\n\nNotes:\n * This is not a constant, so you can adjust the colors at run time for your installation if desired.\n\n * Previous versions of Hammerspoon included these colors at the `hs.drawing.color` path; for backwards compatibility, the keys of this table are replicated at that path as long as they do not conflict with any other color collection or function within the `hs.drawing.color` module.  You really should adjust your code to use the collection, as this may change in the future."
    },
    "Returns a table containing the system color lists and hs.drawing.color collections with their defined colors.": {
        "prefix": "hs.drawing.color.lists() -> table",
        "body": "hs.drawing.color.lists()",
        "description": "Returns a table containing the system color lists and hs.drawing.color collections with their defined colors.\n\nParameters:\n * None\n\nReturns:\n * a table whose keys are made from the currently defined system color lists and hs.drawing.color collections.  Each color list key refers to a table whose keys make up the colors provided by the specific color list.\n\nNotes:\n * Where possible, each color node is provided as its RGB color representation.  Where this is not possible, the color node contains the keys `list` and `name` which identify the indicated color.  This means that you can use the following wherever a color parameter is expected: `hs.drawing.color.lists()[\"list-name\"][\"color-name\"]`\n * This function provides a tostring metatable method which allows listing the defined color lists in the Hammerspoon console with: `hs.drawing.color.lists()`\n * See also `hs.drawing.color.colorsFor`"
    },
    "A collection of colors representing the X11 color names as defined at  https://en.wikipedia.org/wiki/Web_colors#X11_color_names (names in lowercase)": {
        "prefix": "hs.drawing.color.x11",
        "body": "hs.drawing.color.x11",
        "description": "A collection of colors representing the X11 color names as defined at  https://en.wikipedia.org/wiki/Web_colors#X11_color_names (names in lowercase)\n\nNotes:\n * This is not a constant, so you can adjust the colors at run time for your installation if desired."
    },
    "Returns a table containing the current key modifiers being pressed or in effect *at this instant* for the keyboard most recently used.": {
        "prefix": "hs.eventtap.checkKeyboardModifiers([raw]) -> table",
        "body": "hs.eventtap.checkKeyboardModifiers(${1:[raw]})",
        "description": "Returns a table containing the current key modifiers being pressed or in effect *at this instant* for the keyboard most recently used.\n\nParameters:\n * raw - an optional boolean value which, if true, includes the _raw key containing the numeric representation of all of the keyboard/modifier flags.\n\nReturns:\n * Returns a table containing boolean values indicating which keyboard modifiers were held down when the function was invoked; The possible keys are:\n    * cmd (or \u2318)\n    * alt (or \u2325)\n    * shift (or \u21e7)\n    * ctrl (or \u2303)\n    * capslock\n    * fn\n  and optionally\n    * _raw - a numeric representation of the numeric representation of all of the keyboard/modifier flags.\n\nNotes:\n * This is an instantaneous poll of the current keyboard modifiers for the most recently used keyboard, not a callback.  This is useful primarily in conjuction with other modules, such as `hs.menubar`, when a callback is already in progress or waiting for an event callback is not practical or possible.\n * the numeric value returned is useful if you need to detect device dependent flags or flags which we normally ignore because they are not present (or are accessible another way) on most keyboards."
    },
    "Returns a table containing the current mouse buttons being pressed *at this instant*.": {
        "prefix": "hs.mouse.getButtons() -> table",
        "body": "hs.mouse.getButtons()",
        "description": "Returns a table containing the current mouse buttons being pressed *at this instant*.\n\nParameters:\n None\n\nReturns:\n * Returns an array containing indicies starting from 1 up to the highest numbered button currently being pressed where the index is `true` if the button is currently pressed or `false` if it is not.\n * Special hash tag synonyms for `left` (button 1), `right` (button 2), and `middle` (button 3) are also set to true if these buttons are currently being pressed.\n\nNotes:\n * This function is a wrapper to `hs.eventtap.checkMouseButtons`\n * This is an instantaneous poll of the current mouse buttons, not a callback."
    },
    "Returns the system-wide setting for the delay between two clicks, to register a double click event": {
        "prefix": "hs.eventtap.doubleClickInterval() -> number",
        "body": "hs.eventtap.doubleClickInterval()",
        "description": "Returns the system-wide setting for the delay between two clicks, to register a double click event\n\nParameters:\n * None\n\nReturns:\n * A number containing the maximum number of seconds between two mouse click events, for a double click event to be registered"
    },
    "Determine whether or not an event tap object is enabled.": {
        "prefix": "hs.eventtap:isEnabled() -> bool",
        "body": "hs.eventtap:isEnabled()",
        "description": "Determine whether or not an event tap object is enabled.\n\nParameters:\n * None\n\nReturns:\n * True if the event tap is enabled or false if it is not."
    },
    "Checks if macOS is preventing keyboard events from being sent to event taps": {
        "prefix": "hs.eventtap.isSecureInputEnabled() -> boolean",
        "body": "hs.eventtap.isSecureInputEnabled()",
        "description": "Checks if macOS is preventing keyboard events from being sent to event taps\n\nParameters:\n * None\n\nReturns:\n * A boolean, true if secure input is enabled, otherwise false\n\nNotes:\n * If secure input is enabled, Hammerspoon is not able to intercept keyboard events\n * Secure input is enabled generally only in situations where an password field is focused in a web browser, system dialog or terminal"
    },
    "Returns the system-wide setting for the delay before keyboard repeat events begin": {
        "prefix": "hs.eventtap.keyRepeatDelay() -> number",
        "body": "hs.eventtap.keyRepeatDelay()",
        "description": "Returns the system-wide setting for the delay before keyboard repeat events begin\n\nParameters:\n * None\n\nReturns:\n * A number containing the number of seconds before repeat events begin, after a key is held down"
    },
    "Returns the system-wide setting for the interval between repeated keyboard events": {
        "prefix": "hs.eventtap.keyRepeatInterval() -> number",
        "body": "hs.eventtap.keyRepeatInterval()",
        "description": "Returns the system-wide setting for the interval between repeated keyboard events\n\nParameters:\n * None\n\nReturns:\n * A number containing the number of seconds between keyboard events, if a key is held down"
    },
    "Generates and emits a single keystroke event pair for the supplied keyboard modifiers and character": {
        "prefix": "hs.eventtap.keyStroke(modifiers, character[, delay, application])",
        "body": "hs.eventtap.keyStroke(${1:modifiers}, ${2:character[}, ${3:delay}, ${4:application]})",
        "description": "Generates and emits a single keystroke event pair for the supplied keyboard modifiers and character\n\nParameters:\n * modifiers - A table containing the keyboard modifiers to apply (\"fn\", \"ctrl\", \"alt\", \"cmd\", \"shift\", or their Unicode equivalents)\n * character - A string containing a character to be emitted\n * delay - An optional delay (in microseconds) between key down and up event. Defaults to 200000 (i.e. 200ms)\n * application - An optional hs.application object to send the keystroke to\n\nReturns:\n * None\n\nNotes:\n * This function is ideal for sending single keystrokes with a modifier applied (e.g. sending \u2318-v to paste, with `hs.eventtap.keyStroke({\"cmd\"}, \"v\")`). If you want to emit multiple keystrokes for typing strings of text, see `hs.eventtap.keyStrokes()`\n\n * Note that invoking this function with a table (empty or otherwise) for the `modifiers` argument will force the release of any modifier keys which have been explicitly created by [hs.eventtap.event.newKeyEvent](#newKeyEvent) and posted that are still in the \"down\" state. An explicit `nil` for this argument will not (i.e. the keystroke will inherit any currently \"down\" modifiers)"
    },
    "Generates and emits keystroke events for the supplied text": {
        "prefix": "hs.eventtap.keyStrokes(text[, application])",
        "body": "hs.eventtap.keyStrokes(${1:text[}, ${2:application]})",
        "description": "Generates and emits keystroke events for the supplied text\n\nParameters:\n * text - A string containing the text to be typed\n * application - An optional hs.application object to send the keystrokes to\n\nReturns:\n * None\n\nNotes:\n * If you want to send a single keystroke with keyboard modifiers (e.g. sending \u2318-v to paste), see `hs.eventtap.keyStroke()`"
    },
    "Generates a left mouse click event at the specified point": {
        "prefix": "hs.eventtap.leftClick(point[, delay])",
        "body": "hs.eventtap.leftClick(${1:point[}, ${2:delay]})",
        "description": "Generates a left mouse click event at the specified point\n\nParameters:\n * point - A table with keys `{x, y}` indicating the location where the mouse event should occur\n * delay - An optional delay (in microseconds) between mouse down and up event. Defaults to 200000 (i.e. 200ms)\n\nReturns:\n * None\n\nNotes:\n * This is a wrapper around `hs.eventtap.event.newMouseEvent` that sends `leftmousedown` and `leftmouseup` events)"
    },
    "Generates a middle mouse click event at the specified point": {
        "prefix": "hs.eventtap.middleClick(point[, delay])",
        "body": "hs.eventtap.middleClick(${1:point[}, ${2:delay]})",
        "description": "Generates a middle mouse click event at the specified point\n\nParameters:\n * point  - A table with keys `{x, y}` indicating the location where the mouse event should occur\n * delay  - An optional delay (in microseconds) between mouse down and up event. Defaults to 200000 (i.e. 200ms)\n\nReturns:\n * None\n\nNotes:\n * This function is just a wrapper which calls `hs.eventtap.otherClick(point, delay, 2)` and is included solely for backwards compatibility."
    },
    "Create a new event tap object": {
        "prefix": "hs.eventtap.new(types, fn) -> eventtap",
        "body": "hs.eventtap.new(${1:types}, ${2:fn})",
        "description": "Create a new event tap object\n\nParameters:\n * types - A table that should contain values from `hs.eventtap.event.types`\n * fn - A function that will be called when the specified event types occur. The function should take a single parameter, which will be an event object. It can optionally return two values. Firstly, a boolean, true if the event should be deleted, false if it should propagate to any other applications watching for that event. Secondly, a table of events to post.\n\nReturns:\n * An event tap object\n\nNotes:\n * If you specify the argument `types` as the special table {\"all\"[, events to ignore]}, then *all* events (except those you optionally list *after* the \"all\" string) will trigger a callback, even events which are not defined in the [Quartz Event Reference](https://developer.apple.com/library/mac/documentation/Carbon/Reference/QuartzEventServicesRef/Reference/reference.html)."
    },
    "Generates an \"other\" mouse click event at the specified point": {
        "prefix": "hs.eventtap.otherClick(point[, delay][, button])",
        "body": "hs.eventtap.otherClick(${1:point[}, ${2:delay][}, ${3:button]})",
        "description": "Generates an \"other\" mouse click event at the specified point\n\nParameters:\n * point  - A table with keys `{x, y}` indicating the location where the mouse event should occur\n * delay  - An optional delay (in microseconds) between mouse down and up event. Defaults to 200000 (i.e. 200ms)\n * button - An optional integer, default 2, between 2 and 31 specifying the button number to be pressed.  If this parameter is specified then `delay` must also be specified, though you may specify it as `nil` to use the default.\n\nReturns:\n * None\n\nNotes:\n * This is a wrapper around `hs.eventtap.event.newMouseEvent` that sends `otherMouseDown` and `otherMouseUp` events)\n\n * macOS recognizes up to 32 distinct mouse buttons, though few mouse devices have more than 3.  The left mouse button corresponds to button number 0 and the right mouse button corresponds to 1;  distinct events are used for these mouse buttons, so you should use `hs.eventtap.leftClick` and `hs.eventtap.rightClick` respectively.  All other mouse buttons are coalesced into the `otherMouse` events and are distinguished by specifying the specific button with the `mouseEventButtonNumber` property, which this function does for you.\n * The specific purpose of mouse buttons greater than 2 varies by hardware and application (typically they are not present on a mouse and have no effect in an application)"
    },
    "Generates a right mouse click event at the specified point": {
        "prefix": "hs.eventtap.rightClick(point[, delay])",
        "body": "hs.eventtap.rightClick(${1:point[}, ${2:delay]})",
        "description": "Generates a right mouse click event at the specified point\n\nParameters:\n * point - A table with keys `{x, y}` indicating the location where the mouse event should occur\n * delay - An optional delay (in microseconds) between mouse down and up event. Defaults to 200000 (i.e. 200ms)\n\nReturns:\n * None\n\nNotes:\n * This is a wrapper around `hs.eventtap.event.newMouseEvent` that sends `rightmousedown` and `rightmouseup` events)"
    },
    "Generates and emits a scroll wheel event": {
        "prefix": "hs.eventtap.scrollWheel(offsets, modifiers, unit) -> event",
        "body": "hs.eventtap.scrollWheel(${1:offsets}, ${2:modifiers}, ${3:unit})",
        "description": "Generates and emits a scroll wheel event\n\nParameters:\n * offsets - A table containing the {horizontal, vertical} amount to scroll. Positive values scroll up or left, negative values scroll down or right.\n * mods - A table containing zero or more of the following:\n  * cmd\n  * alt\n  * shift\n  * ctrl\n  * fn\n * unit - An optional string containing the name of the unit for scrolling. Either \"line\" (the default) or \"pixel\"\n\nReturns:\n * None"
    },
    "Starts an event tap": {
        "prefix": "hs.eventtap:start()",
        "body": "hs.eventtap:start()",
        "description": "Starts an event tap\n\nParameters:\n * None\n\nReturns:\n * The event tap object"
    },
    "Stops an event tap": {
        "prefix": "hs.eventtap:stop()",
        "body": "hs.eventtap:stop()",
        "description": "Stops an event tap\n\nParameters:\n * None\n\nReturns:\n * The event tap object"
    },
    "Returns a string containing binary data representing the event.  This can be used to record events for later use.": {
        "prefix": "hs.eventtap.event:asData() -> string",
        "body": "hs.eventtap.event:asData()",
        "description": "Returns a string containing binary data representing the event.  This can be used to record events for later use.\n\nParameters:\n * None\n\nReturns:\n * a string representing the event or nil if the event cannot be represented as a string\n\nNotes:\n * You can recreate the event for later posting with [hs.eventtap.event.newEventFromData](#newEventFromData)"
    },
    "Duplicates an `hs.eventtap.event` event for further modification or injection": {
        "prefix": "hs.eventtap.event:copy() -> event",
        "body": "hs.eventtap.event:copy()",
        "description": "Duplicates an `hs.eventtap.event` event for further modification or injection\n\nParameters:\n * None\n\nReturns:\n * A new `hs.eventtap.event` object"
    },
    "Gets the state of a mouse button in the event": {
        "prefix": "hs.eventtap.event:getButtonState(button) -> bool",
        "body": "hs.eventtap.event:getButtonState(${1:button})",
        "description": "Gets the state of a mouse button in the event\n\nParameters:\n * button - A number between 0 and 31. The left mouse button is 0, the right mouse button is 1 and the middle mouse button is 2. The meaning of the remaining buttons varies by hardware, and their functionality varies by application (typically they are not present on a mouse and have no effect in an application)\n\nReturns:\n * A boolean, true if the specified mouse button is to be clicked by the event\n\nNotes:\n * This method should only be called on mouse events"
    },
    "Returns the Unicode character, if any, represented by a keyDown or keyUp event.": {
        "prefix": "hs.eventtap.event:getCharacters([clean]) -> string or nil",
        "body": "hs.eventtap.event:getCharacters(${1:[clean]})",
        "description": "Returns the Unicode character, if any, represented by a keyDown or keyUp event.\n\nParameters:\n * clean -- an optional parameter, default `false`, which indicates if key modifiers, other than Shift, should be stripped from the keypress before converting to Unicode.\n\nReturns:\n * A string containing the Unicode character represented by the keyDown or keyUp event, or nil if the event is not a keyUp or keyDown.\n\nNotes:\n * This method should only be used on keyboard events\n * If `clean` is true, all modifiers except for Shift are stripped from the character before converting to the Unicode character represented by the keypress.\n * If the keypress does not correspond to a valid Unicode character, an empty string is returned (e.g. if `clean` is false, then Opt-E will return an empty string, while Opt-Shift-E will return an accent mark)."
    },
    "Gets the keyboard modifiers of an event": {
        "prefix": "hs.eventtap.event:getFlags() -> table",
        "body": "hs.eventtap.event:getFlags()",
        "description": "Gets the keyboard modifiers of an event\n\nParameters:\n * None\n\nReturns:\n * A table containing the keyboard modifiers that present in the event - i.e. zero or more of the following keys, each with a value of `true`:\n  * cmd\n  * alt\n  * shift\n  * ctrl\n  * fn\n * The table responds to the following methods:\n  * contain(mods) -> boolean\n   * Returns true if the modifiers contain all of given modifiers\n  * containExactly(mods) -> boolean\n   * Returns true if the modifiers contain all of given modifiers exactly and nothing else\n * Parameter mods is a table containing zero or more of the following:\n  * cmd or \u2318\n  * alt or \u2325\n  * shift or \u21e7\n  * ctrl or \u2303\n  * fn"
    },
    "Gets the raw keycode for the event": {
        "prefix": "hs.eventtap.event:getKeyCode() -> keycode",
        "body": "hs.eventtap.event:getKeyCode()",
        "description": "Gets the raw keycode for the event\n\nParameters:\n * None\n\nReturns:\n * A number containing the raw keycode, taken from `hs.keycodes.map`\n\nNotes:\n * This method should only be used on keyboard events"
    },
    "Gets a property of the event": {
        "prefix": "hs.eventtap.event:getProperty(prop) -> number",
        "body": "hs.eventtap.event:getProperty(${1:prop})",
        "description": "Gets a property of the event\n\nParameters:\n * prop - A value taken from `hs.eventtap.event.properties`\n\nReturns:\n * A number containing the value of the requested property\n\nNotes:\n * The properties are `CGEventField` values, as documented at https://developer.apple.com/library/mac/documentation/Carbon/Reference/QuartzEventServicesRef/index.html#//apple_ref/c/tdef/CGEventField"
    },
    "Returns raw data about the event": {
        "prefix": "hs.eventtap.event:getRawEventData() -> table",
        "body": "hs.eventtap.event:getRawEventData()",
        "description": "Returns raw data about the event\n\nParameters:\n * None\n\nReturns:\n * A table with two keys:\n   * CGEventData -- a table with keys containing CGEvent data about the event.\n   * NSEventData -- a table with keys containing NSEvent data about the event.\n\nNotes:\n * Most of the data in `CGEventData` is already available through other methods, but is presented here without any cleanup or parsing.\n * This method is expected to be used mostly for testing and expanding the range of possibilities available with the hs.eventtap module.  If you find that you are regularly using specific data from this method for common or re-usable purposes, consider submitting a request for adding a more targeted method to hs.eventtap or hs.eventtap.event -- it will likely be more efficient and faster for common tasks, something eventtaps need to be to minimize affecting system responsiveness."
    },
    "Returns a table contining more information about some touch related events.": {
        "prefix": "hs.eventtap.event:getTouchDetails() -> table | nil",
        "body": "hs.eventtap.event:getTouchDetails()",
        "description": "Returns a table contining more information about some touch related events.\n\nParameters:\n * None\n\nReturns:\n * if the event is a touch event (i.e. is an event of type `hs.eventtap.event.types.gesture`), then this method returns a table with zero or more of the following key-value pairs:\n   * if the gesture is for a pressure event:\n     * `pressure`         - a number between 0.0 and 1.0 inclusive indicating the relative amount of pressure applied by the touch; trackpads which are not pressure sensitive will only report the discrete values of 0.0 and 1.0.\n     * `stage`            - an integer between 0 and 2 specifying the stage. 0 represents a touch transitioning to a state too light to be considered a touch, usually at the end of a click; 1 represents a touch with enough pressure to be considered a mouseDown event; 2 represents additional pressure, usually what would trigger a \"deep\" or \"force\" touch.\n     * `stageTransition`  - a number between 0.0 and 1.0. As the pressure increases and transition between stages begins, this will rise from 0.0 to 1.0; as the pressure decreases and a transition between stages begins, this will fall from 0.0 to -1.0. When the pressure is solidly within a specific stage, this will remain 0.0.\n     * `pressureBehavior` - a string specifying the effect or purpose of the pressure. Note that the exact meaning (in terms of haptic feedback or action being performed) of each label is target application or ui element specific. Valid values for this key are:\n       * \"unknown\", \"default\", \"click\", \"generic\", \"accelerator\", \"deepClick\", \"deepDrag\"\n   * if the gesture is for a magnification event:\n     * `magnification` - a number specifying the change in magnification that should be added to the current scaling of an item to achieve the new scale factor.\n   * if the gesture is for a rotation event:\n     * `rotation` - a number specifying in degrees the change in rotation that should be added as specified by this event. Clockwise rotation is indicated by a negative number while counter-clockwise rotation will be positive."
    },
    "Returns a table of details containing information about touches on the trackpad associated with this event if the event is of the type `hs.eventtap.event.types.gesture`.": {
        "prefix": "hs.eventtap.event:getTouches() -> table | nil",
        "body": "hs.eventtap.event:getTouches()",
        "description": "Returns a table of details containing information about touches on the trackpad associated with this event if the event is of the type `hs.eventtap.event.types.gesture`.\n\nParameters:\n * None\n\nReturns:\n * if the event is of the type gesture, returns a table; otherwise returns nil.\n\nNotes:\n * if the event is of the type gesture, the table will contain one or more tables in an array. Each member table of the array will have the following key-value pairs:\n   * `device`                     - a string containing a unique identifier for the device on which the touch occurred. At present we do not have a way to match the identifier to a specific touch device, but if multiple such devices are attached to the computer, this value will differ between them.\n   * `deviceSize`                 - a size table containing keys `h` and `w` for the height and width of the touch device in points (72 PPI resolution).\n   * `force`                      - a number representing a measure of the force of the touch when the device is a forcetouch trackpad. This will be 0.0 for non-forcetouch trackpads and the touchbar.\n   * `identity`                   - a string specifying a unique identifier for the touch guaranteed to be unique for the life of the touch. This identifier may be used to track the movement of a specific touch (e.g. finger) as it moves through successive callbacks.\n   * `phase`                      - a string specifying the current phase the touch is considered to be in. The possible values are: \"began\", \"moved\", \"stationary\", \"ended\", or \"cancelled\".\n   * `resting`                    - Resting touches occur when a user simply rests their thumb on the trackpad device. Requires that the foreground window has views accepting resting touches.\n   * `timestamp`                  - a number representing the time the touch was detected. This number corresponds to seconds since the last system boot, not including time the computer has been asleep. Comparable to `hs.timer.absoluteTime() / 1000000000`.\n   * `touching`                   - a boolean specifying whether or not the touch phase is \"began\", \"moved\", or \"stationary\" (i.e. is *not* \"ended\" or \"cancelled\").\n   * `type`                       - a string specifying the type of touch. A \"direct\" touch will indicate a touchbar, while a trackpad will report \"indirect\".\n\n   * The following fields will be present when the touch is from a touchpad (`type` == \"indirect\")`\n     * `normalizedPosition`         - a point table specifying the `x` and `y` coordinates of the touch, each normalized to be a value between 0.0 and 1.0. `{ x = 0, y = 0 }` is the lower left corner of the touch device.\n     * `previousNormalizedPosition` - a point table specifying the `x` and `y` coordinates of the previous position for this specific touch (as linked by `identity`) normalezed to values between 0.0 and 1.0.\n\n   * The following fields will be present when the touch is from the touchbar (`type` == \"direct\")`\n     * `location`                   - a point table specifying the `x` and `y` coordinates of the touch location within the touchbar.\n     * `previousLocation`           - a point table specifying the `x` and `y` coordinates of the previous location for this specific touch (as linked by `identity`) within the touchbar."
    },
    "Gets the type of the event": {
        "prefix": "hs.eventtap.event:getType([nsSpecificType]) -> number",
        "body": "hs.eventtap.event:getType(${1:[nsSpecificType]})",
        "description": "Gets the type of the event\n\nParameters:\n * `nsSpecificType` - an optional boolean, default false, specifying whether or not a more specific Cocoa NSEvent type should be returned, if available.\n\nReturns:\n * A number containing the type of the event, taken from `hs.eventtap.event.types`\n\nNotes:\n * some newer events are grouped into a more generic event for watching purposes and the specific event type is determined by examining the event through the Cocoa API. The primary example of this is for gestures on a trackpad or touches of the touchbar, as all of these are grouped under the `hs.eventtap.event.types.gesture` event. For example:\n\n     ```lua\n     myTap = hs.eventtap.new( { hs.eventtap.event.types.gesture }, function(e)\n         local gestureType = e:getType(true)\n         if gestureType == hs.eventtap.types.directTouch then\n             -- they touched the touch bar\n         elseif gestureType == hs.eventtap.types.gesture then\n             -- they are touching the trackpad, but it's not for a gesture\n         elseif gestureType == hs.eventtap.types.magnify then\n             -- they're preforming a magnify gesture\n         -- etc -- see hs.eventtap.event.types for more\n         endif\n     end\n     ```"
    },
    "Gets the single unicode character of an event": {
        "prefix": "hs.eventtap.event:getUnicodeString()",
        "body": "hs.eventtap.event:getUnicodeString()",
        "description": "Gets the single unicode character of an event\n\nParameters:\n * None\n\nReturns:\n * A string containing the unicode character"
    },
    "Get or set the current mouse pointer location as defined for the event.": {
        "prefix": "hs.eventtap.event:location([pointTable]) -> event | table",
        "body": "hs.eventtap.event:location(${1:[pointTable]})",
        "description": "Get or set the current mouse pointer location as defined for the event.\n\nParameters:\n * pointTable - an optional point table specifying the x and y coordinates of the mouse pointer location for the event\n\nReturns:\n * if pointTable is provided, returns the `hs.eventtap.event` object; otherwise returns a point table containing x and y key-value pairs specifying the mouse pointer location as specified for this event.\n\nNotes:\n * the use or effect of this method is undefined if the event is not a mouse type event."
    },
    "Creates a blank event.  You will need to set its type with [hs.eventtap.event:setType](#setType)": {
        "prefix": "hs.eventtap.event.newEvent() -> event",
        "body": "hs.eventtap.event.newEvent()",
        "description": "Creates a blank event.  You will need to set its type with [hs.eventtap.event:setType](#setType)\n\nParameters:\n * None\n\nReturns:\n * a new `hs.eventtap.event` object\n\nNotes:\n * this is an empty event that you should set a type for and whatever other properties may be appropriate before posting."
    },
    "Creates an event from the data encoded in the string provided.": {
        "prefix": "hs.eventtap.event.newEventFromData(data) -> event",
        "body": "hs.eventtap.event.newEventFromData(${1:data})",
        "description": "Creates an event from the data encoded in the string provided.\n\nParameters:\n * data - a string containing binary data provided by [hs.eventtap.event:asData](#asData) representing an event.\n\nReturns:\n * a new `hs.eventtap.event` object or nil if the string did not represent a valid event"
    },
    "Creates an gesture event.": {
        "prefix": "hs.eventtap.event.newGesture(gestureType[, gestureValue]) -> event",
        "body": "hs.eventtap.event.newGesture(${1:gestureType[}, ${2:gestureValue]})",
        "description": "Creates an gesture event.\n\nParameters:\n * gestureType - the type of gesture you want to create as a string (see notes below).\n * [gestureValue] - an optional value for the specific gesture (i.e. magnification amount or rotation in degrees).\n\nReturns:\n * a new `hs.eventtap.event` object or `nil` if the `gestureType` is not valid.\n\nNotes:\n * Valid gestureType values are:\n  * `beginMagnify` - Starts a magnification event with an optional magnification value as a number (defaults to 0). The exact unit of measurement is unknown.\n  * `endMagnify` - Starts a magnification event with an optional magnification value as a number (defaults to 0.1). The exact unit of measurement is unknown.\n  * `beginRotate` - Starts a rotation event with an rotation value in degrees (i.e. a value of 45 turns it 45 degrees left - defaults to 0).\n  * `endRotate` - Starts a rotation event with an rotation value in degrees (i.e. a value of 45 turns it 45 degrees left - defaults to 45).\n  * `beginSwipeLeft` - Begin a swipe left.\n  * `endSwipeLeft` - End a swipe left.\n  * `beginSwipeRight` - Begin a swipe right.\n  * `endSwipeRight` - End a swipe right.\n  * `beginSwipeUp` - Begin a swipe up.\n  * `endSwipeUp` - End a swipe up.\n  * `beginSwipeDown` - Begin a swipe down.\n  * `endSwipeDown` - End a swipe down.\n\n * Example Usage:\n  ```lua\n  hs.hotkey.bind({\"cmd\", \"alt\", \"ctrl\"}, \"1\", function()\n      print(\"Magnify slightly\")\n      a = require(\"hs.eventtap.event\").newGesture(\"beginMagnify\", 0)\n      b = require(\"hs.eventtap.event\").newGesture(\"endMagnify\", 0.1)\n      a:post()\n      b:post()\n  end)\n  hs.hotkey.bind({\"cmd\", \"alt\", \"ctrl\"}, \"2\", function()\n      print(\"Swipe down\")\n      a = require(\"hs.eventtap.event\").newGesture(\"beginSwipeDown\")\n      b = require(\"hs.eventtap.event\").newGesture(\"endSwipeDown\")\n      a:post()\n      b:post()\n  end)\n  hs.hotkey.bind({\"cmd\", \"alt\", \"ctrl\"}, \"3\", function()\n      print(\"Rotate 45 degrees left\")\n      a = require(\"hs.eventtap.event\").newGesture(\"beginRotate\", 0)\n      b = require(\"hs.eventtap.event\").newGesture(\"endRotate\", 45)\n      a:post()\n      b:post()\n  end)\n  hs.hotkey.bind({\"cmd\", \"alt\", \"ctrl\"}, \"4\", function()\n      print(\"Rotate 45 degrees right\")\n      a = require(\"hs.eventtap.event\").newGesture(\"beginRotate\", 0)\n      b = require(\"hs.eventtap.event\").newGesture(\"endRotate\", -45)\n      a:post()\n      b:post()\n  end)\n  ```"
    },
    "Creates a keyboard event": {
        "prefix": "hs.eventtap.event.newKeyEvent([mods], key, isdown) -> event",
        "body": "hs.eventtap.event.newKeyEvent(${1:[mods]}, ${2:key}, ${3:isdown})",
        "description": "Creates a keyboard event\n\nParameters:\n * mods - An optional table containing zero or more of the following:\n  * cmd\n  * alt\n  * shift\n  * ctrl\n  * fn\n * key - A string containing the name of a key (see `hs.hotkey` for more information) or an integer specifying the virtual keycode for the key.\n * isdown - A boolean, true if the event should be a key-down, false if it should be a key-up\n\nReturns:\n * An `hs.eventtap.event` object\n\nNotes:\n * The original version of this constructor utilized a shortcut which merged `flagsChanged` and `keyUp`/`keyDown` events into one.  This approach is still supported for backwards compatibility and because it *does* work in most cases.\n * According to Apple Documentation, the proper way to perform a keypress with modifiers is through multiple key events; for example to generate '\u00c5', you should do the following:\n~~~lua\n    hs.eventtap.event.newKeyEvent(hs.keycodes.map.shift, true):post()\n    hs.eventtap.event.newKeyEvent(hs.keycodes.map.alt, true):post()\n    hs.eventtap.event.newKeyEvent(\"a\", true):post()\n    hs.eventtap.event.newKeyEvent(\"a\", false):post()\n    hs.eventtap.event.newKeyEvent(hs.keycodes.map.alt, false):post()\n    hs.eventtap.event.newKeyEvent(hs.keycodes.map.shift, false):post()\n~~~\n * The shortcut method is still supported, though if you run into odd behavior or need to generate `flagsChanged` events without a corresponding `keyUp` or `keyDown`, please check out the syntax demonstrated above.\n~~~lua\n    hs.eventtap.event.newKeyEvent({\"shift\", \"alt\"}, \"a\", true):post()\n    hs.eventtap.event.newKeyEvent({\"shift\", \"alt\"}, \"a\", false):post()\n~~~\n\n* The shortcut approach is still limited to generating only the left version of modifiers."
    },
    "Generates a table containing the keydown and keyup events to generate the keystroke with the specified modifiers.": {
        "prefix": "hs.eventtap.event.newKeyEventSequence(modifiers, character) -> table",
        "body": "hs.eventtap.event.newKeyEventSequence(${1:modifiers}, ${2:character})",
        "description": "Generates a table containing the keydown and keyup events to generate the keystroke with the specified modifiers.\n\nParameters:\n * modifiers - A table containing the keyboard modifiers to apply (\"cmd\", \"alt\", \"shift\", \"ctrl\", \"rightCmd\", \"rightAlt\", \"rightShift\", \"rightCtrl\", or \"fn\")\n * character - A string containing a character to be emitted\n\nReturns:\n * a table with events which contains the individual events that Apple recommends for building up a keystroke combination (see [hs.eventtap.event.newKeyEvent](#newKeyEvents)) in the order that they should be posted (i.e. the first half will contain keyDown events and the second half will contain keyUp events)\n\nNotes:\n * The `modifiers` table must contain the full name of the modifiers you wish used for the keystroke as defined in `hs.keycodes.map` -- the Unicode equivalents are not supported by this function.\n * The returned table will always contain an even number of events -- the first half will be the keyDown events and the second half will be the keyUp events.\n * The events have not been posted; the table can be used without change as the return value for a callback to a watcher defined with [hs.eventtap.new](#new)."
    },
    "Creates a new mouse event": {
        "prefix": "hs.eventtap.event.newMouseEvent(eventtype, point[, modifiers) -> event",
        "body": "hs.eventtap.event.newMouseEvent(${1:eventtype}, ${2:point[}, ${3:modifiers})",
        "description": "Creates a new mouse event\n\nParameters:\n * eventtype - One of the mouse related values from `hs.eventtap.event.types`\n * point - An hs.geometry point table (i.e. of the form `{x=123, y=456}`) indicating the location where the mouse event should occur\n * modifiers - An optional table (e.g. {\"cmd\", \"alt\"}) containing zero or more of the following keys:\n  * cmd\n  * alt\n  * shift\n  * ctrl\n  * fn\n\nReturns:\n * An `hs.eventtap` object"
    },
    "Creates a scroll wheel event": {
        "prefix": "hs.eventtap.event.newScrollEvent(offsets, mods, unit) -> event",
        "body": "hs.eventtap.event.newScrollEvent(${1:offsets}, ${2:mods}, ${3:unit})",
        "description": "Creates a scroll wheel event\n\nParameters:\n * offsets - A table containing the {horizontal, vertical} amount to scroll. Positive values scroll up or left, negative values scroll down or right.\n * mods - A table containing zero or more of the following:\n  * cmd\n  * alt\n  * shift\n  * ctrl\n  * fn\n * unit - An optional string containing the name of the unit for scrolling. Either \"line\" (the default) or \"pixel\"\n\nReturns:\n * An `hs.eventtap.event` object"
    },
    "Creates a keyboard event for special keys (e.g. media playback)": {
        "prefix": "hs.eventtap.event.newSystemKeyEvent(key, isdown) -> event",
        "body": "hs.eventtap.event.newSystemKeyEvent(${1:key}, ${2:isdown})",
        "description": "Creates a keyboard event for special keys (e.g. media playback)\n\nParameters:\n * key - A string containing the name of a special key. The possible names are:\n  * SOUND_UP\n  * SOUND_DOWN\n  * MUTE\n  * BRIGHTNESS_UP\n  * BRIGHTNESS_DOWN\n  * CONTRAST_UP\n  * CONTRAST_DOWN\n  * POWER\n  * LAUNCH_PANEL\n  * VIDMIRROR\n  * PLAY\n  * EJECT\n  * NEXT\n  * PREVIOUS\n  * FAST\n  * REWIND\n  * ILLUMINATION_UP\n  * ILLUMINATION_DOWN\n  * ILLUMINATION_TOGGLE\n  * CAPS_LOCK\n  * HELP\n  * NUM_LOCK\n * isdown - A boolean, true if the event should be a key-down, false if it should be a key-up\n\nReturns:\n * An `hs.eventtap.event` object\n\nNotes:\n * To set modifiers on a system key event (e.g. cmd/ctrl/etc), see the `hs.eventtap.event:setFlags()` method\n * The event names are case sensitive"
    },
    "Posts the event to the OS - i.e. emits the keyboard/mouse input defined by the event": {
        "prefix": "hs.eventtap.event:post([app])",
        "body": "hs.eventtap.event:post(${1:[app]})",
        "description": "Posts the event to the OS - i.e. emits the keyboard/mouse input defined by the event\n\nParameters:\n * app - An optional `hs.application` object. If specified, the event will only be sent to that application\n\nReturns:\n * The `hs.eventtap.event` object"
    },
    "A table containing property types for use with `hs.eventtap.event:getProperty()` and `hs.eventtap.event:setProperty()`.  The table supports forward (label to number) and reverse (number to label) lookups to increase its flexibility.": {
        "prefix": "hs.eventtap.event.properties -> table",
        "body": "hs.eventtap.event.properties",
        "description": "A table containing property types for use with `hs.eventtap.event:getProperty()` and `hs.eventtap.event:setProperty()`.  The table supports forward (label to number) and reverse (number to label) lookups to increase its flexibility.\n\nThe constants defined in this table are as follows:\n   (I) in the description indicates that this property is returned or set as an integer\n   (N) in the description indicates that this property is returned or set as a number (floating point)\n\n  * eventSourceGroupID                                      -- (I) The event source Unix effective GID.\n  * eventSourceStateID                                      -- (I) The event source state ID used to create this event.\n  * eventSourceUnixProcessID                                -- (I) The event source Unix process ID.\n  * eventSourceUserData                                     -- (I) Event source user-supplied data, up to 64 bits.\n  * eventSourceUserID                                       -- (I) The event source Unix effective UID.\n  * eventTargetProcessSerialNumber                          -- (I) The event target process serial number. The value is a 64-bit long word.\n  * eventTargetUnixProcessID                                -- (I) The event target Unix process ID.\n  * eventUnacceleratedPointerMovementX                      -- Undocumented, assumed Integer\n  * eventUnacceleratedPointerMovementY                      -- Undocumented, assumed Integer\n  * keyboardEventAutorepeat                                 -- (I) Non-zero when this is an autorepeat of a key-down, and zero otherwise.\n  * keyboardEventKeyboardType                               -- (I) The keyboard type identifier.\n  * keyboardEventKeycode                                    -- (I) The virtual keycode of the key-down or key-up event.\n  * mouseEventButtonNumber                                  -- (I) The mouse button number. For information about the possible values, see Mouse Buttons.\n  * mouseEventClickState                                    -- (I) The mouse button click state. A click state of 1 represents a single click. A click state of 2 represents a double-click. A click state of 3 represents a triple-click.\n  * mouseEventDeltaX                                        -- (I) The horizontal mouse delta since the last mouse movement event.\n  * mouseEventDeltaY                                        -- (I) The vertical mouse delta since the last mouse movement event.\n  * mouseEventInstantMouser                                 -- (I) The value is non-zero if the event should be ignored by the Inkwell subsystem.\n  * mouseEventNumber                                        -- (I) The mouse button event number. Matching mouse-down and mouse-up events will have the same event number.\n  * mouseEventPressure                                      -- (N) The mouse button pressure. The pressure value may range from 0 to 1, with 0 representing the mouse being up. This value is commonly set by tablet pens mimicking a mouse.\n  * mouseEventSubtype                                       -- (I) Encoding of the mouse event subtype. 0 = mouse, 1 = tablet point, 2 = tablet proximity, 3 = touch\n  * mouseEventWindowUnderMousePointer                       -- (I) Window ID of window underneath mouse pointer (this corresponds to `hs.window:id()`)\n  * mouseEventWindowUnderMousePointerThatCanHandleThisEvent -- (I) Window ID of window underneath mouse pointer that can handle this event (this corresponds to `hs.window:id()`)\n  * scrollWheelEventDeltaAxis1                              -- (I) Scrolling data. This field typically contains the change in vertical position since the last scrolling event from a Mighty Mouse scroller or a single-wheel mouse scroller.\n  * scrollWheelEventDeltaAxis2                              -- (I) Scrolling data. This field typically contains the change in horizontal position since the last scrolling event from a Mighty Mouse scroller.\n  * scrollWheelEventDeltaAxis3                              -- (I) This field is not used.\n  * scrollWheelEventFixedPtDeltaAxis1                       -- (N) Contains scrolling data which represents a line-based or pixel-based change in vertical position since the last scrolling event from a Mighty Mouse scroller or a single-wheel mouse scroller.\n  * scrollWheelEventFixedPtDeltaAxis2                       -- (N) Contains scrolling data which represents a line-based or pixel-based change in horizontal position since the last scrolling event from a Mighty Mouse scroller.\n  * scrollWheelEventFixedPtDeltaAxis3                       -- (N) This field is not used.\n  * scrollWheelEventInstantMouser                           -- (I) Indicates whether the event should be ignored by the Inkwell subsystem. If the value is non-zero, the event should be ignored.\n  * scrollWheelEventIsContinuous                            -- (I) Indicates whether a scrolling event contains continuous, pixel-based scrolling data. The value is non-zero when the scrolling data is pixel-based and zero when the scrolling data is line-based (note that this is the opposite of what constants in CGEventTypes.h suggest, so test before relying on and let us know what you discover!).\n  * scrollWheelEventMomentumPhase                           -- (I) Indicates scroll momentum phase: 0 = none, 1 = begin, 2 = continue, 3 = end\n  * scrollWheelEventPointDeltaAxis1                         -- (I) Pixel-based scrolling data. The scrolling data represents the change in vertical position since the last scrolling event from a Mighty Mouse scroller or a single-wheel mouse scroller.\n  * scrollWheelEventPointDeltaAxis2                         -- (I) Pixel-based scrolling data. The scrolling data represents the change in horizontal position since the last scrolling event from a Mighty Mouse scroller.\n  * scrollWheelEventPointDeltaAxis3                         -- (I) This field is not used.\n  * scrollWheelEventScrollCount                             -- (I) The number of scroll gestures that have begun before the momentum phase of the initial gesture has ended (unverified, this is inferred from web comments).\n  * scrollWheelEventScrollPhase                             -- (I) Indicates scroll phase: 1 = began, 2 = changed, 4 = ended, 8 = cancelled, 128 = may begin.\n  * tabletEventDeviceID                                     -- (I) The system-assigned unique device ID.\n  * tabletEventPointButtons                                 -- (I) The tablet button state. Bit 0 is the first button, and a set bit represents a closed or pressed button. Up to 16 buttons are supported.\n  * tabletEventPointPressure                                -- (N) The tablet pen pressure. A value of 0.0 represents no pressure, and 1.0 represents maximum pressure.\n  * tabletEventPointX                                       -- (I) The absolute X coordinate in tablet space at full tablet resolution.\n  * tabletEventPointY                                       -- (I) The absolute Y coordinate in tablet space at full tablet resolution.\n  * tabletEventPointZ                                       -- (I) The absolute Z coordinate in tablet space at full tablet resolution.\n  * tabletEventRotation                                     -- (N) The tablet pen rotation.\n  * tabletEventTangentialPressure                           -- (N) The tangential pressure on the device. A value of 0.0 represents no pressure, and 1.0 represents maximum pressure.\n  * tabletEventTiltX                                        -- (N) The horizontal tablet pen tilt. A value of 0.0 represents no tilt, and 1.0 represents maximum tilt.\n  * tabletEventTiltY                                        -- (N) The vertical tablet pen tilt. A value of 0.0 represents no tilt, and 1.0 represents maximum tilt.\n  * tabletEventVendor1                                      -- (I) A vendor-specified value.\n  * tabletEventVendor2                                      -- (I) A vendor-specified value.\n  * tabletEventVendor3                                      -- (I) A vendor-specified value.\n  * tabletProximityEventCapabilityMask                      -- (I) The device capabilities mask.\n  * tabletProximityEventDeviceID                            -- (I) The system-assigned device ID.\n  * tabletProximityEventEnterProximity                      -- (I) Indicates whether the pen is in proximity to the tablet. The value is non-zero if the pen is in proximity to the tablet and zero when leaving the tablet.\n  * tabletProximityEventPointerID                           -- (I) The vendor-defined ID of the pointing device.\n  * tabletProximityEventPointerType                         -- (I) The pointer type.\n  * tabletProximityEventSystemTabletID                      -- (I) The system-assigned unique tablet ID.\n  * tabletProximityEventTabletID                            -- (I) The vendor-defined tablet ID, typically the USB product ID.\n  * tabletProximityEventVendorID                            -- (I) The vendor-defined ID, typically the USB vendor ID.\n  * tabletProximityEventVendorPointerSerialNumber           -- (I) The vendor-defined pointer serial number.\n  * tabletProximityEventVendorPointerType                   -- (I) The vendor-assigned pointer type.\n  * tabletProximityEventVendorUniqueID                      -- (I) The vendor-defined unique ID."
    },
    "A table containing key-value pairs describing the raw modifier flags which can be manipulated with [hs.eventtap.event:rawFlags](#rawFlags).": {
        "prefix": "hs.eventtap.event.rawFlagMasks[]",
        "body": "hs.eventtap.event.rawFlagMasks",
        "description": "A table containing key-value pairs describing the raw modifier flags which can be manipulated with [hs.eventtap.event:rawFlags](#rawFlags).\n\nThis table and [hs.eventtap.event:rawFlags](#rawFlags) are both considered experimental as the full meanings behind some of these flags and what combinations are likely to be observed is still being determined.  It is possible that some of these key names may change in the future.\n\nAt present, what is known about the flags is presented here:\n * alternate                 - Corresponds to the left (or only) alt key on the keyboard\n * command                   - Corresponds to the left (or only) cmd key on the keyboard\n * control                   - Corresponds to the left (or only) ctrl key on the keyboard\n * shift                     - Corresponds to the left (or only) shift key on the keyboard\n * numericPad                - Indicates that the key corresponds to one defined as belonging to the numeric keypad, if present\n * secondaryFn               - Indicates the fn key found on most modern Macintosh laptops.  May also be observed with function and other special keys (arrows, page-up/down, etc.)\n * deviceRightAlternate      - Corresponds to the right alt key on the keyboard (if present)\n * deviceRightCommand        - Corresponds to the right cmd key on the keyboard (if present)\n * deviceRightControl        - Corresponds to the right ctrl key on the keyboard (if present)\n * deviceRightShift          - Corresponds to the right alt key on the keyboard (if present)\n * nonCoalesced              - Indicates that multiple mouse movements are not being coalesced into one event if delivery of the event has been delayed\n\nThe following are also defined in IOLLEvent.h, but the description is a guess since I have not observed them myself\n * alphaShift                - related to the caps-lock in some way?\n * alphaShiftStateless       - related to the caps-lock in some way?\n * deviceAlphaShiftStateless - related to the caps-lock in some way?\n * deviceLeftAlternate       - Corresponds to the left alt key on the keyboard (if present)\n * deviceLeftCommand         - Corresponds to the left cmd key on the keyboard (if present)\n * deviceLeftControl         - Corresponds to the left ctrl key on the keyboard (if present)\n * deviceLeftShift           - Corresponds to the left shift key on the keyboard (if present)\n * help                      - related to a modifier found on old NeXT keyboards but not on modern keyboards?\n\nIt has also been observed that synthetic events that have been posted also have the bit represented by 0x20000000 set.  This constant does not appear in IOLLEvent.h or CGEventTypes.h, which defines most of the constants used in this module, so it is not included within this table at present, but may be added in the future if any corroborating information can be found.\n\nFor what it may be worth, I have found it most useful to filter out `nonCoalesced` and 0x20000000 before examining the flags in my own code, like this: `hs.eventtap.event:rawFlags() & 0xdffffeff` where 0xdffffeff = ~(0x20000000 | 0x100) (limited to the 32 bits since that is what is returned by `rawFlags`).\n\nAny documentation or references that can be found which can further expand on the information here is welcome -- Please submit any information you may have through the Hammerspoon GitHub site or Google group."
    },
    "Experimental method to get or set the modifier flags for an event directly.": {
        "prefix": "hs.eventtap.event:rawFlags([flags]) -> event | integer",
        "body": "hs.eventtap.event:rawFlags(${1:[flags]})",
        "description": "Experimental method to get or set the modifier flags for an event directly.\n\nParameters:\n * flags - an optional integer, made by logically combining values from [hs.eventtap.event.rawFlagMasks](#rawFlagMasks) specifying the modifier keys which should be set for this event\n\nReturns:\n * if flags is provided, returns the `hs.eventtap.event` object; otherwise returns the current flags set as an integer\n\nNotes:\n * This method is experimental and may undergo changes or even removal in the future\n * See [hs.eventtap.event.rawFlagMasks](#rawFlagMasks) for more information"
    },
    "Sets the keyboard modifiers of an event": {
        "prefix": "hs.eventtap.event:setFlags(table) -> event",
        "body": "hs.eventtap.event:setFlags(${1:table})",
        "description": "Sets the keyboard modifiers of an event\n\nParameters:\n * A table containing the keyboard modifiers to be sent with the event - i.e. zero or more of the following keys, each with a value of `true`:\n  * cmd\n  * alt\n  * shift\n  * ctrl\n  * fn\n\nReturns:\n * The `hs.eventap.event` object."
    },
    "Sets the raw keycode for the event": {
        "prefix": "hs.eventtap.event:setKeyCode(keycode)",
        "body": "hs.eventtap.event:setKeyCode(${1:keycode})",
        "description": "Sets the raw keycode for the event\n\nParameters:\n * keycode - A number containing a raw keycode, taken from `hs.keycodes.map`\n\nReturns:\n * The `hs.eventtap.event` object\n\nNotes:\n * This method should only be used on keyboard events"
    },
    "Sets a property of the event": {
        "prefix": "hs.eventtap.event:setProperty(prop, value)",
        "body": "hs.eventtap.event:setProperty(${1:prop}, ${2:value})",
        "description": "Sets a property of the event\n\nParameters:\n * prop - A value from `hs.eventtap.event.properties`\n * value - A number containing the value of the specified property\n\nReturns:\n * The `hs.eventtap.event` object.\n\nNotes:\n * The properties are `CGEventField` values, as documented at https://developer.apple.com/library/mac/documentation/Carbon/Reference/QuartzEventServicesRef/index.html#//apple_ref/c/tdef/CGEventField"
    },
    "Set the type for this event.": {
        "prefix": "hs.eventtap.event:setType(type) -> event",
        "body": "hs.eventtap.event:setType(${1:type})",
        "description": "Set the type for this event.\n\nParameters:\n * type - an integer matching one of the event types described in [hs.eventtap.event.types](#types)\n\nReturns:\n * the `hs.eventtap.event` object"
    },
    "Sets a unicode string as the output of the event": {
        "prefix": "hs.eventtap.event:setUnicodeString(string)",
        "body": "hs.eventtap.event:setUnicodeString(${1:string})",
        "description": "Sets a unicode string as the output of the event\n\nParameters:\n * string - A string containing unicode characters, which will be applied to the event\n\nReturns:\n * The `hs.eventtap.event` object\n\nNotes:\n * Calling this method will reset any flags previously set on the event (because they don't make any sense, and you should not try to set flags again)\n * This is likely to only work with short unicode strings that resolve to a single character"
    },
    "Returns the special key and its state if the event is a NSSystemDefined event of subtype AUX_CONTROL_BUTTONS (special-key pressed)": {
        "prefix": "hs.eventtap.event:systemKey() -> table",
        "body": "hs.eventtap.event:systemKey()",
        "description": "Returns the special key and its state if the event is a NSSystemDefined event of subtype AUX_CONTROL_BUTTONS (special-key pressed)\n\nParameters:\n * None\n\nReturns:\n * If the event is a NSSystemDefined event of subtype AUX_CONTROL_BUTTONS, a table with the following keys defined:\n   * key    -- a string containing one of the following labels indicating the key involved:\n     * SOUND_UP\n     * SOUND_DOWN\n     * MUTE\n     * BRIGHTNESS_UP\n     * BRIGHTNESS_DOWN\n     * CONTRAST_UP\n     * CONTRAST_DOWN\n     * POWER\n     * LAUNCH_PANEL\n     * VIDMIRROR\n     * PLAY\n     * EJECT\n     * NEXT\n     * PREVIOUS\n     * FAST\n     * REWIND\n     * ILLUMINATION_UP\n     * ILLUMINATION_DOWN\n     * ILLUMINATION_TOGGLE\n     * CAPS_LOCK\n     * HELP\n     * NUM_LOCK\n     or \"undefined\" if the key detected is unrecognized.\n   * keyCode -- the numeric keyCode corresponding to the key specified in `key`.\n   * down   -- a boolean value indicating if the key is pressed down (true) or just released (false)\n   * repeat -- a boolean indicating if this event is because the keydown is repeating.  This will always be false for a key release.\n * If the event does not correspond to a NSSystemDefined event of subtype AUX_CONTROL_BUTTONS, then an empty table is returned.\n\nNotes:\n* CAPS_LOCK seems to sometimes generate 0 or 2 key release events (down == false), especially on builtin laptop keyboards, so it is probably safest (more reliable) to look for cases where down == true only.\n* If the key field contains \"undefined\", you can use the number in keyCode to look it up in `/System/Library/Frameworks/IOKit.framework/Headers/hidsystem/ev_keymap.h`.  If you believe the numeric value is part of a new system update or was otherwise mistakenly left out, please submit the label (it will defined in the header file as `NX_KEYTYPE_something`) and number to the Hammerspoon maintainers at https://github.com/Hammerspoon/hammerspoon with a request for inclusion in the next Hammerspoon update."
    },
    "Get or set the timestamp of the event.": {
        "prefix": "hs.eventtap.event:timestamp([absolutetime]) -> event | integer",
        "body": "hs.eventtap.event:timestamp(${1:[absolutetime]})",
        "description": "Get or set the timestamp of the event.\n\nParameters:\n * absolutetime - an optional integer specifying the timestamp for the event.\n\nReturns:\n * if absolutetime is provided, returns the `hs.eventtap.event` object; otherwise returns the current timestamp for the event.\n\nNotes:\n * Synthesized events have a timestamp of 0 by default.\n * The timestamp, if specified, is expressed as an integer representing the number of nanoseconds since the system was last booted.  See `hs.timer.absoluteTime`.\n * This field appears to be informational only and is not required when crafting your own events with this module."
    },
    "A table containing event types to be used with `hs.eventtap.new(...)` and returned by `hs.eventtap.event:type()`.  The table supports forward (label to number) and reverse (number to label) lookups to increase its flexibility.": {
        "prefix": "hs.eventtap.event.types -> table",
        "body": "hs.eventtap.event.types",
        "description": "A table containing event types to be used with `hs.eventtap.new(...)` and returned by `hs.eventtap.event:type()`.  The table supports forward (label to number) and reverse (number to label) lookups to increase its flexibility.\n\nThe constants defined in this table are as follows:\n\n  * nullEvent         --  Specifies a null event. (thus far unobserved; please submit an issue if you can provide more information)\n  * leftMouseDown     --  Specifies a mouse down event with the left button.\n  * leftMouseUp       --  Specifies a mouse up event with the left button.\n  * rightMouseDown    --  Specifies a mouse down event with the right button.\n  * rightMouseUp      --  Specifies a mouse up event with the right button.\n  * mouseMoved        --  Specifies a mouse moved event.\n  * leftMouseDragged  --  Specifies a mouse drag event with the left button down.\n  * rightMouseDragged --  Specifies a mouse drag event with the right button down.\n  * keyDown           --  Specifies a key down event.\n  * keyUp             --  Specifies a key up event.\n  * flagsChanged      --  Specifies a key changed event for a modifier or status key.\n  * scrollWheel       --  Specifies a scroll wheel moved event.\n  * tabletPointer     --  Specifies a tablet pointer event.\n  * tabletProximity   --  Specifies a tablet proximity event.\n  * otherMouseDown    --  Specifies a mouse down event with one of buttons 2-31.\n  * otherMouseUp      --  Specifies a mouse up event with one of buttons 2-31.\n  * otherMouseDragged --  Specifies a mouse drag event with one of buttons 2-31 down.\n\n The following events, also included in the lookup table, are provided through NSEvent and currently may require the use of `hs.eventtap.event:getRawEventData()` to retrieve supporting information.  Target specific methods may be added as the usability of these events is explored.\n\n  * gesture               --  An event that represents a touch event on a touch sensitive trackpad or touchbar. See below.\n  * systemDefined         --  An event indicating some system event has occurred. For us, it is primarily used to detect special system keys (Volume Up/Down, etc.). See [hs.eventtap.event:systemKey](#systemKey) and [hs.eventtap.event.newSystemKeyEvent](#newSystemKeyEvent).\n\n  * appKitDefined         --  (thus far unobserved; please submit an issue if you can provide more information)\n  * applicationDefined    --  (thus far unobserved; please submit an issue if you can provide more information)\n  * cursorUpdate          --  (thus far unobserved; please submit an issue if you can provide more information)\n  * mouseEntered          --  (thus far unobserved; please submit an issue if you can provide more information)\n  * mouseExited           --  (thus far unobserved; please submit an issue if you can provide more information)\n  * periodic              --  (thus far unobserved; please submit an issue if you can provide more information)\n  * quickLook             --  (thus far unobserved; please submit an issue if you can provide more information)\n\n To detect the following events, setup your eventtap to capture the `hs.eventtap.event.type.gesture` type and examine the value of [hs.eventtap.event:getType(true)](#getType).\n  * gesture      --  The user touched a portion of a touchpad\n  * directTouch  --  The user touched a portion of the touch bar.\n  * changeMode   --  A double-tap on the side of an Apple Pencil paired with an iPad that is being used as an external monitor via Sidecar.\n  * magnify      --  The user performed a pinch open or pinch close gesture.\n  * pressure     --  The pressure on a forcetouch trackpad has changed..\n  * rotate       --  The user performed a rotation gesture.\n  * smartMagnify --  The user performed a smart zoom gesture (2-finger double tap on trackpads).\n  * swipe        --  The user performed a swipe gesture. (thus far unobserved; please submit an issue if you can provide more information)"
    },
    "Hides the expose, if visible, and exits the modal mode.": {
        "prefix": "hs.expose:hide()",
        "body": "hs.expose:hide()",
        "description": "Hides the expose, if visible, and exits the modal mode.\nCall this function if you need to make sure the modal is exited without waiting for the user to press `esc`.\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Creates a new hs.expose instance; it can use a windowfilter to determine which windows to show": {
        "prefix": "hs.expose.new([windowfilter[, uiPrefs][, logname, [loglevel]]]) -> hs.expose object",
        "body": "hs.expose.new(${1:[windowfilter[}, ${2:uiPrefs][}, ${3:logname}, ${4:[loglevel]]]})",
        "description": "Creates a new hs.expose instance; it can use a windowfilter to determine which windows to show\n\nParameters:\n * windowfilter - (optional) if omitted or nil, use the default windowfilter; otherwise it must be a windowfilter\n   instance or constructor table\n * uiPrefs - (optional) a table to override UI preferences for this instance; its keys and values\n   must follow the conventions described in `hs.expose.ui`; this parameter allows you to have multiple\n   expose instances with different behaviour (for example, with and without thumbnails and/or titles)\n   using different hotkeys\n * logname - (optional) name of the `hs.logger` instance for the new expose; if omitted, the class logger will be used\n * loglevel - (optional) log level for the `hs.logger` instance for the new expose\n\nReturns:\n * the new instance\n\nNotes:\n  * by default expose will show invisible windows and (unlike the OSX expose) windows from other spaces; use\n    `hs.expose.ui` or the `uiPrefs` parameter to change these behaviours."
    },
    "Shows an expose-like screen with modal keyboard hints for switching to, closing or minimizing/unminimizing windows.": {
        "prefix": "hs.expose:show([activeApplication])",
        "body": "hs.expose:show(${1:[activeApplication]})",
        "description": "Shows an expose-like screen with modal keyboard hints for switching to, closing or minimizing/unminimizing windows.\n\nParameters:\n * activeApplication - (optional) if true, only show windows of the active application (within the\n  scope of the instance windowfilter); otherwise show all windows allowed by the instance windowfilter\n\nReturns:\n * None\n\nNotes:\n * passing `true` for `activeApplication` will simply hide hints/thumbnails for applications other\n   than the active one, without recalculating the hints layout; conversely, setting `onlyActiveApplication=true`\n   for an expose instance's `ui` will calculate an optimal layout for the current active application's windows\n * Completing a hint will exit the expose and focus the selected window.\n * Pressing esc will exit the expose and with no action taken.\n * If shift is being held when a hint is completed (the background will be red), the selected\n   window will be closed. If it's the last window of an application, the application will be closed.\n * If alt is being held when a hint is completed (the background will be blue), the selected\n   window will be minimized (if visible) or unminimized/unhidden (if minimized or hidden)."
    },
    "Toggles the expose - see `hs.expose:show()` and `hs.expose:hide()`": {
        "prefix": "hs.expose:toggleShow([activeApplication])",
        "body": "hs.expose:toggleShow(${1:[activeApplication]})",
        "description": "Toggles the expose - see `hs.expose:show()` and `hs.expose:hide()`\n\nParameters: see `hs.expose:show()`\n\nReturns:\n * None"
    },
    "Allows customization of the expose behaviour and user interface": {
        "prefix": "hs.expose.ui",
        "body": "hs.expose.ui",
        "description": "Allows customization of the expose behaviour and user interface\n\nThis table contains variables that you can change to customize the behaviour of the expose and the look of the UI.\nTo have multiple expose instances with different behaviour/looks, use the `uiPrefs` parameter for the constructor;\nthe passed keys and values will override those in this table for that particular instance.\n\nThe default values are shown in the right hand side of the assignements below.\n\nTo represent color values, you can use:\n * a table {red=redN, green=greenN, blue=blueN, alpha=alphaN}\n * a table {redN,greenN,blueN[,alphaN]} - if omitted alphaN defaults to 1.0\nwhere redN, greenN etc. are the desired value for the color component between 0.0 and 1.0\n\n * `hs.expose.ui.textColor = {0.9,0.9,0.9}`\n * `hs.expose.ui.fontName = 'Lucida Grande'`\n * `hs.expose.ui.textSize = 40` - in screen points\n * `hs.expose.ui.highlightColor = {0.8,0.5,0,0.1}` - highlight color for candidate windows\n * `hs.expose.ui.backgroundColor = {0.30,0.03,0.03,1}`\n * `hs.expose.ui.closeModeModifier = 'shift'` - \"close mode\" engaged while pressed (or 'cmd','ctrl','alt')\n * `hs.expose.ui.closeModeBackgroundColor = {0.7,0.1,0.1,1}` - background color while \"close mode\" is engaged\n * `hs.expose.ui.minimizeModeModifier = 'alt'` - \"minimize mode\" engaged while pressed\n * `hs.expose.ui.minimizeModeBackgroundColor = {0.1,0.2,0.3,1}` - background color while \"minimize mode\" is engaged\n * `hs.expose.ui.onlyActiveApplication = false` -- only show windows of the active application\n * `hs.expose.ui.includeNonVisible = true` - include minimized and hidden windows\n * `hs.expose.ui.nonVisibleStripBackgroundColor = {0.03,0.1,0.15,1}` - contains hints for non-visible windows\n * `hs.expose.ui.nonVisibleStripPosition = 'bottom'` - set it to your Dock position ('bottom', 'left' or 'right')\n * `hs.expose.ui.nonVisibleStripWidth = 0.1` - 0..0.5, width of the strip relative to the screen\n * `hs.expose.ui.includeOtherSpaces = true` - include windows in other Mission Control Spaces\n * `hs.expose.ui.otherSpacesStripBackgroundColor = {0.1,0.1,0.1,1}`\n * `hs.expose.ui.otherSpacesStripPosition = 'top'`\n * `hs.expose.ui.otherSpacesStripWidth = 0.2`\n * `hs.expose.ui.showTitles = true` - show window titles\n * `hs.expose.ui.showThumbnails = true` - show window thumbnails\n * `hs.expose.ui.thumbnailAlpha = 0` - 0..1, opacity for thumbnails\n * `hs.expose.ui.highlightThumbnailAlpha = 1` - 0..1, opacity for thumbnails of candidate windows\n * `hs.expose.ui.highlightThumbnailStrokeWidth = 8` - thumbnail frame thickness for candidate windows\n * `hs.expose.ui.maxHintLetters = 2` - if necessary, hints longer than this will be disambiguated with digits\n * `hs.expose.ui.fitWindowsMaxIterations = 30` -- lower is faster, but higher chance of overlapping thumbnails\n * `hs.expose.ui.fitWindowsInBackground = false` -- improves responsivenss, but can affect the rest of the config"
    },
    "Join two tables together": {
        "prefix": "hs.fnutils.concat(table1, table2)",
        "body": "hs.fnutils.concat(${1:table1}, ${2:table2})",
        "description": "Join two tables together\n\nParameters:\n * table1 - A table containing some sort of data\n * table2 - A table containing some sort of data\n\nReturns:\n * table1, with all of table2's elements added to the end of it\n\nNotes:\n * table2 cannot be a sparse table, see [http://www.luafaq.org/gotchas.html#T6.4](http://www.luafaq.org/gotchas.html#T6.4)"
    },
    "Determine if a table contains a given object": {
        "prefix": "hs.fnutils.contains(table, element) -> bool",
        "body": "hs.fnutils.contains(${1:table}, ${2:element})",
        "description": "Determine if a table contains a given object\n\nParameters:\n * table - A table containing some sort of data\n * element - An object to search the table for\n\nReturns:\n * A boolean, true if the element could be found in the table, otherwise false"
    },
    "Copy a table using `pairs()`": {
        "prefix": "hs.fnutils.copy(table) -> table",
        "body": "hs.fnutils.copy(${1:table})",
        "description": "Copy a table using `pairs()`\n\nParameters:\n * table - A table containing some sort of data\n\nReturns:\n * A new table containing the same data as the input table"
    },
    "Creates a function that repeatedly iterates a table": {
        "prefix": "hs.fnutils.cycle(table) -> fn()",
        "body": "hs.fnutils.cycle(${1:table})",
        "description": "Creates a function that repeatedly iterates a table\n\nParameters:\n * table - A table containing some sort of data\n\nReturns:\n * A function that, when called repeatedly, will return all of the elements of the supplied table, repeating indefinitely\n\nNotes:\n * table cannot be a sparse table, see [http://www.luafaq.org/gotchas.html#T6.4](http://www.luafaq.org/gotchas.html#T6.4)\n * An example usage:\n    ```lua\n    f = cycle({4, 5, 6})\n    {f(), f(), f(), f(), f(), f(), f()} == {4, 5, 6, 4, 5, 6, 4}\n    ```"
    },
    "Execute a function across a table (in arbitrary order), and discard the results": {
        "prefix": "hs.fnutils.each(table, fn)",
        "body": "hs.${2:fn}utils.each(${1:table}, fn)",
        "description": "Execute a function across a table (in arbitrary order), and discard the results\n\nParameters:\n * table - A table; it can have both a list (or array) part and a hash (or dict) part\n * fn - A function that accepts a single parameter (a table element)\n\nReturns:\n * None"
    },
    "Returns true if the application of fn on every entry in table is true.": {
        "prefix": "hs.fnutils.every(table, fn) -> bool",
        "body": "hs.${2:fn}utils.every(${1:table}, fn)",
        "description": "Returns true if the application of fn on every entry in table is true.\n\nParameters:\n * table - A table containing some sort of data\n * fn - A function that accepts a single parameter and returns a \"true\" value (any value except the boolean `false` or nil) if the parameter was accepted, or a \"false\" value (the boolean false or nil) if the parameter was rejected.\n\nReturns:\n * True if the application of fn on every element of the table is true\n * False if the function returns `false` for any element of the table.  Note that testing stops when the first false return is detected."
    },
    "Filter a table by running a predicate function on its elements (in arbitrary order)": {
        "prefix": "hs.fnutils.filter(table, fn) -> table",
        "body": "hs.${2:fn}utils.filter(${1:table}, fn)",
        "description": "Filter a table by running a predicate function on its elements (in arbitrary order)\n\nParameters:\n * table - A table; it can have both a list (or array) part and a hash (or dict) part\n * fn - A function that accepts a single parameter (a table element) and returns a boolean\n   value: true if the parameter should be kept, false if it should be discarded\n\nReturns:\n * A table containing the elements of the table for which fn(element) returns true\n\nNotes:\n * If `table` is a pure array table (list-like) without \"holes\", use `hs.fnutils.ifilter()` if you need guaranteed in-order\n processing and for better performance."
    },
    "Execute a function across a table and return the first element where that function returns true": {
        "prefix": "hs.fnutils.find(table, fn) -> element",
        "body": "hs.${2:fn}utils.find(${1:table}, fn)",
        "description": "Execute a function across a table and return the first element where that function returns true\n\nParameters:\n * table - A table containing some sort of data\n * fn - A function that takes one parameter and returns a boolean value\n\nReturns:\n * The element of the supplied table that first caused fn to return true"
    },
    "Execute a function across a list-like table in order, and discard the results": {
        "prefix": "hs.fnutils.ieach(list, fn)",
        "body": "hs.${2:fn}utils.ieach(${1:list}, fn)",
        "description": "Execute a function across a list-like table in order, and discard the results\n\nParameters:\n * list - A list-like table, i.e. one whose keys are sequential integers starting from 1\n * fn - A function that accepts a single parameter (a table element)\n\nReturns:\n * None"
    },
    "Filter a list-like table by running a predicate function on its elements in order": {
        "prefix": "hs.fnutils.ifilter(list, fn) -> list",
        "body": "hs.${2:fn}utils.ifilter(${1:list}, fn)",
        "description": "Filter a list-like table by running a predicate function on its elements in order\n\nParameters:\n * list - A list-like table, i.e. one whose keys are sequential integers starting from 1\n * fn - A function that accepts a single parameter (a table element) and returns a boolean\n   value: true if the parameter should be kept, false if it should be discarded\n\nReturns:\n * A list-like table containing the elements of the table for which fn(element) returns true\n\nNotes:\n * If `list` has \"holes\", all elements after the first hole will be lost, as the table is iterated over with `ipairs`;\n   use `hs.fnutils.map()` if your table has holes"
    },
    "Execute a function across a list-like table in order, and collect the results": {
        "prefix": "hs.fnutils.imap(list, fn) -> list",
        "body": "hs.${2:fn}utils.imap(${1:list}, fn)",
        "description": "Execute a function across a list-like table in order, and collect the results\n\nParameters:\n * list - A list-like table, i.e. one whose keys are sequential integers starting from 1\n * fn - A function that accepts a single parameter (a table element). The values returned from this function\n   will be collected into the result list; when `nil` is returned the relevant element is discarded - the\n   result list won't have any \"holes\".\n\nReturns:\n * A list-like table containing the results of calling the function on every element in the table\n\nNotes:\n * If `list` has \"holes\", all elements after the first hole will be lost, as the table is iterated over with `ipairs`;\n   use `hs.fnutils.map()` if your table has holes"
    },
    "Determine the location in a table of a given object": {
        "prefix": "hs.fnutils.indexOf(table, element) -> number or nil",
        "body": "hs.fnutils.indexOf(${1:table}, ${2:element})",
        "description": "Determine the location in a table of a given object\n\nParameters:\n * table - A table containing some sort of data\n * element - An object to search the table for\n\nReturns:\n * A number containing the index of the element in the table, or nil if it could not be found"
    },
    "Execute a function across a table (in arbitrary order) and collect the results": {
        "prefix": "hs.fnutils.map(table, fn) -> table",
        "body": "hs.${2:fn}utils.map(${1:table}, fn)",
        "description": "Execute a function across a table (in arbitrary order) and collect the results\n\nParameters:\n * table - A table; it can have both a list (or array) part and a hash (or dict) part\n * fn - A function that accepts a single parameter (a table element). For the hash part, the values returned\n from this function (if non-nil) will be assigned to the same key in the result list. For the array part, this function\n behaves like `hs.fnutils.imap()` (i.e. `nil` results are discarded); however all keys, including integer keys after\n a \"hole\" in `table`, will be iterated over.\n\nReturns:\n * A table containing the results of calling the function on every element in the table\n\nNotes:\n * If `table` is a pure array table (list-like) without \"holes\", use `hs.fnutils.imap()` if you need guaranteed in-order\n processing and for better performance."
    },
    "Execute, across a table, a function that outputs tables, and concatenate all of those tables together": {
        "prefix": "hs.fnutils.mapCat(table, fn) -> table",
        "body": "hs.${2:fn}utils.mapCat(${1:table}, fn)",
        "description": "Execute, across a table, a function that outputs tables, and concatenate all of those tables together\n\nParameters:\n * table - A table containing some sort of data\n * fn - A function that takes a single parameter and returns a table\n\nReturns:\n * A table containing the concatenated results of calling fn(element) for every element in the supplied table"
    },
    "Returns a new function which takes the provided arguments and pre-applies them as the initial arguments to the provided function.  When the new function is later invoked with additional arguments, they are appended to the end of the initial list given and the complete list of arguments is finally passed into the provided function and its result returned.": {
        "prefix": "hs.fnutils.partial(fn, ...) -> fn'",
        "body": "hs.${1:fn}utils.partial(fn, ${2:...})",
        "description": "Returns a new function which takes the provided arguments and pre-applies them as the initial arguments to the provided function.  When the new function is later invoked with additional arguments, they are appended to the end of the initial list given and the complete list of arguments is finally passed into the provided function and its result returned.\n\nParameters:\n * fn - The function which will act on all of the arguments provided now and when the result is invoked later.\n * ... - The initial arguments to pre-apply to the resulting new function.\n\nReturns:\n * A function\n\nNotes:\n * This is best understood with an example which you can test in the Hammerspoon console:\n\n   Create the function `a` which has it's initial arguments set to `1,2,3`:\n      a = hs.fnutils.partial(function(...) return table.pack(...) end, 1, 2, 3)\n\n   Now some examples of using the new function, `a(...)`:\n      hs.inspect(a(\"a\",\"b\",\"c\")) will return: { 1, 2, 3, \"a\", \"b\", \"c\", n = 6 }\n      hs.inspect(a(4,5,6,7))     will return: { 1, 2, 3, 4, 5, 6, 7, n = 7 }\n      hs.inspect(a(1))           will return: { 1, 2, 3, 1, n = 4 }"
    },
    "Reduce a table to a single element, using a function": {
        "prefix": "hs.fnutils.reduce(table, fn) -> table",
        "body": "hs.${2:fn}utils.reduce(${1:table}, fn)",
        "description": "Reduce a table to a single element, using a function\n\nParameters:\n * table - A table containing some sort of data\n * fn - A function that takes two parameters, which will be elements of the supplied table. It should choose one of these elements and return it\n\nReturns:\n * The element of the supplied table that was chosen by the iterative reducer function\n\nNotes:\n * table cannot be a sparse table, see [http://www.luafaq.org/gotchas.html#T6.4](http://www.luafaq.org/gotchas.html#T6.4)\n * The first iteration of the reducer will call fn with the first and second elements of the table. The second iteration will call fn with the result of the first iteration, and the third element. This repeats until there is only one element left"
    },
    "Creates a function that will collect the result of a series of functions into a table": {
        "prefix": "hs.fnutils.sequence(...) -> fn",
        "body": "hs.fnutils.sequence(${1:...})",
        "description": "Creates a function that will collect the result of a series of functions into a table\n\nParameters:\n * ... - A number of functions, passed as different arguments. They should accept zero parameters, and return something\n\nReturns:\n * A function that, when called, will call all of the functions passed to this constructor. The output of these functions will be collected together and returned."
    },
    "Returns true if the application of fn on entries in table are true for at least one of the members.": {
        "prefix": "hs.fnutils.some(table, fn) -> bool",
        "body": "hs.${2:fn}utils.some(${1:table}, fn)",
        "description": "Returns true if the application of fn on entries in table are true for at least one of the members.\n\nParameters:\n * table - A table containing some sort of data\n * fn - A function that accepts a single parameter and returns a \"true\" value (any value except the boolean `false` or nil) if the parameter was accepted, or a \"false\" value (the boolean false or nil) if the parameter was rejected.\n\nReturns:\n * True if the application of fn on any element of the table is true.  Note that testing stops when the first true return is detected.\n * False if the function returns `false` for all elements of the table."
    },
    "Iterator for retrieving elements from a table of key-value pairs in the order of the keys.": {
        "prefix": "hs.fnutils.sortByKeys(table[ , function]) -> function",
        "body": "hs.fnutils.sortByKeys(${1:table[} , ${2:function]})",
        "description": "Iterator for retrieving elements from a table of key-value pairs in the order of the keys.\n\nParameters:\n * table - the table of key-value pairs to be iterated through\n * fn - an optional function which will be passed to `table.sort` to determine how the keys are sorted.  If it is not present, then keys will be sorted numerically/alphabetically.\n\nReturns:\n * function to be used as an iterator\n\nNotes:\n * Similar to Perl's `sort(keys %hash)`\n * Iterators are used in looping constructs like `for`:\n   * `for i,v in hs.fnutils.sortByKeys(t[, f]) do ... end`\n * A sort function should accept two arguments and return true if the first argument should appear before the second, or false otherwise.\n   * e.g. `function(m,n) return not (m < n) end` would result in reverse alphabetic order.\n   * See _Programming_In_Lua,_3rd_ed_, page 52 for a more complete discussion.\n   * The default sort is to compare keys directly, if they are of the same type, or as their tostring() versions, if the key types differ:\n     * function(m,n) if type(m) ~= type(n) then return tostring(m) < tostring(n) else return m < n end"
    },
    "Iterator for retrieving elements from a table of key-value pairs in the order of the values.": {
        "prefix": "hs.fnutils.sortByKeyValues(table[ , function]) -> function",
        "body": "hs.fnutils.sortByKeyValues(${1:table[} , ${2:function]})",
        "description": "Iterator for retrieving elements from a table of key-value pairs in the order of the values.\n\nParameters:\n * table - the table of key-value pairs to be iterated through\n * fn - an optional function which will be passed to `table.sort` to determine how the values are sorted.  If it is not present, then values will be sorted numerically/alphabetically.\n\nReturns:\n * function to be used as an iterator\n\nNotes:\n * Similar to Perl's `sort { $hash{$a} <=> $hash{$b} } keys %hash`\n * Iterators are used in looping constructs like `for`:\n   * `for i,v in hs.fnutils.sortByKeyValues(t[, f]) do ... end`\n * A sort function should accept two arguments and return true if the first argument should appear before the second, or false otherwise.\n   * e.g. `function(m,n) return not (m < n) end` would result in reverse alphabetic order.\n   * See _Programming_In_Lua,_3rd_ed_, page 52 for a more complete discussion.\n   * The default sort is to compare values directly, if they are of the same type, or as their tostring() versions, if the value types differ:\n     * function(m,n) if type(m) ~= type(n) then return tostring(m) < tostring(n) else return m < n end"
    },
    "Convert string to an array of strings, breaking at the specified separator.": {
        "prefix": "hs.fnutils.split(sString, sSeparator [, nMax] [, bPlain]) -> { array }",
        "body": "hs.fnutils.split(${1:sString}, ${2:sSeparator [}, ${3:nMax] [}, ${4:bPlain]})",
        "description": "Convert string to an array of strings, breaking at the specified separator.\n\nParameters:\n * sString    -- the string to split into substrings\n * sSeparator -- the separator.  If `bPlain` is false or not provided, this is treated as a Lua pattern.\n * nMax       -- optional parameter specifying the maximum number (or all if `nMax` is nil) of substrings to split from `sString`.\n * bPlain     -- optional boolean parameter, defaulting to false, specifying if `sSeparator` should be treated as plain text (true) or a Lua pattern (false)\n\nReturns:\n * An array of substrings.  The last element of the array will be the remaining portion of `sString` that remains after `nMax` (or all, if `nMax` is not provided or is nil) substrings have been identified.\n\nNotes:\n * Similar to \"split\" in Perl or \"string.split\" in Python.\n * Optional parameters `nMax` and `bPlain` are identified by their type -- if parameter 3 or 4 is a number or nil, it will be considered a value for `nMax`; if parameter 3 or 4 is a boolean value, it will be considered a value for `bPlain`.\n * Lua patterns are more flexible for pattern matching, but can also be slower if the split point is simple. See \u00a76.4.1 of the _Lua_Reference_Manual_ at http://www.lua.org/manual/5.3/manual.html#6.4.1 for more information on Lua patterns."
    },
    "Gets the attributes of a file": {
        "prefix": "hs.fs.attributes(filepath [, aName]) -> table or string or nil,error",
        "body": "hs.fs.attributes(${1:filepath [}, ${2:aName]})",
        "description": "Gets the attributes of a file\n\nParameters:\n * filepath - A string containing the path of a file to inspect\n * aName - An optional attribute name. If this value is specified, only the attribute requested, is returned\n\nReturns:\n * A table with the file attributes corresponding to filepath (or nil followed by an error message in case of error). If the second optional argument is given, then a string is returned with the value of the named attribute. attribute mode is a string, all the others are numbers, and the time related attributes use the same time reference of os.time:\n  * dev - A number containing the device the file resides on\n  * ino - A number containing the inode of the file\n  * mode - A string containing the type of the file (possible values are: file, directory, link, socket, named pipe, char device, block device or other)\n  * nlink - A number containing a count of hard links to the file\n  * uid - A number containing the user-id of owner\n  * gid - A number containing the group-id of owner\n  * rdev - A number containing the type of device, for files that are char/block devices\n  * access - A number containing the time of last access modification (as seconds since the UNIX epoch)\n  * change - A number containing the time of last file status change (as seconds since the UNIX epoch)\n  * modification - A number containing the time of the last file contents change (as seconds since the UNIX epoch)\n  * permissions - A 9 character string specifying the user access permissions for the file. The first three characters represent Read/Write/Execute permissions for the file owner. The first character will be \"r\" if the user has read permissions, \"-\" if they do not; the second will be \"w\" if they have write permissions, \"-\" if they do not; the third will be \"x\" if they have execute permissions, \"-\" if they do not. The second group of three characters follow the same convention, but refer to whether or not the file's group have Read/Write/Execute permissions, and the final three characters follow the same convention, but apply to other system users not covered by the Owner or Group fields.\n  * creation - A number containing the time the file was created (as seconds since the UNIX epoch)\n  * size - A number containing the file size, in bytes\n  * blocks - A number containing the number of blocks allocated for file\n  * blksize - A number containing the optimal file system I/O blocksize\n\nNotes:\n * This function uses `stat()` internally thus if the given filepath is a symbolic link, it is followed (if it points to another link the chain is followed recursively) and the information is about the file it refers to. To obtain information about the link itself, see function `hs.fs.symlinkAttributes()`"
    },
    "Changes the current working directory to the given path.": {
        "prefix": "hs.fs.chdir(path) -> true or (nil,error)",
        "body": "hs.fs.chdir(${1:path})",
        "description": "Changes the current working directory to the given path.\n\nParameters:\n * path - A string containing the path to change working directory to\n\nReturns:\n * If successful, returns true, otherwise returns nil and an error string"
    },
    "Gets the current working directory": {
        "prefix": "hs.fs.currentDir() -> string or (nil,error)",
        "body": "hs.fs.currentDir()",
        "description": "Gets the current working directory\n\nParameters:\n * None\n\nReturns:\n * A string containing the current working directory, or if an error occured, nil and an error string"
    },
    "Creates an iterator for walking a filesystem path": {
        "prefix": "hs.fs.dir(path) -> iter_fn, dir_obj, nil, dir_obj",
        "body": "hs.fs.dir(${1:path})",
        "description": "Creates an iterator for walking a filesystem path\n\nParameters:\n * path - A string containing a directory to iterate\n\nReturns:\n * An iterator function\n * A data object to pass to the iterator function or an error message as a string\n * `nil` as the initial argument for the iterator (unused and unnecessary in this case, but conforms to Lua spec for iterators). Ignore this value if you are not using this function with `for` (see Notes).\n * A second data object used by `for` to close the directory object immediately when the loop terminates. Ignore this value if you are not using this function with `for` (see Notes).\n\nNotes:\n * Unlike most functions in this module, `hs.fs.dir` will throw a Lua error if the supplied path cannot be iterated.\n\n * The simplest way to use this function is with a `for` loop. When used in this manner, the `for` loop itself will take care of closing the directory stream for us, even if we break out of the loop early.\n   ```\n      for file in hs.fs.dir(\"/Users/Guest/Documents\") do\n          print(file)\n      end\n   ```\n\n * It is also possible to use the dir_obj directly if you wish:\n   ```\n      local iterFn, dirObj = hs.fs.dir(\"/Users/Guest/Documents\")\n      local file = dirObj:next() -- get the first file in the directory\n      while (file) do\n          print(file)\n          file = dirObj:next() -- get the next file in the directory\n      end\n      dirObj:close() -- necessary to make sure that the directory stream is closed\n   ```"
    },
    "Returns the display name of the file or directory at a specified path.": {
        "prefix": "hs.fs.displayName(filepath) -> string",
        "body": "hs.fs.displayName(${1:filepath})",
        "description": "Returns the display name of the file or directory at a specified path.\n\nParameters:\n * filepath - The path to the file or directory\n\nReturns:\n * a string containing the display name of the file or directory at a specified path; returns nil if no file with the specified path exists."
    },
    "Returns the Uniform Type Identifier for the file location specified.": {
        "prefix": "hs.fs.fileUTI(path) -> string or nil",
        "body": "hs.fs.fileUTI(${1:path})",
        "description": "Returns the Uniform Type Identifier for the file location specified.\n\nParameters:\n * path - the path to the file to return the UTI for.\n\nReturns:\n * a string containing the Uniform Type Identifier for the file location specified or nil if an error occured"
    },
    "Returns the fileUTI's equivalent form in an alternate type specification format.": {
        "prefix": "hs.fs.fileUTIalternate(fileUTI, type) -> string",
        "body": "hs.fs.${1:fileUTI}alternate(fileUTI, ${2:type})",
        "description": "Returns the fileUTI's equivalent form in an alternate type specification format.\n\nParameters:\n * a string containing a file UTI, such as one returned by `hs.fs.fileUTI`.\n * a string specifying the alternate format for the UTI.  This string may be one of the following:\n    * `extension`  - as a file extension, commonly used for platform independant file sharing when file metadata can't be guaranteed to be cross-platform compatible.  Generally considered unreliable when other file type identification methods are available.\n   * `mime`       - as a mime-type, commonly used by Internet applications like web browsers and email applications.\n   * `pasteboard` - as an NSPasteboard type (see `hs.pasteboard`).\n   * `ostype`     - four character file type, most common pre OS X, but still used in some legacy APIs.\n\nReturns:\n * the file UTI in the alternate format or nil if the UTI does not have an alternate of the specified type."
    },
    "Get the Finder comments for the file or directory at the specified path": {
        "prefix": "hs.fs.getFinderComments(path) -> string",
        "body": "hs.fs.getFinderComments(${1:path})",
        "description": "Get the Finder comments for the file or directory at the specified path\n\nParameters:\n * path - the path to the file or directory you wish to get the comments of\n\nReturns:\n * a string containing the Finder comments for the file or directory specified.  If no comments have been set for the file, returns an empty string.  If an error occurs, most commonly an invalid path, this function will throw a Lua error.\n\nNotes:\n * This function uses `hs.osascript` to access the file comments through AppleScript"
    },
    "Creates a link": {
        "prefix": "hs.fs.link(old, new[, symlink]) -> true or (nil,error)",
        "body": "hs.fs.link(${1:old}, ${2:new[}, ${3:symlink]})",
        "description": "Creates a link\n\nParameters:\n * old - A string containing a path to a filesystem object to link from\n * new - A string containing a path to create the link at\n * symlink - An optional boolean, true to create a symlink, false to create a hard link. Defaults to false\n\nReturns:\n * True if the link was created, otherwise nil and an error string"
    },
    "Locks a file, or part of it": {
        "prefix": "hs.fs.lock(filehandle, mode[, start[, length]]) -> true or (nil,error)",
        "body": "hs.fs.lock(${1:filehandle}, ${2:mode[}, ${3:start[}, ${4:length]]})",
        "description": "Locks a file, or part of it\n\nParameters:\n * filehandle - An open file\n * mode - A string containing either \"r\" for a shared read lock, or \"w\" for an exclusive write lock\n * start - An optional number containing an offset into the file to start the lock at. Defaults to 0\n * length - An optional number containing the length of the file to lock. Defaults to the full size of the file\n\nReturns:\n * True if the lock was obtained successfully, otherwise nil and an error string"
    },
    "Locks a directory": {
        "prefix": "hs.fs.lockDir(path, [seconds_stale]) -> lock or (nil,error)",
        "body": "hs.fs.lockDir(${1:path}, ${2:[seconds_stale]})",
        "description": "Locks a directory\n\nParameters:\n * path - A string containing the path to a directory\n * seconds_stale - An optional number containing an age (in seconds) beyond which to consider an existing lock as stale. Defaults to INT_MAX (which is, broadly speaking, equivalent to \"never\")\n\nReturns:\n * If successful, a lock object, otherwise nil and an error string\n\nNotes:\n * This is not a low level OS feature, the lock is actually a file created in the path, called `lockfile.lfs`, so the directory must be writable for this function to succeed\n * The returned lock object can be freed with ```lock:free()```\n * If the lock already exists and is not stale, the error string returned will be \"File exists\""
    },
    "Creates a new directory": {
        "prefix": "hs.fs.mkdir(dirname) -> true or (nil,error)",
        "body": "hs.fs.mkdir(${1:dirname})",
        "description": "Creates a new directory\n\nParameters:\n * dirname - A string containing the path of a directory to create\n\nReturns:\n * True if the directory was created, otherwise nil and an error string"
    },
    "Gets the file path from a binary encoded bookmark.": {
        "prefix": "hs.fs.pathFromBookmark(data) -> string | nil, string",
        "body": "hs.fs.pathFromBookmark(${1:data})",
        "description": "Gets the file path from a binary encoded bookmark.\n\nParameters:\n * data - The binary encoded Bookmark.\n\nReturns:\n * A string containing the path to the Bookmark URL or `nil` if an error occurs.\n * An error message if an error occurs.\n\nNotes:\n * A bookmark provides a persistent reference to a file-system resource.\n   When you resolve a bookmark, you obtain a URL to the resource\u2019s current location.\n   A bookmark\u2019s association with a file-system resource (typically a file or folder)\n   usually continues to work if the user moves or renames the resource, or if the\n   user relaunches your app or restarts the system.\n * No volumes are mounted during the resolution of the bookmark data."
    },
    "Gets the absolute path of a given path": {
        "prefix": "hs.fs.pathToAbsolute(filepath) -> string",
        "body": "hs.fs.pathToAbsolute(${1:filepath})",
        "description": "Gets the absolute path of a given path\n\nParameters:\n * filepath - Any kind of file or directory path, be it relative or not\n\nReturns:\n * A string containing the absolute path of `filepath` (i.e. one that doesn't include `.`, `..` or symlinks)\n * Note that symlinks will be resolved to their target file"
    },
    "Returns the path as binary encoded bookmark data.": {
        "prefix": "hs.fs.pathToBookmark(path) -> string | nil",
        "body": "hs.fs.${1:path}ToBookmark(path)",
        "description": "Returns the path as binary encoded bookmark data.\n\nParameters:\n * path - The path to encode\n\nReturns:\n * Bookmark data in a binary encoded string or `nil` if path is invalid."
    },
    "Removes an existing directory": {
        "prefix": "hs.fs.rmdir(dirname) -> true or (nil,error)",
        "body": "hs.fs.rmdir(${1:dirname})",
        "description": "Removes an existing directory\n\nParameters:\n * dirname - A string containing the path to a directory to remove\n\nReturns:\n * True if the directory was removed, otherwise nil and an error string"
    },
    "Set the Finder comments for the file or directory at the specified path to the comment specified": {
        "prefix": "hs.fs.setFinderComments(path, comment) -> boolean",
        "body": "hs.fs.setFinderComments(${1:path}, ${2:comment})",
        "description": "Set the Finder comments for the file or directory at the specified path to the comment specified\n\nParameters:\n * path    - the path to the file or directory you wish to set the comments of\n * comment - a string specifying the comment to set.  If this parameter is missing or is an explicit nil, the existing comment is cleared.\n\nReturns:\n * true on success; on error, most commonly an invalid path, this function will throw a Lua error.\n\nNotes:\n * This function uses `hs.osascript` to access the file comments through AppleScript"
    },
    "Gets the attributes of a symbolic link": {
        "prefix": "hs.fs.symlinkAttributes (filepath [, aname]) -> table or string or nil,error",
        "body": "hs.fs.symlinkAttributes (${1:filepath [}, ${2:aname]})",
        "description": "Gets the attributes of a symbolic link\n\nParameters:\n * filepath - A string containing the path of a link to inspect\n * aName - An optional attribute name. If this value is specified, only the attribute requested, is returned\n\nReturns:\n * A table or string if the values could be found, otherwise nil and an error string.\n\nNotes:\n * The return values for this function are identical to those provided by `hs.fs.attributes()` with the following addition: the attribute name \"target\" is added and specifies a string containing the absolute path that the symlink points to."
    },
    "Adds one or more tags to the Finder tags of a file": {
        "prefix": "hs.fs.tagsAdd(filepath, tags)",
        "body": "hs.fs.${2:tags}Add(${1:filepath}, tags)",
        "description": "Adds one or more tags to the Finder tags of a file\n\nParameters:\n * filepath - A string containing the path of a file\n * tags - A table containing one or more strings, each containing a tag name\n\nReturns:\n * true if the tags were updated; throws a lua error if an error occurs updating the tags"
    },
    "Gets the Finder tags of a file": {
        "prefix": "hs.fs.tagsGet(filepath) -> table or nil",
        "body": "hs.fs.tagsGet(${1:filepath})",
        "description": "Gets the Finder tags of a file\n\nParameters:\n * filepath - A string containing the path of a file\n\nReturns:\n * A table containing the list of the file's tags, or nil if the file has no tags assigned; throws a lua error if an error accessing the file occurs"
    },
    "Removes Finder tags from a file": {
        "prefix": "hs.fs.tagsRemove(filepath, tags)",
        "body": "hs.fs.${2:tags}Remove(${1:filepath}, tags)",
        "description": "Removes Finder tags from a file\n\nParameters:\n * filepath - A string containing the path of a file\n * tags - A table containing one or more strings, each containing a tag name\n\nReturns:\n * true if the tags were updated; throws a lua error if an error occurs updating the tags"
    },
    "Sets the Finder tags of a file, removing any that are already set": {
        "prefix": "hs.fs.tagsSet(filepath, tags)",
        "body": "hs.fs.${2:tags}Set(${1:filepath}, tags)",
        "description": "Sets the Finder tags of a file, removing any that are already set\n\nParameters:\n * filepath - A string containing the path of a file\n * tags - A table containing zero or more strings, each containing a tag name\n\nReturns:\n * true if the tags were set; throws a lua error if an error occurs setting the new tags"
    },
    "Returns the path of the temporary directory for the current user.": {
        "prefix": "hs.fs.temporaryDirectory() -> string",
        "body": "hs.fs.temporaryDirectory()",
        "description": "Returns the path of the temporary directory for the current user.\n\nParameters:\n * None\n\nReturns:\n * The path to the system designated temporary directory for the current user."
    },
    "Updates the access and modification times of a file": {
        "prefix": "hs.fs.touch(filepath [, atime [, mtime]]) -> true or (nil,error)",
        "body": "hs.fs.touch(${1:filepath [}, ${2:atime [}, ${3:mtime]]})",
        "description": "Updates the access and modification times of a file\n\nParameters:\n * filepath - A string containing the path of a file to touch\n * atime - An optional number containing the new access time of the file to set (as seconds since the Epoch). Defaults to now\n * mtime - An optional number containing the new modification time of the file to set (as seconds since the Epoch). Defaults to the value of atime\n\nReturns:\n * True if the operation was successful, otherwise nil and an error string"
    },
    "Unlocks a file or a part of it.": {
        "prefix": "hs.fs.unlock(filehandle[, start[, length]]) -> true or (nil,error)",
        "body": "hs.fs.unlock(${1:filehandle[}, ${2:start[}, ${3:length]]})",
        "description": "Unlocks a file or a part of it.\n\nParameters:\n * filehandle - An open file\n * start - An optional number containing an offset from the start of the file, to unlock. Defaults to 0\n * length - An optional number containing the length of file to unlock. Defaults to the full size of the file\n\nReturns:\n * True if the unlock succeeded, otherwise nil and an error string"
    },
    "Returns the encoded URL from a path.": {
        "prefix": "hs.fs.urlFromPath(path) -> string | nil",
        "body": "hs.fs.urlFromPath(${1:path})",
        "description": "Returns the encoded URL from a path.\n\nParameters:\n * path - The path\n\nReturns:\n * A string or `nil` if path is invalid."
    },
    "Returns a table of information about disk volumes attached to the system": {
        "prefix": "hs.host.volumeInformation([showHidden]) -> table",
        "body": "hs.host.volumeInformation(${1:[showHidden]})",
        "description": "Returns a table of information about disk volumes attached to the system\n\nParameters:\n * showHidden - An optional boolean, true to show hidden volumes, false to not show hidden volumes. Defaults to false.\n\nReturns:\n * A table of information, where the keys are the paths of disk volumes\n\nNotes:\n * The possible keys in the table are:\n  * NSURLVolumeTotalCapacityKey - Size of the volume in bytes\n  * NSURLVolumeAvailableCapacityKey - Available space on the volume in bytes\n  * NSURLVolumeIsAutomountedKey - Boolean indicating if the volume was automounted\n  * NSURLVolumeIsBrowsableKey - Boolean indicating if the volume can be browsed\n  * NSURLVolumeIsEjectableKey - Boolean indicating if the volume should be ejected before its media is removed\n  * NSURLVolumeIsInternalKey - Boolean indicating if the volume is an internal drive or an external drive\n  * NSURLVolumeIsLocalKey - Boolean indicating if the volume is a local or remote drive\n  * NSURLVolumeIsReadOnlyKey - Boolean indicating if the volume is read only\n  * NSURLVolumeIsRemovableKey - Boolean indicating if the volume's media can be physically ejected from the drive (e.g. a DVD)\n  * NSURLVolumeMaximumFileSizeKey - Maximum file size the volume can support, in bytes\n  * NSURLVolumeUUIDStringKey - The UUID of volume's filesystem\n  * NSURLVolumeURLForRemountingKey - For remote volumes, the network URL of the volume\n  * NSURLVolumeLocalizedNameKey - Localized version of the volume's name\n  * NSURLVolumeNameKey - The volume's name\n  * NSURLVolumeLocalizedFormatDescriptionKey - Localized description of the volume\n* Not all keys will be present for all volumes\n* The meanings of NSURLVolumeIsEjectableKey and NSURLVolumeIsRemovableKey are not generally what they sound like. If you want a simple test as to whether or not a volume is a removable drive (e.g. a USB hard disk), check for NSURLVolumeIsInternalKey being false (this is what Finder does)"
    },
    "A volume was mounted": {
        "prefix": "hs.fs.volume.didMount",
        "body": "hs.fs.volume.didMount",
        "description": "A volume was mounted"
    },
    "A volume changed either its name or mountpoint (or more likely, both)": {
        "prefix": "hs.fs.volume.didRename",
        "body": "hs.fs.volume.didRename",
        "description": "A volume changed either its name or mountpoint (or more likely, both)"
    },
    "A volume was unmounted": {
        "prefix": "hs.fs.volume.didUnmount",
        "body": "hs.fs.volume.didUnmount",
        "description": "A volume was unmounted"
    },
    "Unmounts and ejects a volume": {
        "prefix": "hs.fs.volume.eject(path) -> boolean,string",
        "body": "hs.fs.volume.eject(${1:path})",
        "description": "Unmounts and ejects a volume\n\nParameters:\n * path - An absolute path to the volume you wish to eject\n\nReturns:\n * A boolean, true if the volume was ejected, otherwise false\n * A string, empty if the volume was ejected, otherwise it will contain the error message"
    },
    "Creates a watcher object for volume events": {
        "prefix": "hs.fs.volume.new(fn) -> watcher",
        "body": "hs.fs.volume.new(${1:fn})",
        "description": "Creates a watcher object for volume events\n\nParameters:\n * fn - A function that will be called when volume events happen. It should accept two parameters:\n  * An event type (see the constants defined above)\n  * A table that will contain relevant information\n\nReturns:\n * An `hs.fs.volume` object"
    },
    "Starts the volume watcher": {
        "prefix": "hs.fs.volume:start()",
        "body": "hs.fs.volume:start()",
        "description": "Starts the volume watcher\n\nParameters:\n * None\n\nReturns:\n * An `hs.fs.volume` object"
    },
    "Stops the volume watcher": {
        "prefix": "hs.fs.volume:stop()",
        "body": "hs.fs.volume:stop()",
        "description": "Stops the volume watcher\n\nParameters:\n * None\n\nReturns:\n * An `hs.fs.volume` object"
    },
    "A volume is about to be unmounted": {
        "prefix": "hs.fs.volume.willUnmount",
        "body": "hs.fs.volume.willUnmount",
        "description": "A volume is about to be unmounted"
    },
    "Set the extended attribute to the value provided for the path specified.": {
        "prefix": "hs.fs.xattr.set(path, attribute, value, [options], [position]) -> boolean",
        "body": "hs.fs.xattr.set(${1:path}, ${2:attribute}, ${3:value}, ${4:[options]}, ${5:[position]})",
        "description": "Set the extended attribute to the value provided for the path specified.\n\nParameters:\n * `path`      - A string specifying the path to the file or directory to set the extended attribute for\n * `attribute` - A string specifying the name of the extended attribute to set\n * `value`     - A string containing the value to set the extended attribute to. This value is treated as a raw sequence of bytes and does not have to conform to propert UTF-8 byte sequences.\n * `options`   - An optional table containing options as described in this module's documentation header. Defaults to {} (an empty array).\n * `position`  - An optional integer specifying the offset within the extended attribute. Defaults to 0. Setting this argument to a value other than 0 is only valid when `attribute` is \"com.apple.ResourceFork\".\n\nReturns:\n * True if the operation succeeds; otherwise throws a Lua error with a description of reason for failure."
    },
    "A wrapper to [hs.fs.xattr.get](#get) which returns non UTF-8 data as a hexadecimal dump provided by `hs.utf8.hexDump`.": {
        "prefix": "hs.fs.xattr.getHumanReadable(path, attribute, [options], [position]) -> string | true | nil",
        "body": "hs.fs.xattr.getHumanReadable(${1:path}, ${2:attribute}, ${3:[options]}, ${4:[position]})",
        "description": "A wrapper to [hs.fs.xattr.get](#get) which returns non UTF-8 data as a hexadecimal dump provided by `hs.utf8.hexDump`.\n\nParameters:\n * see [hs.fs.xattr.get](#get)\n\nReturns:\n * if the returned data does not conform to proper UTF-8 byte sequences, passes the string through `hs.utf8.hexDump` first.  Otherwise the return values follow the description for [hs.fs.xattr.get](#get) .\n\nNotes:\n * This is provided for testing and debugging purposes; in general you probably want [hs.fs.xattr.get](#get) once you know how to properly understand the data returned for the attribute.\n * This is similar to the long format option in the command line `xattr` command."
    },
    "Returns a list of the extended attributes currently defined for the specified file or directory": {
        "prefix": "hs.fs.xattr.list(path, [options]) -> table",
        "body": "hs.fs.xattr.list(${1:path}, ${2:[options]})",
        "description": "Returns a list of the extended attributes currently defined for the specified file or directory\n\nParameters:\n * `path`      - A string specifying the path to the file or directory to get the list of extended attributes for\n * `options`   - An optional table containing options as described in this module's documentation header. Defaults to {} (an empty array).\n\nReturns:\n * a table containing an array of strings identifying the extended attributes currently defined for the file or directory; note that the order of the attributes is nondeterministic and is not guaranteed to be the same for future queries.  Throws a Lua error on failure with a description of the reason for the failure."
    },
    "Removes the specified extended attribute from the file or directory at the path specified.": {
        "prefix": "hs.fs.xattr.remove(path, attribute, [options]) -> boolean",
        "body": "hs.fs.xattr.remove(${1:path}, ${2:attribute}, ${3:[options]})",
        "description": "Removes the specified extended attribute from the file or directory at the path specified.\n\nParameters:\n * `path`      - A string specifying the path to the file or directory to remove the extended attribute from\n * `attribute` - A string specifying the name of the extended attribute to remove\n * `options`   - An optional table containing options as described in this module's documentation header. Defaults to {} (an empty array).\n\nReturns:\n * True if the operation succeeds; otherwise throws a Lua error with a description of reason for failure."
    },
    "Returns the angle between the positive x axis and this vector2": {
        "prefix": "hs.geometry:angle() -> number",
        "body": "hs.geometry:angle()",
        "description": "Returns the angle between the positive x axis and this vector2\n\nParameters:\n * None\n\nReturns:\n * a number represeting the angle in radians"
    },
    "Returns the angle between the positive x axis and the vector connecting this point or rect's center to another point or rect's center": {
        "prefix": "hs.geometry:angleTo(point) -> number",
        "body": "hs.geometry:angleTo(${1:point})",
        "description": "Returns the angle between the positive x axis and the vector connecting this point or rect's center to another point or rect's center\n\nParameters:\n * point - an hs.geometry object, or a table or string or parameter list to construct one; if a rect, uses the rect's center\n\nReturns:\n * a number represeting the angle in radians"
    },
    "A number representing the area of this rect or size; changing it will scale the rect/size - see `hs.geometry:scale()`": {
        "prefix": "hs.geometry.area",
        "body": "hs.geometry.area",
        "description": "A number representing the area of this rect or size; changing it will scale the rect/size - see `hs.geometry:scale()`"
    },
    "A number representing the aspect ratio of this rect or size; changing it will reshape the rect/size, keeping its area and center constant": {
        "prefix": "hs.geometry.aspect",
        "body": "hs.geometry.aspect",
        "description": "A number representing the aspect ratio of this rect or size; changing it will reshape the rect/size, keeping its area and center constant"
    },
    "Alias for `x2y2`": {
        "prefix": "hs.geometry.bottomright",
        "body": "hs.geometry.bottomright",
        "description": "Alias for `x2y2`"
    },
    "A point representing the geometric center of this rect or the midpoint of this vector2; changing it will move the rect/vector accordingly": {
        "prefix": "hs.geometry.center",
        "body": "hs.geometry.center",
        "description": "A point representing the geometric center of this rect or the midpoint of this vector2; changing it will move the rect/vector accordingly"
    },
    "Creates a copy of an hs.geometry object": {
        "prefix": "hs.geometry.copy(geom) -> hs.geometry object",
        "body": "hs.${1:geom}etry.copy(geom)",
        "description": "Creates a copy of an hs.geometry object\n\nParameters:\n * geom - an hs.geometry object to copy\n\nReturns:\n * a newly created copy of the hs.geometry object"
    },
    "Finds the distance between this point or rect's center and another point or rect's center": {
        "prefix": "hs.geometry:distance(point) -> number",
        "body": "hs.geometry:distance(${1:point})",
        "description": "Finds the distance between this point or rect's center and another point or rect's center\n\nParameters:\n * point - an hs.geometry object, or a table or string or parameter list to construct one; if a rect, uses the rect's center\n\nReturns:\n * a number indicating the distance"
    },
    "Checks if two geometry objects are equal": {
        "prefix": "hs.geometry:equals(other) -> boolean",
        "body": "hs.geometry:equals(${1:other})",
        "description": "Checks if two geometry objects are equal\n\nParameters:\n * other - another hs.geometry object, or a table or string or parameter list to construct one\n\nReturns:\n * `true` if this hs.geometry object perfectly overlaps other, `false` otherwise"
    },
    "Ensure this rect is fully inside `bounds`, by scaling it down if it's larger (preserving its aspect ratio) and moving it if necessary": {
        "prefix": "hs.geometry:fit(bounds) -> hs.geometry object",
        "body": "hs.geometry:fit(${1:bounds})",
        "description": "Ensure this rect is fully inside `bounds`, by scaling it down if it's larger (preserving its aspect ratio) and moving it if necessary\n\nParameters:\n * bounds - an hs.geometry rect object, or a table or string or parameter list to construct one, indicating the rect that\n   must fully contain this rect\n\nReturns:\n * this hs.geometry object for method chaining"
    },
    "Truncates all coordinates in this object to integers": {
        "prefix": "hs.geometry:floor() -> hs.geometry object",
        "body": "hs.geometry:floor()",
        "description": "Truncates all coordinates in this object to integers\n\nParameters:\n * None\n\nReturns:\n * this hs.geometry point for method chaining"
    },
    "Converts a unit rect within a given frame into a rect": {
        "prefix": "hs.geometry:fromUnitRect(frame) -> hs.geometry rect",
        "body": "hs.geometry:fromUnitRect(${1:frame})",
        "description": "Converts a unit rect within a given frame into a rect\n\nParameters:\n * frame - an hs.geometry rect (with `w` and `h` >0)\n\nReturns:\n * An hs.geometry rect object"
    },
    "The height of this rect or size; changing it will keep the rect's x,y corner constant": {
        "prefix": "hs.geometry.h",
        "body": "hs.geometry.h",
        "description": "The height of this rect or size; changing it will keep the rect's x,y corner constant"
    },
    "Checks if this hs.geometry object lies fully inside a given rect": {
        "prefix": "hs.geometry:inside(rect) -> boolean",
        "body": "hs.geometry:inside(${1:rect})",
        "description": "Checks if this hs.geometry object lies fully inside a given rect\n\nParameters:\n * rect - an hs.geometry rect, or a table or string or parameter list to construct one\n\nReturns:\n * `true` if this point/rect lies fully inside the given rect, `false` otherwise"
    },
    "Returns the intersection rect between this rect and another rect": {
        "prefix": "hs.geometry:intersect(rect) -> hs.geometry rect",
        "body": "hs.geometry:intersect(${1:rect})",
        "description": "Returns the intersection rect between this rect and another rect\n\nParameters:\n * rect - an hs.geometry rect, or a table or string or parameter list to construct one\n\nReturns:\n * a new hs.geometry rect\n\nNotes:\n * If the two rects don't intersect, the result rect will be a \"projection\" of the second rect onto this rect's\n   closest edge or corner along the x or y axis; the `w` and/or `h` fields in the result rect will be 0."
    },
    "A number representing the length of the diagonal of this rect, or the length of this vector2; changing it will scale the rect/vector - see `hs.geometry:scale()`": {
        "prefix": "hs.geometry.length",
        "body": "hs.geometry.length",
        "description": "A number representing the length of the diagonal of this rect, or the length of this vector2; changing it will scale the rect/vector - see `hs.geometry:scale()`"
    },
    "Moves this point/rect": {
        "prefix": "hs.geometry:move(point) -> hs.geometry object",
        "body": "hs.geometry:move(${1:point})",
        "description": "Moves this point/rect\n\nParameters:\n * point - an hs.geometry object, or a table or string or parameter list to construct one, indicating the x and y displacement to apply\n\nReturns:\n * this hs.geometry object for method chaining"
    },
    "Creates a new hs.geometry object": {
        "prefix": "hs.geometry.new(...) -> hs.geometry object",
        "body": "hs.geometry.new(${1:...})",
        "description": "Creates a new hs.geometry object\n\nParameters: see the module description at the top\n\nReturns:\n * a newly created hs.geometry object"
    },
    "Normalizes this vector2": {
        "prefix": "hs.geometry:normalize() -> point",
        "body": "hs.geometry:normalize()",
        "description": "Normalizes this vector2\n\nParameters:\n * None\n\nReturns:\n * this hs.geometry point for method chaining"
    },
    "Convenience function for creating a point object": {
        "prefix": "hs.geometry.point(x, y) -> hs.geometry point",
        "body": "hs.geometr${2:y}.point(${1:x}, y)",
        "description": "Convenience function for creating a point object\n\nParameters:\n * x - A number containing the horizontal co-ordinate of the point\n * y - A number containing the vertical co-ordinate of the point\n\nReturns:\n * An hs.geometry point object"
    },
    "Convenience function for creating a rect-table": {
        "prefix": "hs.geometry.rect(x, y, w, h) -> hs.geometry rect",
        "body": "${4:h}s.geometr${2:y}.rect(${1:x}, y, ${3:w}, h)",
        "description": "Convenience function for creating a rect-table\n\nParameters:\n * x - A number containing the horizontal co-ordinate of the top-left point of the rect\n * y - A number containing the vertical co-ordinate of the top-left point of the rect\n * w - A number containing the width of the rect\n * h - A number containing the height of the rect\n\nReturns:\n * An hs.geometry rect object"
    },
    "Rotates a point around another point N times": {
        "prefix": "hs.geometry:rotateCCW(aroundpoint, ntimes) -> hs.geometry point",
        "body": "hs.geometry:rotateCCW(${1:aroundpoint}, ${2:ntimes})",
        "description": "Rotates a point around another point N times\n\nParameters:\n * aroundpoint - an hs.geometry point to rotate this point around\n * ntimes - the number of times to rotate, defaults to 1\n\nReturns:\n * A new hs.geometry point containing the location of the rotated point"
    },
    "Scales this vector2/size, or this rect *keeping its center constant*": {
        "prefix": "hs.geometry:scale(size) -> hs.geometry object",
        "body": "hs.geometry:scale(${1:size})",
        "description": "Scales this vector2/size, or this rect *keeping its center constant*\n\nParameters:\n * size - an hs.geometry object, or a table or string or parameter list to construct one, indicating the factors for scaling this rect's width and height;\n   if a number, the rect will be scaled by the same factor in both axes\n\nReturns:\n * this hs.geometry object for method chaining"
    },
    "Convenience function for creating a size object": {
        "prefix": "hs.geometry.size(w, h) -> hs.geometry size",
        "body": "${2:h}s.geometry.size(${1:w}, h)",
        "description": "Convenience function for creating a size object\n\nParameters:\n * w - A number containing a width\n * h - A number containing a height\n\nReturns:\n * An hs.geometry size object"
    },
    "The `\"X,Y/WxH\"` string for this hs.geometry object (*reduced precision*); useful e.g. for logging": {
        "prefix": "hs.geometry.string",
        "body": "hs.geometry.string",
        "description": "The `\"X,Y/WxH\"` string for this hs.geometry object (*reduced precision*); useful e.g. for logging"
    },
    "The `{x=X,y=Y,w=W,h=H}` table for this hs.geometry object; useful e.g. for serialization/deserialization": {
        "prefix": "hs.geometry.table",
        "body": "hs.geometry.table",
        "description": "The `{x=X,y=Y,w=W,h=H}` table for this hs.geometry object; useful e.g. for serialization/deserialization"
    },
    "Alias for `xy`": {
        "prefix": "hs.geometry.topleft",
        "body": "hs.geometry.topleft",
        "description": "Alias for `xy`"
    },
    "Converts a rect into its unit rect within a given frame": {
        "prefix": "hs.geometry:toUnitRect(frame) -> hs.geometry unit rect",
        "body": "hs.geometry:toUnitRect(${1:frame})",
        "description": "Converts a rect into its unit rect within a given frame\n\nParameters:\n * frame - an hs.geometry rect (with `w` and `h` >0)\n\nReturns:\n * An hs.geometry unit rect object\n\nNotes:\n * The resulting unit rect is always clipped within `frame`'s bounds (via `hs.geometry:intersect()`); if `frame`\n   does not encompass this rect *no error will be thrown*, but the resulting unit rect won't be a direct match with this rect\n   (i.e. calling `:fromUnitRect(frame)` on it will return a different rect)"
    },
    "Returns the type of an hs.geometry object": {
        "prefix": "hs.geometry:type() -> string",
        "body": "hs.geometry:type()",
        "description": "Returns the type of an hs.geometry object\n\nParameters:\n * None\n\nReturns:\n * a string describing the type of this hs.geometry object, i.e. 'point', 'size', 'rect' or 'unitrect'; `nil` if not a valid object"
    },
    "Returns the smallest rect that encloses both this rect and another rect": {
        "prefix": "hs.geometry:union(rect) -> hs.geometry rect",
        "body": "hs.geometry:union(${1:rect})",
        "description": "Returns the smallest rect that encloses both this rect and another rect\n\nParameters:\n * rect - an hs.geometry rect, or a table or string or parameter list to construct one\n\nReturns:\n * a new hs.geometry rect"
    },
    "Returns the vector2 from this point or rect's center to another point or rect's center": {
        "prefix": "hs.geometry:vector(point) -> point",
        "body": "hs.geometry:vector(${1:point})",
        "description": "Returns the vector2 from this point or rect's center to another point or rect's center\n\nParameters:\n * point - an hs.geometry object, or a table or string or parameter list to construct one; if a rect, uses the rect's center\n\nReturns:\n * an hs.geometry point"
    },
    "The width of this rect or size; changing it will keep the rect's x,y corner constant": {
        "prefix": "hs.geometry.w",
        "body": "hs.geometry.w",
        "description": "The width of this rect or size; changing it will keep the rect's x,y corner constant"
    },
    "The size component for this hs.geometry object; setting this to a new size will keep the rect's x,y corner constant": {
        "prefix": "hs.geometry.wh",
        "body": "hs.geometry.wh",
        "description": "The size component for this hs.geometry object; setting this to a new size will keep the rect's x,y corner constant"
    },
    "The x coordinate for this point or rect's corner; changing it will move the rect but keep the same width and height": {
        "prefix": "hs.geometry.x",
        "body": "hs.geometry.x",
        "description": "The x coordinate for this point or rect's corner; changing it will move the rect but keep the same width and height"
    },
    "Alias for `x`": {
        "prefix": "hs.geometry.x1",
        "body": "hs.geometry.x1",
        "description": "Alias for `x`"
    },
    "The x coordinate for the second corner of this rect; changing it will affect the rect's width": {
        "prefix": "hs.geometry.x2",
        "body": "hs.geometry.x2",
        "description": "The x coordinate for the second corner of this rect; changing it will affect the rect's width"
    },
    "The point denoting the other corner of this hs.geometry object; setting this to a new point will change the rect's width and height": {
        "prefix": "hs.geometry.x2y2",
        "body": "hs.geometry.x2y2",
        "description": "The point denoting the other corner of this hs.geometry object; setting this to a new point will change the rect's width and height"
    },
    "The point component for this hs.geometry object; setting this to a new point will move the rect but keep the same width and height": {
        "prefix": "hs.geometry.xy",
        "body": "hs.geometry.xy",
        "description": "The point component for this hs.geometry object; setting this to a new point will move the rect but keep the same width and height"
    },
    "The y coordinate for this point or rect's corner; changing it will move the rect but keep the same width and height": {
        "prefix": "hs.geometry.y",
        "body": "hs.geometry.y",
        "description": "The y coordinate for this point or rect's corner; changing it will move the rect but keep the same width and height"
    },
    "Alias for `y`": {
        "prefix": "hs.geometry.y1",
        "body": "hs.geometry.y1",
        "description": "Alias for `y`"
    },
    "The y coordinate for the second corner of this rect; changing it will affect the rect's height": {
        "prefix": "hs.geometry.y2",
        "body": "hs.geometry.y2",
        "description": "The y coordinate for the second corner of this rect; changing it will affect the rect's height"
    },
    "Calls a user specified function to adjust a window's cell": {
        "prefix": "hs.grid.adjustWindow(fn, window) -> hs.grid",
        "body": "hs.grid.adjustWindow(${1:fn}, ${2:window})",
        "description": "Calls a user specified function to adjust a window's cell\n\nParameters:\n * fn - a function that accepts a cell object as its only argument. The function should modify it as needed and return nothing\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining"
    },
    "Gets the cell describing a window": {
        "prefix": "hs.grid.get(win) -> cell",
        "body": "hs.grid.get(${1:win})",
        "description": "Gets the cell describing a window\n\nParameters:\n* an `hs.window` object to get the cell of\n\nReturns:\n* a cell object (i.e. an `hs.geometry` rect), or nil if an error occurred"
    },
    "Gets the `hs.geometry` rect for a cell on a particular screen": {
        "prefix": "hs.grid.getCell(cell, screen) -> hs.geometry",
        "body": "hs.grid.getCell(${1:cell}, ${2:screen})",
        "description": "Gets the `hs.geometry` rect for a cell on a particular screen\n\nParameters:\n * cell - a cell object, i.e. an `hs.geometry` rect or argument to construct one\n * screen - an `hs.screen` object or argument to `hs.screen.find()` where the cell is located\n\nReturns:\n * the `hs.geometry` rect for a cell on a particular screen or nil if the screen isn't found"
    },
    "Gets the defined grid size for a given screen or screen resolution": {
        "prefix": "hs.grid.getGrid(screen) -> hs.geometry size",
        "body": "hs.grid.getGrid(${1:screen})",
        "description": "Gets the defined grid size for a given screen or screen resolution\n\nParameters:\n * screen - an `hs.screen` object, or a valid argument to `hs.screen.find()`, indicating the screen to get the grid of;\n   if omitted or nil, gets the default grid, which is used when no specific grid is found for any given screen/resolution\n\nReturns:\n  * an `hs.geometry` size object indicating the number of columns and rows in the grid\n\nNotes:\n  * if a grid was not set for the specified screen or geometry, the default grid will be returned\n\nUsage:\nlocal mygrid = hs.grid.getGrid('1920x1080') -- gets the defined grid for all screens with a 1920x1080 resolution\nlocal defgrid=hs.grid.getGrid() defgrid.w=defgrid.w+2 -- increases the number of columns in the default grid by 2"
    },
    "Gets the defined grid frame for a given screen or screen resolution.": {
        "prefix": "hs.grid.getGridFrame(screen) -> hs.geometry rect",
        "body": "hs.grid.getGridFrame(${1:screen})",
        "description": "Gets the defined grid frame for a given screen or screen resolution.\n\nParameters:\n * screen - an `hs.screen` object, or a valid argument to `hs.screen.find()`, indicating the screen to get the grid frame of\n\nReturns:\n  * an `hs.geometry` rect object indicating the frame used by the grid for the given screen; if no custom frame\n    was given via `hs.grid.setGrid()`, returns the screen's frame"
    },
    "Hides the grid, if visible, and exits the modal resizing mode.": {
        "prefix": "hs.grid.hide()",
        "body": "hs.grid.hide()",
        "description": "Hides the grid, if visible, and exits the modal resizing mode.\nCall this function if you need to make sure the modal is exited without waiting for the user to press `esc`.\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * If an exit callback was provided when invoking the modal interface, calling `.hide()` will call it"
    },
    "A bidimensional array (table of tables of strings) holding the keyboard hints (as per `hs.keycodes.map`) to be used for the interactive resizing interface.": {
        "prefix": "hs.grid.HINTS",
        "body": "hs.grid.HINTS",
        "description": "A bidimensional array (table of tables of strings) holding the keyboard hints (as per `hs.keycodes.map`) to be used for the interactive resizing interface.\nChange this if you don't use a QWERTY layout; you need to provide 5 valid rows of hints (even if you're not going to use all 5 rows)\n\nDefault `HINTS` is an array to 5 rows and 10 columns.\n\nNotes:\n * `hs.inspect(hs.grid.HINTS)` from the console will show you how the table is built\n * `hs.grid.show()`\n    When displaying interactive grid, if gird dimensions (`hs.grid.setGrid()`) are greater than `HINTS` dimensions,\n    then Hammerspoon merges few cells such that interactive grid dimensions do not exceed `HINTS` dimensions.\n    This is done to make sure interactive grid cells do not run out of hints. The interactive grid ends up with\n    cells of varying height and width.\n    The actual grid is not affected. If you use API methods like `hs.grid.pushWindowDown()`, you will not face this\n    issue at all.\n    If you have a grid of higher dimensions and require an interactive gird that accurately models underlying grid\n    then set `HINTS` variable to a table that has same dimensions as your grid.\n    Following is an example of grid that has 16 columns\n\n```\nhs.grid.setGrid('16x4')\nhs.grid.HINTS={\n    {'f1', 'f2' , 'f3' , 'f4' , 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12', 'f13', 'f14', 'f15', 'f16'},\n    {'1' , 'f11', 'f15', 'f19', 'f3', '=' , ']' , '2' , '3' , '4'  , '5'  , '6'  , '7'  , '8'  , '9'  , '0'  },\n    {'Q' , 'f12', 'f16', 'f20', 'f4', '-' , '[' , 'W' , 'E' , 'R'  , 'T'  , 'Y'  , 'U'  , 'I'  , 'O'  , 'P'  },\n    {'A' , 'f13', 'f17', 'f1' , 'f5', 'f7', '\\\\', 'S' , 'D' , 'F'  , 'G'  , 'H'  , 'J'  , 'K'  , 'L'  , ','  },\n    {'X' , 'f14', 'f18', 'f2' , 'f6', 'f8', ';' , '/' , '.' , 'Z'  , 'X'  , 'C'  , 'V'  , 'B'  , 'N'  , 'M'  }\n}\n```\n"
    },
    "Moves and resizes a window to fill the entire grid": {
        "prefix": "hs.grid.maximizeWindow(window) -> hs.grid",
        "body": "hs.grid.maximizeWindow(${1:window})",
        "description": "Moves and resizes a window to fill the entire grid\n\nParameters:\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining"
    },
    "Moves a window one grid cell down the screen, or onto the adjacent screen's grid when necessary": {
        "prefix": "hs.grid.pushWindowDown(window) -> hs.grid",
        "body": "hs.grid.pushWindowDown(${1:window})",
        "description": "Moves a window one grid cell down the screen, or onto the adjacent screen's grid when necessary\n\nParameters:\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining"
    },
    "Moves a window one grid cell to the left, or onto the adjacent screen's grid when necessary": {
        "prefix": "hs.grid.pushWindowLeft(window) -> hs.grid",
        "body": "hs.grid.pushWindowLeft(${1:window})",
        "description": "Moves a window one grid cell to the left, or onto the adjacent screen's grid when necessary\n\nParameters:\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining"
    },
    "Moves a window one cell to the right, or onto the adjacent screen's grid when necessary": {
        "prefix": "hs.grid.pushWindowRight(window) -> hs.grid",
        "body": "hs.grid.pushWindowRight(${1:window})",
        "description": "Moves a window one cell to the right, or onto the adjacent screen's grid when necessary\n\nParameters:\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining"
    },
    "Moves a window one grid cell up the screen, or onto the adjacent screen's grid when necessary": {
        "prefix": "hs.grid.pushWindowUp(window) -> hs.grid",
        "body": "hs.grid.pushWindowUp(${1:window})",
        "description": "Moves a window one grid cell up the screen, or onto the adjacent screen's grid when necessary\n\nParameters:\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining"
    },
    "Resizes a window so its bottom edge moves one grid cell higher": {
        "prefix": "hs.grid.resizeWindowShorter(window) -> hs.grid",
        "body": "hs.grid.resizeWindowShorter(${1:window})",
        "description": "Resizes a window so its bottom edge moves one grid cell higher\n\nParameters:\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining"
    },
    "Resizes a window so its bottom edge moves one grid cell lower": {
        "prefix": "hs.grid.resizeWindowTaller(window) -> hs.grid",
        "body": "hs.grid.resizeWindowTaller(${1:window})",
        "description": "Resizes a window so its bottom edge moves one grid cell lower\n\nParameters:\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining\n\nNotes:\n * if the window hits the bottom edge of the screen and is asked to become taller, its top edge will shift further up"
    },
    "Resizes a window to be one cell thinner": {
        "prefix": "hs.grid.resizeWindowThinner(window) -> hs.grid",
        "body": "hs.grid.resizeWindowThinner(${1:window})",
        "description": "Resizes a window to be one cell thinner\n\nParameters:\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining"
    },
    "Resizes a window to be one cell wider": {
        "prefix": "hs.grid.resizeWindowWider(window) -> hs.grid",
        "body": "hs.grid.resizeWindowWider(${1:window})",
        "description": "Resizes a window to be one cell wider\n\nParameters:\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining\n\nNotes:\n * if the window hits the right edge of the screen and is asked to become wider, its left edge will shift further left"
    },
    "Sets the cell for a window on a particular screen": {
        "prefix": "hs.grid.set(win, cell, screen) -> hs.grid",
        "body": "hs.grid.set(${1:win}, ${2:cell}, ${3:screen})",
        "description": "Sets the cell for a window on a particular screen\n\nParameters:\n * win - an `hs.window` object representing the window to operate on\n * cell - a cell object, i.e. an `hs.geometry` rect or argument to construct one, to apply to the window\n * screen - (optional) an `hs.screen` object or argument to `hs.screen.find()` representing the screen to place the window on; if omitted\n   the window's current screen will be used\n\nReturns:\n * the `hs.grid` module for method chaining"
    },
    "Sets the grid size for a given screen or screen resolution": {
        "prefix": "hs.grid.setGrid(grid,screen,frame) -> hs.grid",
        "body": "hs.${1:grid}.setGrid(grid,${2:screen},${3:frame})",
        "description": "Sets the grid size for a given screen or screen resolution\n\nParameters:\n * grid - an `hs.geometry` size, or argument to construct one, indicating the number of columns and rows for the grid\n * screen - an `hs.screen` object, or a valid argument to `hs.screen.find()`, indicating the screen(s) to apply the grid to;\n   if omitted or nil, sets the default grid, which is used when no specific grid is found for any given screen/resolution\n * frame - an `hs.geometry` rect object indicating the frame that the grid will occupy for the given screen;\n   if omitted or nil, the screen's `:frame()` will be used; use this argument if you want e.g. to leave\n   a strip of the desktop unoccluded when using GeekTool or similar. The `screen` argument *must* be non-nil when setting a\n   custom grid frame.\n\nReturns:\n  * the `hs.grid` module for method chaining\n\nUsage:\nhs.grid.setGrid('5x3','Color LCD') -- sets the grid to 5x3 for any screen named \"Color LCD\"\nhs.grid.setGrid('8x5','1920x1080') -- sets the grid to 8x5 for all screens with a 1920x1080 resolution\nhs.grid.setGrid'4x4' -- sets the default grid to 4x4"
    },
    "Sets the margins between windows": {
        "prefix": "hs.grid.setMargins(margins) -> hs.grid",
        "body": "hs.grid.setMargins(${1:margins})",
        "description": "Sets the margins between windows\n\nParameters:\n * margins - an `hs.geometry` point or size, or argument to construct one, indicating the desired margins between windows in screen points\n\nReturns:\n  * the `hs.grid` module for method chaining"
    },
    "Shows the grid and starts the modal interactive resizing process for the focused or frontmost window.": {
        "prefix": "hs.grid.show([exitedCallback][, multipleWindows])",
        "body": "hs.grid.show(${1:[exitedCallback][}, ${2:multipleWindows]})",
        "description": "Shows the grid and starts the modal interactive resizing process for the focused or frontmost window.\nIn most cases this function should be invoked via `hs.hotkey.bind` with some keyboard shortcut.\n\nParameters:\n * exitedCallback - (optional) a function that will be called after the user dismisses the modal interface\n * multipleWindows - (optional) if `true`, the resizing grid won't automatically go away after selecting the desired cells\n   for the frontmost window; instead, it'll switch to the next window\n\nReturns:\n * None\n\nNotes:\n * In the modal interface, press the arrow keys to jump to adjacent screens; spacebar to maximize/unmaximize; esc to quit without any effect\n * Pressing `tab` or `shift-tab` in the modal interface will cycle to the next or previous window; if `multipleWindows`\n   is false or omitted, the first press will just enable the multiple windows behaviour\n * The keyboard hints assume a QWERTY layout; if you use a different layout, change `hs.grid.HINTS` accordingly\n * If grid dimensions are greater than 10x10 then you may have to change `hs.grid.HINTS` depending on your\n   requirements. See note in `HINTS`."
    },
    "Snaps a window into alignment with the nearest grid lines": {
        "prefix": "hs.grid.snap(win) -> hs.grid",
        "body": "hs.grid.snap(${1:win})",
        "description": "Snaps a window into alignment with the nearest grid lines\n\nParameters:\n * win - an `hs.window` object to snap\n\nReturns:\n * the `hs.grid` module for method chaining"
    },
    "Toggles the grid and modal resizing mode - see `hs.grid.show()` and `hs.grid.hide()`": {
        "prefix": "hs.grid.toggleShow([exitedCallback][, multipleWindows])",
        "body": "hs.grid.toggleShow(${1:[exitedCallback][}, ${2:multipleWindows]})",
        "description": "Toggles the grid and modal resizing mode - see `hs.grid.show()` and `hs.grid.hide()`\n\nParameters: see `hs.grid.show()`\n\nReturns:\n * None"
    },
    "Allows customization of the modal resizing grid user interface": {
        "prefix": "hs.grid.ui",
        "body": "hs.grid.ui",
        "description": "Allows customization of the modal resizing grid user interface\n\nThis table contains variables that you can change to customize the look of the modal resizing grid.\nThe default values are shown in the right hand side of the assignements below.\n\nTo represent color values, you can use:\n * a table {red=redN, green=greenN, blue=blueN, alpha=alphaN}\n * a table {redN,greenN,blueN[,alphaN]} - if omitted alphaN defaults to 1.0\nwhere redN, greenN etc. are the desired value for the color component between 0.0 and 1.0\n\nThe following variables must be color values:\n * `hs.grid.ui.textColor = {1,1,1}`\n * `hs.grid.ui.cellColor = {0,0,0,0.25}`\n * `hs.grid.ui.cellStrokeColor = {0,0,0}`\n * `hs.grid.ui.selectedColor = {0.2,0.7,0,0.4}` -- for the first selected cell during a modal resize\n * `hs.grid.ui.highlightColor = {0.8,0.8,0,0.5}` -- to highlight the frontmost window behind the grid\n * `hs.grid.ui.highlightStrokeColor = {0.8,0.8,0,1}`\n * `hs.grid.ui.cyclingHighlightColor = {0,0.8,0.8,0.5}` -- to highlight the window to be resized, when cycling among windows\n * `hs.grid.ui.cyclingHighlightStrokeColor = {0,0.8,0.8,1}`\n\nThe following variables must be numbers (in screen points):\n * `hs.grid.ui.textSize = 200`\n * `hs.grid.ui.cellStrokeWidth = 5`\n * `hs.grid.ui.highlightStrokeWidth = 30`\n\nThe following variables must be strings:\n * `hs.grid.ui.fontName = 'Lucida Grande'`\n\nThe following variables must be booleans:\n * `hs.grid.ui.showExtraKeys = true` -- show non-grid keybindings in the center of the grid"
    },
    "Calculates an HMAC using a key and an MD5 hash": {
        "prefix": "hs.hash.hmacMD5(key, data) -> string",
        "body": "hs.hash.hmacMD5(${1:key}, ${2:data})",
        "description": "Calculates an HMAC using a key and an MD5 hash\n\nParameters:\n * key - A string containing a secret key to use\n * data - A string containing the data to hash\n\nReturns:\n * A string containing the hash of the supplied data"
    },
    "Calculates an HMAC using a key and a SHA1 hash": {
        "prefix": "hs.hash.hmacSHA1(key, data) -> string",
        "body": "hs.hash.hmacSHA1(${1:key}, ${2:data})",
        "description": "Calculates an HMAC using a key and a SHA1 hash\n\nParameters:\n * key - A string containing a secret key to use\n * data - A string containing the data to hash\n\nReturns:\n * A string containing the hash of the supplied data"
    },
    "Calculates an HMAC using a key and a SHA256 hash": {
        "prefix": "hs.hash.hmacSHA256(key, data) -> string",
        "body": "hs.hash.hmacSHA256(${1:key}, ${2:data})",
        "description": "Calculates an HMAC using a key and a SHA256 hash\n\nParameters:\n * key - A string containing a secret key to use\n * data - A string containing the data to hash\n\nReturns:\n * A string containing the hash of the supplied data"
    },
    "Calculates an HMAC using a key and a SHA512 hash": {
        "prefix": "hs.hash.hmacSHA512(key, data) -> string",
        "body": "hs.hash.hmacSHA512(${1:key}, ${2:data})",
        "description": "Calculates an HMAC using a key and a SHA512 hash\n\nParameters:\n * key - A string containing a secret key to use\n * data - A string containing the data to hash\n\nReturns:\n * A string containing the hash of the supplied data"
    },
    "Calculates an MD5 hash": {
        "prefix": "hs.hash.MD5(data) -> string",
        "body": "hs.hash.MD5(${1:data})",
        "description": "Calculates an MD5 hash\n\nParameters:\n * data - A string containing some data to hash\n\nReturns:\n * A string containing the hash of the supplied data"
    },
    "Calculates an SHA1 hash": {
        "prefix": "hs.hash.SHA1(data) -> string",
        "body": "hs.hash.SHA1(${1:data})",
        "description": "Calculates an SHA1 hash\n\nParameters:\n * data - A string containing some data to hash\n\nReturns:\n * A string containing the hash of the supplied data"
    },
    "Calculates an SHA256 hash": {
        "prefix": "hs.hash.SHA256(data) -> string",
        "body": "hs.hash.SHA256(${1:data})",
        "description": "Calculates an SHA256 hash\n\nParameters:\n * data - A string containing some data to hash\n\nReturns:\n * A string containing the hash of the supplied data"
    },
    "Calculates an SHA512 hash": {
        "prefix": "hs.hash.SHA512(data) -> string",
        "body": "hs.hash.SHA512(${1:data})",
        "description": "Calculates an SHA512 hash\n\nParameters:\n * data - A string containing some data to hash\n\nReturns:\n * A string containing the hash of the supplied data"
    },
    "Checks the state of the caps lock via HID": {
        "prefix": "hs.hid.capslock.get() -> bool",
        "body": "hs.hid.capslock.get()",
        "description": "Checks the state of the caps lock via HID\n\nReturns:\n * true if on, false if off"
    },
    "Assigns capslock to the desired state": {
        "prefix": "hs.hid.capslock.set(state) -> bool",
        "body": "hs.hid.capslock.set(${1:state})",
        "description": "Assigns capslock to the desired state\n\nParameters:\n * state - A boolean indicating desired state\n\nReturns:\n * true if on, false if off"
    },
    "Toggles the state of caps lock via HID": {
        "prefix": "hs.hid.capslock.toggle() -> bool",
        "body": "hs.hid.capslock.toggle()",
        "description": "Toggles the state of caps lock via HID\n\nReturns:\n * true if on, false if off"
    },
    "Assigns HID LED to the desired state": {
        "prefix": "hs.hid.led.set(name, state) -> bool",
        "body": "hs.hid.led.set(${1:name}, ${2:state})",
        "description": "Assigns HID LED to the desired state\nNote that this function controls the LED state only,\nto modify capslock state, use hs.hid.capslock.set\n\nParameters:\n * name  - LED name: \"caps\", \"scroll\" or \"num\"\n * state - A boolean indicating desired state\n\nReturns:\n * true if success, false if error"
    },
    "A fully specified family-face name, preferrably the PostScript name, such as Helvetica-BoldOblique or Times-Roman. (The Font Book app displays PostScript names of fonts in the Font Info panel.)": {
        "prefix": "hs.hints.fontName",
        "body": "hs.hints.fontName",
        "description": "A fully specified family-face name, preferrably the PostScript name, such as Helvetica-BoldOblique or Times-Roman. (The Font Book app displays PostScript names of fonts in the Font Info panel.)\nThe default value is the system font"
    },
    "The size of font that should be used. A value of 0.0 will use the default size.": {
        "prefix": "hs.hints.fontSize",
        "body": "hs.hints.fontSize",
        "description": "The size of font that should be used. A value of 0.0 will use the default size."
    },
    "This controls the set of characters that will be used for window hints. They must be characters found in hs.keycodes.map": {
        "prefix": "hs.hints.hintChars",
        "body": "hs.hints.hintChars",
        "description": "This controls the set of characters that will be used for window hints. They must be characters found in hs.keycodes.map\nThe default is the letters A-Z. Note that if `hs.hints.style` is set to \"vimperator\", this variable will be ignored."
    },
    "Opacity of the application icon. Default is 0.95.": {
        "prefix": "hs.hints.iconAlpha",
        "body": "hs.hints.iconAlpha",
        "description": "Opacity of the application icon. Default is 0.95."
    },
    "If there are less than or equal to this many windows on screen their titles will be shown in the hints.": {
        "prefix": "hs.hints.showTitleThresh",
        "body": "hs.hints.showTitleThresh",
        "description": "If there are less than or equal to this many windows on screen their titles will be shown in the hints.\nThe default is 4. Setting to 0 will disable this feature."
    },
    "If this is set to \"vimperator\", every window hint starts with the first character": {
        "prefix": "hs.hints.style",
        "body": "hs.hints.style",
        "description": "If this is set to \"vimperator\", every window hint starts with the first character\nof the parent application's title"
    },
    "If the title is longer than maxSize, the string is truncated, -1 to disable, valid value is >= 6": {
        "prefix": "hs.hints.titleMaxSize",
        "body": "hs.hints.titleMaxSize",
        "description": "If the title is longer than maxSize, the string is truncated, -1 to disable, valid value is >= 6"
    },
    "Displays a keyboard hint for switching focus to each window": {
        "prefix": "hs.hints.windowHints([windows, callback, allowNonStandard])",
        "body": "hs.hints.windowHints(${1:[windows}, ${2:callback}, ${3:allowNonStandard]})",
        "description": "Displays a keyboard hint for switching focus to each window\n\nParameters:\n * windows - An optional table containing some `hs.window` objects. If this value is nil, all windows will be hinted\n * callback - An optional function that will be called when a window has been selected by the user. The function will be called with a single argument containing the `hs.window` object of the window chosen by the user\n * allowNonStandard - An optional boolean.  If true, all windows will be included, not just standard windows\n\nReturns:\n * None\n\nNotes:\n * If there are more windows open than there are characters available in hs.hints.hintChars, multiple characters will be used\n * If hints.style is set to \"vimperator\", every window hint is prefixed with the first character of the parent application's name\n * To display hints only for the currently focused application, try something like:\n  * `hs.hints.windowHints(hs.window.focusedWindow():application():allWindows())`"
    },
    "Gets a list of network addresses for the current machine": {
        "prefix": "hs.host.addresses() -> table",
        "body": "hs.host.addresses()",
        "description": "Gets a list of network addresses for the current machine\n\nParameters:\n * None\n\nReturns:\n * A table of strings containing the network addresses of the current machine\n\nNotes:\n * The results will include IPv4 and IPv6 addresses"
    },
    "Query CPU usage statistics for a given time interval using [hs.host.cpuUsageTicks](#cpuUsageTicks) and return the results as percentages.": {
        "prefix": "hs.host.cpuUsage([period], [callback]) -> table",
        "body": "hs.host.cpuUsage(${1:[period]}, ${2:[callback]})",
        "description": "Query CPU usage statistics for a given time interval using [hs.host.cpuUsageTicks](#cpuUsageTicks) and return the results as percentages.\n\nParameters:\n * `period`    - an optional value specifying the time between samples collected for calculating CPU usage statistics.\n   * If `callback` is not provided, this is an optional integer, default 100000, specifying the number of microseconds to block between samples collected.  Note that Hammerspoon will block for this period of time during execution of this function.\n   * If `callback` is provided, this is an optional number, default 1.0, specifying the number of seconds between samples collected.  Hammerspoon will *not* block during this time period.\n * `callback` - an optional callback function which will receive the cpu usage statistics in a table, described below, as its sole argument.\n\nReturns:\n * If a callback function is not provided, this function will return a table containing the following:\n   * Individual tables, indexed by the core number, for each CPU core with the following keys in each subtable:\n     * user   -- percentage of CPU time occupied by user level processes.\n     * system -- percentage of CPU time occupied by system (kernel) level processes.\n     * nice   -- percentage of CPU time occupied by user level processes with a positive nice value. (See notes below)\n     * active -- For convenience, when you just want the total CPU usage, this is the sum of user, system, and nice.\n     * idle   -- percentage of CPU time spent idle\n   * The key `overall` containing the same keys as described above but based upon the average of all cores combined.\n   * The key `n` containing the number of cores detected.\n * If a callback function is provided, this function will return a placeholder table with the following metamethods:\n   * `hs.host.cpuUsage:finished()` - returns a boolean indicating if the second CPU sample has been collected yet (true) or not (false).\n   * `hs.host.cpuUsage:stop()`     - abort the sample collection.  The callback function will not be invoked.\n   * The results of the cpu statistics will be submitted as a table, described above, to the callback function.\n\nNotes:\n * If no callback function is provided, Hammerspoon will block (i.e. no other Hammerspoon activity can occur) during execution of this function for `period` microseconds (1 second = 1,000,000 microseconds).  The default period is 1/10 of a second. If `period` is too small, it is possible that some of the CPU statistics may result in `nan` (not-a-number).\n\n * For reference, the `top` command has a default period between samples of 1 second.\n\n * The subtables for each core and `overall` have a __tostring() metamethod which allows listing it's contents in the Hammerspoon console by typing `hs.host.cpuUsage()[#]` where # is the core you are interested in or the string \"overall\"."
    },
    "Returns a table containing the current cpu usage information for the system in `ticks` since the most recent system boot.": {
        "prefix": "hs.host.cpuUsageTicks() -> table",
        "body": "hs.host.cpuUsageTicks()",
        "description": "Returns a table containing the current cpu usage information for the system in `ticks` since the most recent system boot.\n\nParameters:\n * None\n\nReturns:\n * A table containing the following:\n   * Individual tables, indexed by the core number, for each CPU core with the following keys in each subtable:\n     * user   -- number of ticks the cpu core has spent in user mode since system startup.\n     * system -- number of ticks the cpu core has spent in system mode since system startup.\n     * nice   \n     * active -- For convenience, when you just want the total CPU usage, this is the sum of user, system, and nice.\n     * idle   -- number of ticks the cpu core has spent idle\n   * The key `overall` containing the same keys as described above but based upon the combined total of all cpu cores for the system.\n   * The key `n` containing the number of cores detected.\n\nNotes:\n * CPU mode ticks are updated during system interrupts and are incremented based upon the mode the CPU is in at the time of the interrupt. By its nature, this is always going to be approximate, and a single call to this function will return the current tick values since the system was last rebooted.\n * To generate a snapshot of the system's usage \"at this moment\", you must take two samples and calculate the difference between them.  The [hs.host.cpuUsage](#cpuUsage) function is a wrapper which does this for you and returns the cpu usage statistics as a percentage of the total number of ticks which occurred during the sample period you specify when invoking `hs.host.cpuUsage`.\n\n * Historically on Unix based systems, the `nice` cpu state represents processes for which the execution priority has been reduced to allow other higher priority processes access to more system resources.  The source code for the version of the [XNU Kernel](https://opensource.apple.com/source/xnu/xnu-3789.41.3/) currently provided by Apple (for macOS 10.12.3) shows this value as returned by the `host_processor_info` as hardcoded to 0.  For completeness, this value *is* included in the statistics returned by this function, but unless Apple makes a change in the future, it is not expected to provide any useful information.\n\n * Adapted primarily from code found at http://stackoverflow.com/questions/6785069/get-cpu-percent-usage"
    },
    "Returns a newly generated global unique identifier as a string": {
        "prefix": "hs.host.globallyUniqueString() -> string",
        "body": "hs.host.globallyUniqueString()",
        "description": "Returns a newly generated global unique identifier as a string\n\nParameters:\n * None\n\nReturns:\n * a newly generated global unique identifier as a string\n\nNotes:\n * See also `hs.host.uuid`\n * The global unique identifier for a process includes the host name, process ID, and a time stamp, which ensures that the ID is unique for the network. This property generates a new string each time it is invoked, and it uses a counter to guarantee that strings are unique.\n * This is often used as a file or directory name in conjunction with `hs.host.temporaryDirectory()` when creating temporary files."
    },
    "Returns the model and VRAM size for the installed GPUs.": {
        "prefix": "hs.host.gpuVRAM() -> table",
        "body": "hs.host.gpuVRAM()",
        "description": "Returns the model and VRAM size for the installed GPUs.\n\nParameters:\n * None\n\nReturns:\n * A table whose key-value pairs represent the GPUs for the current system.  Each key is a string contining the name for an installed GPU and its value is the GPU's VRAM size in MB.  If the VRAM size cannot be determined for a specific GPU, its value will be -1.0.\n\nNotes:\n * If your GPU reports -1.0 as the memory size, please submit an issue to the Hammerspoon github repository and include any information that you can which may be relevant, such as: Macintosh model, macOS version, is the GPU built in or a third party expansion card, the GPU model and VRAM as best you can determine (see the System Information application in the Utilities folder and look at the Graphics/Display section) and anything else that you think might be important."
    },
    "Returns the number of seconds the computer has been idle.": {
        "prefix": "hs.host.idleTime() -> seconds",
        "body": "hs.host.idleTime()",
        "description": "Returns the number of seconds the computer has been idle.\n\nParameters:\n * None\n\nReturns:\n * the idle time in seconds\n\nNotes:\n * Idle time is defined as no mouse move nor keyboard entry, etc. and is determined by querying the HID (Human Interface Device) subsystem.\n * This code is directly inspired by code found at http://www.xs-labs.com/en/archives/articles/iokit-idle-time"
    },
    "Returns the OS X interface style for the current user.": {
        "prefix": "hs.host.interfaceStyle() -> string",
        "body": "hs.host.interfaceStyle()",
        "description": "Returns the OS X interface style for the current user.\n\nParameters:\n * None\n\nReturns:\n * A string representing the current user interface style, or nil if the default style is in use.\n\nNotes:\n * As of OS X 10.10.4, other than the default style, only \"Dark\" is recognized as a valid style."
    },
    "Gets the name of the current machine, as displayed in the Finder sidebar": {
        "prefix": "hs.host.localizedName() -> string",
        "body": "hs.host.localizedName()",
        "description": "Gets the name of the current machine, as displayed in the Finder sidebar\n\nParameters:\n * None\n\nReturns:\n * A string containing the name of the current machine"
    },
    "Gets a list of network names for the current machine": {
        "prefix": "hs.host.names() -> table",
        "body": "hs.host.names()",
        "description": "Gets a list of network names for the current machine\n\nParameters:\n * None\n\nReturns:\n * A table of strings containing the network names of the current machine\n\nNotes:\n * This function should be used sparingly, as it may involve blocking network access to resolve hostnames"
    },
    "The operating system version as a table containing the major, minor, and patch numbers.": {
        "prefix": "hs.host.operatingSystemVersion() -> table",
        "body": "hs.host.operatingSystemVersion()",
        "description": "The operating system version as a table containing the major, minor, and patch numbers.\n\nParameters:\n * None\n\nReturns:\n * The operating system version as a table containing the keys major, minor, and patch corresponding to the version number determined and a key named \"exact\" or \"approximation\" depending upon the method used to determine the OS Version information.\n\nNotes:\n * Prior to 10.10 (Yosemite), there was no definitive way to reliably get an exact OS X version number without either mapping it to the Darwin kernel version, mapping it to the AppKitVersionNumber (the recommended method), or parsing the result of NSProcessingInfo's `operatingSystemVersionString` selector, which Apple states is not guaranteed to be reliably parseable.\n   * for OS X versions prior to 10.10, the version number is approximately determined by evaluating the AppKitVersionNumber.  For these operating systems, the `approximate` key is defined and set to true, as the exact patch level cannot be definitively determined.\n   * for OS X Versions starting at 10.10 and going forward, an exact value for the version number can be determined with NSProcessingInfo's `operatingSystemVersion` selector and the `exact` key is defined and set to true if this method is used."
    },
    "The operating system version as a human readable string.": {
        "prefix": "hs.host.operatingSystemVersionString() -> string",
        "body": "hs.host.operatingSystemVersionString()",
        "description": "The operating system version as a human readable string.\n\nParameters:\n * None\n\nReturns:\n * The operating system version as a human readable string.\n\nNotes:\n * According to the OS X Developer documentation, \"The operating system version string is human readable, localized, and is appropriate for displaying to the user. This string is not appropriate for parsing.\""
    },
    "The current thermal state of the computer, as a human readable string": {
        "prefix": "hs.host.thermalState() -> string",
        "body": "hs.host.thermalState()",
        "description": "The current thermal state of the computer, as a human readable string\n\nParameters:\n * None\n\nReturns:\n * The system's thermal state as a human readable string"
    },
    "Returns a newly generated UUID as a string": {
        "prefix": "hs.host.uuid() -> string",
        "body": "hs.host.uuid()",
        "description": "Returns a newly generated UUID as a string\n\nParameters:\n * None\n\nReturns:\n * a newly generated UUID as a string\n\nNotes:\n * See also `hs.host.globallyUniqueString`\n * UUIDs (Universally Unique Identifiers), also known as GUIDs (Globally Unique Identifiers) or IIDs (Interface Identifiers), are 128-bit values. UUIDs created by NSUUID conform to RFC 4122 version 4 and are created with random bytes."
    },
    "Returns a table containing virtual memory statistics for the current machine, as well as the page size (in bytes) and physical memory size (in bytes).": {
        "prefix": "hs.host.vmStat() -> table",
        "body": "hs.host.vmStat()",
        "description": "Returns a table containing virtual memory statistics for the current machine, as well as the page size (in bytes) and physical memory size (in bytes).\n\nParameters:\n * None\n\nReturns:\n * A table containing the following keys:\n   * anonymousPages          -- the total number of pages that are anonymous\n   * cacheHits               -- number of object cache hits\n   * cacheLookups            -- number of object cache lookups\n   * fileBackedPages         -- the total number of pages that are file-backed (non-swap)\n   * memSize                 -- physical memory size in bytes\n   * pageIns                 -- the total number of requests for pages from a pager (such as the inode pager).\n   * pageOuts                -- the total number of pages that have been paged out.\n   * pageSize                -- page size in bytes\n   * pagesActive             -- the total number of pages currently in use and pageable.\n   * pagesCompressed         -- the total number of pages that have been compressed by the VM compressor.\n   * pagesCopyOnWrite        -- the number of faults that caused a page to be copied (generally caused by copy-on-write faults).\n   * pagesDecompressed       -- the total number of pages that have been decompressed by the VM compressor.\n   * pagesFree               -- the total number of free pages in the system.\n   * pagesInactive           -- the total number of pages on the inactive list.\n   * pagesPurgeable          -- the total number of purgeable pages.\n   * pagesPurged             -- the total number of pages that have been purged.\n   * pagesReactivated        -- the total number of pages that have been moved from the inactive list to the active list (reactivated).\n   * pagesSpeculative        -- the total number of pages on the speculative list.\n   * pagesThrottled          -- the total number of pages on the throttled list (not wired but not pageable).\n   * pagesUsedByVMCompressor -- the number of pages used to store compressed VM pages.\n   * pagesWiredDown          -- the total number of pages wired down. That is, pages that cannot be paged out.\n   * pagesZeroFilled         -- the total number of pages that have been zero-filled on demand.\n   * swapIns                 -- the total number of compressed pages that have been swapped out to disk.\n   * swapOuts                -- the total number of compressed pages that have been swapped back in from disk.\n   * translationFaults       -- the number of times the \"vm_fault\" routine has been called.\n   * uncompressedPages       -- the total number of pages (uncompressed) held within the compressor\n\nNotes:\n * The table returned has a __tostring() metamethod which allows listing it's contents in the Hammerspoon console by typing `hs.host.vmStats()`.\n * Except for the addition of cacheHits, cacheLookups, pageSize and memSize, the results for this function should be identical to the OS X command `vm_stat`.\n * Adapted primarily from the source code to Apple's vm_stat command located at http://www.opensource.apple.com/source/system_cmds/system_cmds-643.1.1/vm_stat.tproj/vm_stat.c"
    },
    "Returns an array table containing the identifiers for the locales available on the system.": {
        "prefix": "hs.host.locale.availableLocales() -> table",
        "body": "hs.host.locale.availableLocales()",
        "description": "Returns an array table containing the identifiers for the locales available on the system.\n\nParameters:\n * None\n\nReturns:\n * an array table of strings specifying the locale identifiers recognized by this system.\n\nNotes:\n * these values can be used with [hs.host.locale.details](#details) to get details for a specific locale."
    },
    "Returns an string specifying the user's currently selected locale identifier.": {
        "prefix": "hs.host.locale.current() -> string",
        "body": "hs.host.locale.current()",
        "description": "Returns an string specifying the user's currently selected locale identifier.\n\nParameters:\n * None\n\nReturns:\n * a string specifying the identifier of the user's currently selected locale.\n\nNotes:\n * this value can be used with [hs.host.locale.details](#details) to get details for the returned locale."
    },
    "Returns a table containing information about the current or specified locale.": {
        "prefix": "hs.host.locale.details([identifier]) -> table",
        "body": "hs.host.locale.details(${1:[identifier]})",
        "description": "Returns a table containing information about the current or specified locale.\n\nParameters:\n * `identifier` - an optional string, specifying the locale to display information about.  If you do not specify an identifier, information about the user's currently selected locale is returned.\n\nReturns:\n * a table containing one or more of the following key-value pairs:\n   * `alternateQuotationBeginDelimiterKey` - A string containing the alternating begin quotation symbol associated with the locale. In some locales, when quotations are nested, the quotation characters alternate.\n   * `alternateQuotationEndDelimiterKey`   - A string containing the alternate end quotation symbol associated with the locale. In some locales, when quotations are nested, the quotation characters alternate.\n   * `calendar`                            - A table containing key-value pairs describing for calendar associated with the locale. The table will contain one or more of the following pairs:\n     * `AMSymbol`                          - The AM symbol for time in the locale's calendar.\n     * `calendarIdentifier`                - A string representing the calendar identity.\n     * `eraSymbols`                        - An array table of strings specifying the names of the eras as recognized in the locale's calendar.\n     * `firstWeekday`                      - The index in `weekdaySymbols` of the first weekday in the locale's calendar.\n     * `longEraSymbols`                    - An array table of strings specifying long names of the eras as recognized in the locale's calendar.\n     * `minimumDaysInFirstWeek`            - The minimum number of days, an integer value, in the first week in the locale's calendar.\n     * `monthSymbols`                      - An array table of strings for the months of the year in the locale's calendar.\n     * `PMSymbol`                          - The PM symbol for time in the locale's calendar.\n     * `quarterSymbols`                    - An array table of strings for the quarters of the year in the locale's calendar.\n     * `shortMonthSymbols`                 - An array table of short strings for the months of the year in the locale's calendar.\n     * `shortQuarterSymbols`               - An array table of short strings for the quarters of the year in the locale's calendar.\n     * `shortStandaloneMonthSymbols`       - An array table of short standalone strings for the months of the year in the locale's calendar.\n     * `shortStandaloneQuarterSymbols`     - An array table of short standalone strings for the quarters of the year in the locale's calendar.\n     * `shortStandaloneWeekdaySymbols`     - An array table of short standalone strings for the days of the week in the locale's calendar.\n     * `shortWeekdaySymbols`               - An array table of short strings for the days of the week in the locale's calendar.\n     * `standaloneMonthSymbols`            - An array table of standalone strings for the months of the year in the locale's calendar.\n     * `standaloneQuarterSymbols`          - An array table of standalone strings for the quarters of the year in the locale's calendar.\n     * `standaloneWeekdaySymbols`          - An array table of standalone strings for the days of the week in the locale's calendar.\n     * `veryShortMonthSymbols`             - An array table of very short strings for the months of the year in the locale's calendar.\n     * `veryShortStandaloneMonthSymbols`   - An array table of very short standalone strings for the months of the year in the locale's calendar.\n     * `veryShortStandaloneWeekdaySymbols` - An array table of very short standalone strings for the days of the week in the locale's calendar.\n     * `veryShortWeekdaySymbols`           - An array table of very short strings for the days of the week in the locale's calendar.\n     * `weekdaySymbols`                    - An array table of strings for the days of the week in the locale's calendar.\n   * `collationIdentifier`                 - A string containing the collation associated with the locale.\n   * `collatorIdentifier`                  - A string containing the collation identifier for the locale.\n   * `countryCode`                         - A string containing the locale country code.\n   * `currencyCode`                        - A string containing the currency code associated with the locale.\n   * `currencySymbol`                      - A string containing the currency symbol associated with the locale.\n   * `decimalSeparator`                    - A string containing the decimal separator associated with the locale.\n   * `exemplarCharacterSet`                - An array table of strings which make up the exemplar character set for the locale.\n   * `groupingSeparator`                   - A string containing the numeric grouping separator associated with the locale.\n   * `identifier`                          - A string containing the locale identifier.\n   * `languageCode`                        - A string containing the locale language code.\n   * `measurementSystem`                   - A string containing the measurement system associated with the locale.\n   * `quotationBeginDelimiterKey`          - A string containing the begin quotation symbol associated with the locale.\n   * `quotationEndDelimiterKey`            - A string containing the end quotation symbol associated with the locale.\n   * `scriptCode`                          - A string containing the locale script code.\n   * `temperatureUnit`                     - A string containing the preferred measurement system for temperature.\n   * `timeFormatIs24Hour`                  - A boolean specifying whether time is expressed in a 24 hour format (true) or 12 hour format (false).\n   * `usesMetricSystem`                    - A boolean specifying whether or not the locale uses the metric system.\n   * `variantCode`                         - A string containing the locale variant code.\n\nNotes:\n * If you specify a locale identifier as an argument, it should be based on one of the strings returned by [hs.host.locale.availableLocales](#availableLocales). Use of an arbitrary string may produce unreliable or inconsistent results.\n\n * Apple does not provide a documented method for retrieving the users preferences with respect to `temperatureUnit` or `timeFormatIs24Hour`. The methods used to determine these values are based on code from the following sources:\n   * `temperatureUnit`    - http://stackoverflow.com/a/41263725\n   * `timeFormatIs24Hour` - http://stackoverflow.com/a/1972487\n * If you are able to identify additional locale or regional settings that are not provided by this function and have a source which describes a reliable method to retrieve this information, please submit an issue at https://github.com/Hammerspoon/hammerspoon with the details."
    },
    "Returns the localized string for a specific language code.": {
        "prefix": "hs.host.locale.localizedString(localeCode[, baseLocaleCode]) -> string | nil, string | nil",
        "body": "hs.host.locale.localizedString(${1:localeCode[}, ${2:baseLocaleCode]})",
        "description": "Returns the localized string for a specific language code.\n\nParameters:\n * `localeCode` - The locale code for the locale you want to return the localized string of.\n * `baseLocaleCode` - An optional string, specifying the locale to use for the string. If you do not specify a `baseLocaleCode`, the user's currently selected locale is used.\n\nReturns:\n * A string containing the localized string or `nil ` if either the `localeCode` or `baseLocaleCode` is invalid. For example, if the `localeCode` is \"de_CH\", this will return \"German\".\n * A string containing the localized string including the dialect or `nil ` if either the `localeCode` or `baseLocaleCode` is invalid. For example, if the `localeCode` is \"de_CH\", this will return \"German (Switzerland)\".\n\nNotes:\n * The `localeCode` and optional `baseLocaleCode` must be one of the strings returned by [hs.host.locale.availableLocales](#availableLocales)."
    },
    "Returns the user's language preference order as an array of strings.": {
        "prefix": "hs.host.locale.preferredLanguages() -> table",
        "body": "hs.host.locale.preferredLanguages()",
        "description": "Returns the user's language preference order as an array of strings.\n\nParameters:\n * None\n\nReturns:\n * an array table of strings specifying the user's preferred languages as string identifiers."
    },
    "Registers a function to be invoked when anything in the user's locale settings change": {
        "prefix": "hs.host.locale.registerCallback(function) -> uuidString",
        "body": "hs.host.locale.registerCallback(${1:function})",
        "description": "Registers a function to be invoked when anything in the user's locale settings change\n\nParameters:\n * `fn` - the function to be invoked when a setting changes\n\nReturns:\n * a uuid string which can be used to unregister a callback function when you no longer require notification of changes\n\nNotes:\n * The callback function will not receive any arguments and should return none.  You can retrieve the new locale settings with [hs.host.locale.localeInformation](#localeInformation) and check its keys to determine if the change is of interest.\n\n * Any change made within the Language and Region settings panel will trigger this callback, even changes which are not reflected in the locale information provided by [hs.host.locale.localeInformation](#localeInformation)."
    },
    "Unregister a callback function when you no longer care about changes to the user's locale": {
        "prefix": "hs.host.locale.unregisterCallback(uuidString) -> boolean",
        "body": "hs.host.locale.unregisterCallback(${1:uuidString})",
        "description": "Unregister a callback function when you no longer care about changes to the user's locale\n\nParameters:\n * `uuidString` - the uuidString returned by [hs.host.locale.registerCallback](#registerCallback) when you registered the callback function\n\nReturns:\n * true if the callback was successfully unregistered or false if it was not, usually because the uuidString does not correspond to a current callback function."
    },
    "Duration of the alert shown when a hotkey created with a `message` parameter is triggered, in seconds. Default is 1.": {
        "prefix": "hs.hotkey.alertDuration",
        "body": "hs.hotkey.alertDuration",
        "description": "Duration of the alert shown when a hotkey created with a `message` parameter is triggered, in seconds. Default is 1.\n\nUsage:\nhs.hotkey.alertDuration = 2.5 -- alert stays on screen a bit longer\nhs.hotkey.alertDuration = 0 -- hotkey alerts are disabled"
    },
    "Determines whether the hotkey combination can be assigned a callback through Hammerspoon.": {
        "prefix": "hs.hotkey.assignable(mods, key) -> boolean",
        "body": "hs.hot${2:key}.assignable(${1:mods}, key)",
        "description": "Determines whether the hotkey combination can be assigned a callback through Hammerspoon.\n\nParameters:\n * mods - A table or a string containing (as elements, or as substrings with any separator) the keyboard modifiers required,\n   which should be zero or more of the following:\n   * \"cmd\", \"command\" or \"\u2318\"\n   * \"ctrl\", \"control\" or \"\u2303\"\n   * \"alt\", \"option\" or \"\u2325\"\n   * \"shift\" or \"\u21e7\"\n * key - A string containing the name of a keyboard key (as found in [hs.keycodes.map](hs.keycodes.html#map) ), or a raw keycode number\n\nReturns:\n * a boolean value, true if the hotkey combination can be given an assignment by Hammerspoon or false if it cannot.\n\nNotes:\n * The most common reason a hotkey combination cannot be given an assignment by Hammerspoon is because it is in use by the Mac operating system -- see the Shortcuts tab of Keyboard in the System Preferences application or [hs.hotkey.systemAssigned](#systemAssigned)."
    },
    "Creates a new hotkey and enables it immediately": {
        "prefix": "hs.hotkey.bind(mods, key, [message,] pressedfn, releasedfn, repeatfn) -> hs.hotkey object",
        "body": "hs.hot${2:key}.bind(${1:mods}, key, ${3:[message},${4:] pressedfn}, ${5:releasedfn}, ${6:repeatfn})",
        "description": "Creates a new hotkey and enables it immediately\n\nParameters:\n * mods - A table or a string containing (as elements, or as substrings with any separator) the keyboard modifiers required,\n   which should be zero or more of the following:\n   * \"cmd\", \"command\" or \"\u2318\"\n   * \"ctrl\", \"control\" or \"\u2303\"\n   * \"alt\", \"option\" or \"\u2325\"\n   * \"shift\" or \"\u21e7\"\n * key - A string containing the name of a keyboard key (as found in [hs.keycodes.map](hs.keycodes.html#map) ), or a raw keycode number\n * message - (optional) A string containing a message to be displayed via `hs.alert()` when the hotkey has been\n   triggered; if omitted, no alert will be shown\n * pressedfn - A function that will be called when the hotkey has been pressed, or nil\n * releasedfn - A function that will be called when the hotkey has been released, or nil\n * repeatfn - A function that will be called when a pressed hotkey is repeating, or nil\n\nReturns:\n * A new `hs.hotkey` object or nil if the hotkey could not be enabled\n\nNotes:\n * This function is just a wrapper that performs `hs.hotkey.new(...):enable()`\n * You can create multiple `hs.hotkey` objects for the same keyboard combination, but only one can be active\n   at any given time - see `hs.hotkey:enable()`\n * If `message` is the empty string `\"\"`, the alert will just show the triggered keyboard combination\n * If you don't want any alert, you must *actually* omit the `message` parameter; a `nil` in 3rd position\n   will be interpreted as a missing `pressedfn`\n * You must pass at least one of `pressedfn`, `releasedfn` or `repeatfn`; to delete a hotkey, use `hs.hotkey:delete()`"
    },
    "Creates a hotkey and enables it immediately": {
        "prefix": "hs.hotkey.bindSpec(keyspec, ...) -> hs.hotkey object",
        "body": "hs.hotkey.bindSpec(${1:keyspec}, ${2:...})",
        "description": "Creates a hotkey and enables it immediately\n\nParameters:\n * keyspec - A table containing two items:\n  * first, a table containing keyboard modifiers, as specified in `hs.hotkey.bind()`\n  * second, a string containing the name of a keyboard key, as specified in `hs.hotkey.bind()`\n * ... - All remaining arguments are as specified in `hs.hotkey.bind()`\n\nReturns:\n * A new `hs.hotkey` object for method chaining\n\nNotes:\n * This function is just a wrapper that performs `hs.hotkey.bind(keyspec[1], keyspec[2], ...)`"
    },
    "Disables and deletes a hotkey object": {
        "prefix": "hs.hotkey:delete()",
        "body": "hs.hotkey:delete()",
        "description": "Disables and deletes a hotkey object\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Deletes all previously set callbacks for a given keyboard combination": {
        "prefix": "hs.hotkey.deleteAll(mods, key)",
        "body": "hs.hot${2:key}.deleteAll(${1:mods}, key)",
        "description": "Deletes all previously set callbacks for a given keyboard combination\n\nParameters:\n * mods - A table or a string containing (as elements, or as substrings with any separator) the keyboard modifiers required,\n   which should be zero or more of the following:\n   * \"cmd\", \"command\" or \"\u2318\"\n   * \"ctrl\", \"control\" or \"\u2303\"\n   * \"alt\", \"option\" or \"\u2325\"\n   * \"shift\" or \"\u21e7\"\n * key - A string containing the name of a keyboard key (as found in [hs.keycodes.map](hs.keycodes.html#map) ), or a raw keycode number\n\nReturns:\n * None"
    },
    "Disables a hotkey object": {
        "prefix": "hs.hotkey:disable() -> hs.hotkey object",
        "body": "hs.hotkey:disable()",
        "description": "Disables a hotkey object\n\nParameters:\n * None\n\nReturns:\n * The `hs.hotkey` object for method chaining"
    },
    "Disables all previously set callbacks for a given keyboard combination": {
        "prefix": "hs.hotkey.disableAll(mods, key)",
        "body": "hs.hot${2:key}.disableAll(${1:mods}, key)",
        "description": "Disables all previously set callbacks for a given keyboard combination\n\nParameters:\n * mods - A table or a string containing (as elements, or as substrings with any separator) the keyboard modifiers required,\n   which should be zero or more of the following:\n   * \"cmd\", \"command\" or \"\u2318\"\n   * \"ctrl\", \"control\" or \"\u2303\"\n   * \"alt\", \"option\" or \"\u2325\"\n   * \"shift\" or \"\u21e7\"\n * key - A string containing the name of a keyboard key (as found in [hs.keycodes.map](hs.keycodes.html#map) ), or a raw keycode number\n\nReturns:\n * None"
    },
    "Enables a hotkey object": {
        "prefix": "hs.hotkey:enable() -> hs.hotkey object | nil",
        "body": "hs.hotkey:enable()",
        "description": "Enables a hotkey object\n\nParameters:\n * None\n\nReturns:\n * The `hs.hotkey` object for method chaining or nil if the hotkey could not be enabled for some reason.\n\nNotes:\n * When you enable a hotkey that uses the same keyboard combination as another previously-enabled hotkey, the old\n   one will stop working as it's being \"shadowed\" by the new one. As soon as the new hotkey is disabled or deleted\n   the old one will trigger again."
    },
    "Returns a list of all currently active hotkeys": {
        "prefix": "hs.hotkey.getHotkeys() -> table",
        "body": "hs.hotkey.getHotkeys()",
        "description": "Returns a list of all currently active hotkeys\n\nParameters:\n * None\n\nReturns:\n * A table containing the hotkeys that are active, i.e. enabled and not \"shadowed\", in the current context\n   (usually, the global hotkey context, but it could be a modal hotkey context). Every element in the list\n   is a table with two fields:\n   * idx - a string describing the keyboard combination for the hotkey\n   * msg - the hotkey message, if provided when the hotkey was created (prefixed with the keyboard combination)"
    },
    "Creates a new hotkey": {
        "prefix": "hs.hotkey.new(mods, key, [message,] pressedfn, releasedfn, repeatfn) -> hs.hotkey object",
        "body": "hs.hot${2:key}.new(${1:mods}, key, ${3:[message},${4:] pressedfn}, ${5:releasedfn}, ${6:repeatfn})",
        "description": "Creates a new hotkey\n\nParameters:\n * mods - A table or a string containing (as elements, or as substrings with any separator) the keyboard modifiers required,\n   which should be zero or more of the following:\n   * \"cmd\", \"command\" or \"\u2318\"\n   * \"ctrl\", \"control\" or \"\u2303\"\n   * \"alt\", \"option\" or \"\u2325\"\n   * \"shift\" or \"\u21e7\"\n * key - A string containing the name of a keyboard key (as found in [hs.keycodes.map](hs.keycodes.html#map) ), or a raw keycode number\n * message - (optional) A string containing a message to be displayed via `hs.alert()` when the hotkey has been\n   triggered; if omitted, no alert will be shown\n * pressedfn - A function that will be called when the hotkey has been pressed, or nil\n * releasedfn - A function that will be called when the hotkey has been released, or nil\n * repeatfn - A function that will be called when a pressed hotkey is repeating, or nil\n\nReturns:\n * A new `hs.hotkey` object or nil if the hotkey could not be enabled\n\nNotes:\n * You can create multiple `hs.hotkey` objects for the same keyboard combination, but only one can be active\n   at any given time - see `hs.hotkey:enable()`\n * If `message` is the empty string `\"\"`, the alert will just show the triggered keyboard combination\n * If you don't want any alert, you must *actually* omit the `message` parameter; a `nil` in 3rd position\n   will be interpreted as a missing `pressedfn`\n * You must pass at least one of `pressedfn`, `releasedfn` or `repeatfn`; to delete a hotkey, use `hs.hotkey:delete()`"
    },
    "Creates (and enables) a hotkey that shows all currently active hotkeys (i.e. enabled and not \"shadowed\"": {
        "prefix": "hs.hotkey.showHotkeys(mods, key) -> hs.hotkey object",
        "body": "hs.hot${2:key}.showHotkeys(${1:mods}, key)",
        "description": "Creates (and enables) a hotkey that shows all currently active hotkeys (i.e. enabled and not \"shadowed\"\nin the current context) while pressed\n\nParameters:\n * mods - A table or a string containing (as elements, or as substrings with any separator) the keyboard modifiers required,\n   which should be zero or more of the following:\n   * \"cmd\", \"command\" or \"\u2318\"\n   * \"ctrl\", \"control\" or \"\u2303\"\n   * \"alt\", \"option\" or \"\u2325\"\n   * \"shift\" or \"\u21e7\"\n * key - A string containing the name of a keyboard key (as found in [hs.keycodes.map](hs.keycodes.html#map) ), or a raw keycode number\n\nReturns:\n * The new `hs.hotkey` object"
    },
    "Examine whether a potential hotkey is in use by the macOS system such as the Screen Capture, Universal Access, and Keyboard Navigation keys.": {
        "prefix": "hs.hotkey.systemAssigned(mods, key) -> table | false",
        "body": "hs.hot${2:key}.systemAssigned(${1:mods}, key)",
        "description": "Examine whether a potential hotkey is in use by the macOS system such as the Screen Capture, Universal Access, and Keyboard Navigation keys.\n\nParameters:\n * mods - A table or a string containing (as elements, or as substrings with any separator) the keyboard modifiers required,\n   which should be zero or more of the following:\n   * \"cmd\", \"command\" or \"\u2318\"\n   * \"ctrl\", \"control\" or \"\u2303\"\n   * \"alt\", \"option\" or \"\u2325\"\n   * \"shift\" or \"\u21e7\"\n * key - A string containing the name of a keyboard key (as found in [hs.keycodes.map](hs.keycodes.html#map) ), or a raw keycode number\n\nReturns:\n * if the hotkey combination is in use by a system function, returns a table containing the following keys:\n   * keycode - the numberic keycode for the hotkey\n   * mods    - a numeric representation of the modifier flags for the htokey\n   * enabled - a boolean indicating whether or not the key is currently enabled\n * if the hotkey combination is not in use by the operating system, returns the boolean value `false`\n\nNotes:\n * this is provided for informational purposes and does not provide a reliable test as to whether or not Hammerspoon can use the combination to create a custom hotkey -- some combinations which return a table can be over-ridden by Hammerspoon while others cannot.  See also [hs.hotkey.assignable](#assignable)."
    },
    "Creates a hotkey that is enabled/disabled as the modal is entered/exited": {
        "prefix": "hs.hotkey.modal:bind(mods, key, message, pressedfn, releasedfn, repeatfn) -> hs.hotkey.modal object",
        "body": "hs.hot${2:key}.modal:bind(${1:mods}, key, ${3:message}, ${4:pressedfn}, ${5:releasedfn}, ${6:repeatfn})",
        "description": "Creates a hotkey that is enabled/disabled as the modal is entered/exited\n\nParameters:\n * mods - A table or a string containing (as elements, or as substrings with any separator) the keyboard modifiers required,\n   which should be zero or more of the following:\n   * \"cmd\", \"command\" or \"\u2318\"\n   * \"ctrl\", \"control\" or \"\u2303\"\n   * \"alt\", \"option\" or \"\u2325\"\n   * \"shift\" or \"\u21e7\"\n * key - A string containing the name of a keyboard key (as found in [hs.keycodes.map](hs.keycodes.html#map) ), or a raw keycode number\n * message - A string containing a message to be displayed via `hs.alert()` when the hotkey has been triggered, or nil for no alert\n * pressedfn - A function that will be called when the hotkey has been pressed, or nil\n * releasedfn - A function that will be called when the hotkey has been released, or nil\n * repeatfn - A function that will be called when a pressed hotkey is repeating, or nil\n\nReturns:\n * The `hs.hotkey.modal` object for method chaining"
    },
    "Deletes a modal hotkey object without calling :exited()": {
        "prefix": "hs.hotkey.modal:delete()",
        "body": "hs.hotkey.modal:delete()",
        "description": "Deletes a modal hotkey object without calling :exited()\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Enters a modal state": {
        "prefix": "hs.hotkey.modal:enter() -> hs.hotkey.modal object",
        "body": "hs.hotkey.modal:enter()",
        "description": "Enters a modal state\n\nParameters:\n * None\n\nReturns:\n * The `hs.hotkey.modal` object for method chaining\n\nNotes:\n * This method will enable all of the hotkeys defined in the modal state via `hs.hotkey.modal:bind()`,\n   and disable the hotkey that entered the modal state (if one was defined)\n * If the modal state was created with a keyboard combination, this method will be called automatically"
    },
    "Optional callback for when a modal is entered": {
        "prefix": "hs.hotkey.modal:entered()",
        "body": "hs.hotkey.modal:entered()",
        "description": "Optional callback for when a modal is entered\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This is a pre-existing function that you should override if you need to use it; the default implementation does nothing."
    },
    "Exits a modal state": {
        "prefix": "hs.hotkey.modal:exit() -> hs.hotkey.modal object",
        "body": "hs.hotkey.modal:exit()",
        "description": "Exits a modal state\n\nParameters:\n * None\n\nReturns:\n * The `hs.hotkey.modal` object for method chaining\n\nNotes:\n * This method will disable all of the hotkeys defined in the modal state, and enable the hotkey for entering the modal state (if one was defined)"
    },
    "Optional callback for when a modal is exited": {
        "prefix": "hs.hotkey.modal:exited()",
        "body": "hs.hotkey.modal:exited()",
        "description": "Optional callback for when a modal is exited\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This is a pre-existing function that you should override if you need to use it; the default implementation does nothing."
    },
    "Creates a new modal state, optionally with a global keyboard combination to trigger it": {
        "prefix": "hs.hotkey.modal.new(mods, key, message) -> hs.hotkey.modal object",
        "body": "hs.hot${2:key}.modal.new(${1:mods}, key, ${3:message})",
        "description": "Creates a new modal state, optionally with a global keyboard combination to trigger it\n\nParameters:\n * mods - A table or a string containing (as elements, or as substrings with any separator) the keyboard modifiers required,\n   which should be zero or more of the following:\n   * \"cmd\", \"command\" or \"\u2318\"\n   * \"ctrl\", \"control\" or \"\u2303\"\n   * \"alt\", \"option\" or \"\u2325\"\n   * \"shift\" or \"\u21e7\"\n * key - A string containing the name of a keyboard key (as found in [hs.keycodes.map](hs.keycodes.html#map) ), or a raw keycode number\n * message - A string containing a message to be displayed via `hs.alert()` when the hotkey has been triggered, or nil for no alert\n\nReturns:\n * A new `hs.hotkey.modal` object\n\nNotes:\n * If `key` is nil, no global hotkey will be registered (all other parameters will be ignored)"
    },
    "Sends an HTTP GET request asynchronously": {
        "prefix": "hs.http.asyncGet(url, headers, callback)",
        "body": "hs.http.asyncGet(${1:url}, ${2:headers}, ${3:callback})",
        "description": "Sends an HTTP GET request asynchronously\n\nParameters:\n * url - A string containing the URL to retrieve\n * headers - A table containing string keys and values representing the request headers, or nil to add no headers\n * callback - A function to be called when the request succeeds or fails. The function will be passed three parameters:\n  * A number containing the HTTP response status\n  * A string containing the response body\n  * A table containing the response headers\n\nNotes:\n * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http://user:password@host.com/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.\n\n * If the request fails, the callback function's first parameter will be negative and the second parameter will contain an error message. The third parameter will be nil"
    },
    "Sends an HTTP POST request asynchronously": {
        "prefix": "hs.http.asyncPost(url, data, headers, callback)",
        "body": "hs.http.asyncPost(${1:url}, ${2:data}, ${3:headers}, ${4:callback})",
        "description": "Sends an HTTP POST request asynchronously\n\nParameters:\n * url - A string containing the URL to submit to\n * data - A string containing the request body, or nil to send no body\n * headers - A table containing string keys and values representing the request headers, or nil to add no headers\n * callback - A function to be called when the request succeeds or fails. The function will be passed three parameters:\n  * A number containing the HTTP response status\n  * A string containing the response body\n  * A table containing the response headers\n\nNotes:\n * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http://user:password@host.com/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.\n\n * If the request fails, the callback function's first parameter will be negative and the second parameter will contain an error message. The third parameter will be nil"
    },
    "Convert all recognized HTML Entities in the `inString` to appropriate UTF8 byte sequences and returns the converted text.": {
        "prefix": "hs.http.convertHtmlEntities(inString) -> outString",
        "body": "hs.http.convertHtmlEntities(${1:inString})",
        "description": "Convert all recognized HTML Entities in the `inString` to appropriate UTF8 byte sequences and returns the converted text.\n\nParameters:\n * inString -- A string containing any number of HTML Entities (&whatever;) in the text.\n\nReturns:\n * outString -- the input string with all recognized HTML Entity sequences converted to UTF8 byte sequences.\n\nNotes:\n * Recognized HTML Entities are those registered in `hs.http.htmlEntities` or numeric entity sequences: &#n; where `n` can be any integer number.\n * This function is especially useful as a post-filter to data retrieved by the `hs.http.get` and `hs.http.asyncGet` functions."
    },
    "Creates an HTTP request and executes it asynchronously": {
        "prefix": "hs.http.doAsyncRequest(url, method, data, headers, callback, [cachePolicy])",
        "body": "hs.http.doAsyncRequest(${1:url}, ${2:method}, ${3:data}, ${4:headers}, ${5:callback}, ${6:[cachePolicy]})",
        "description": "Creates an HTTP request and executes it asynchronously\n\nParameters:\n * url - A string containing the URL\n * method - A string containing the HTTP method to use (e.g. \"GET\", \"POST\", etc)\n * data - A string containing the request body, or nil to send no body\n * headers - A table containing string keys and values representing request header keys and values, or nil to add no headers\n * callback - A function to called when the response is received. The function should accept three arguments:\n  * code - A number containing the HTTP response code\n  * body - A string containing the body of the response\n  * headers - A table containing the HTTP headers of the response\n * cachePolicy - An optional string containing the cache policy (\"protocolCachePolicy\", \"ignoreLocalCache\", \"ignoreLocalAndRemoteCache\", \"returnCacheOrLoad\", \"returnCacheDontLoad\" or \"reloadRevalidatingCache\"). Defaults to `protocolCachePolicy`.\n\nReturns:\n * None\n\nNotes:\n * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http://user:password@host.com/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.\n * If the Content-Type response header begins `text/` then the response body return value is a UTF8 string. Any other content type passes the response body, unaltered, as a stream of bytes."
    },
    "Creates an HTTP request and executes it synchronously": {
        "prefix": "hs.http.doRequest(url, method, [data, headers, cachePolicy]) -> int, string, table",
        "body": "hs.http.doRequest(${1:url}, ${2:method}, ${3:[data}, ${4:headers}, ${5:cachePolicy]})",
        "description": "Creates an HTTP request and executes it synchronously\n\nParameters:\n * url - A string containing the URL\n * method - A string containing the HTTP method to use (e.g. \"GET\", \"POST\", etc)\n * data - An optional string containing the data to POST to the URL, or nil to send no data\n * headers - An optional table of string keys and values used as headers for the request, or nil to add no headers\n * cachePolicy - An optional string containing the cache policy (\"protocolCachePolicy\", \"ignoreLocalCache\", \"ignoreLocalAndRemoteCache\", \"returnCacheOrLoad\", \"returnCacheDontLoad\" or \"reloadRevalidatingCache\"). Defaults to `protocolCachePolicy`.\n\nReturns:\n * A number containing the HTTP response status code\n * A string containing the response body\n * A table containing the response headers\n\nNotes:\n * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http://user:password@host.com/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.\n\n * This function is synchronous and will therefore block all Lua execution until it completes. You are encouraged to use the asynchronous functions.\n * If you attempt to connect to a local Hammerspoon server created with `hs.httpserver`, then Hammerspoon will block until the connection times out (60 seconds), return a failed result due to the timeout, and then the `hs.httpserver` callback function will be invoked (so any side effects of the function will occur, but it's results will be lost).  Use [hs.http.doAsyncRequest](#doAsyncRequest) to avoid this.\n * If the Content-Type response header begins `text/` then the response body return value is a UTF8 string. Any other content type passes the response body, unaltered, as a stream of bytes."
    },
    "Returns a copy of the provided string in which characters that are not valid within an HTTP query key or value are escaped with their %## equivalent.": {
        "prefix": "hs.http.encodeForQuery(string) -> string",
        "body": "hs.http.encodeForQuery(${1:string})",
        "description": "Returns a copy of the provided string in which characters that are not valid within an HTTP query key or value are escaped with their %## equivalent.\n\nParameters:\n * originalString - the string to make safe as a key or value for a query\n\nReturns:\n * the converted string\n\nNotes:\n * The intent of this function is to provide a valid key or a valid value for a query string, not to validate the entire query string.  For this reason, ?, =, +, and & are included in the converted characters."
    },
    "Sends an HTTP GET request to a URL": {
        "prefix": "hs.http.get(url, headers) -> int, string, table",
        "body": "hs.http.get(${1:url}, ${2:headers})",
        "description": "Sends an HTTP GET request to a URL\n\nParameters\n * url - A string containing the URL to retrieve\n * headers - A table containing string keys and values representing the request headers, or nil to add no headers\n\nReturns:\n * A number containing the HTTP response status\n * A string containing the response body\n * A table containing the response headers\n\nNotes:\n * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http://user:password@host.com/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.\n\n * This function is synchronous and will therefore block all other Lua execution while the request is in progress, you are encouraged to use the asynchronous functions\n * If you attempt to connect to a local Hammerspoon server created with `hs.httpserver`, then Hammerspoon will block until the connection times out (60 seconds), return a failed result due to the timeout, and then the `hs.httpserver` callback function will be invoked (so any side effects of the function will occur, but it's results will be lost).  Use [hs.http.asyncGet](#asyncGet) to avoid this."
    },
    "A collection of common HTML Entities (&whatever;) and their UTF8 equivalents.  To retrieve the UTF8 sequence for a given entity, reference the table as `hs.http.htmlEntities[\"&key;\"]` where `key` is the text of the entity's name or a numeric reference like `#number`.": {
        "prefix": "hs.http.htmlEntities[]",
        "body": "hs.http.htmlEntities",
        "description": "A collection of common HTML Entities (&whatever;) and their UTF8 equivalents.  To retrieve the UTF8 sequence for a given entity, reference the table as `hs.http.htmlEntities[\"&key;\"]` where `key` is the text of the entity's name or a numeric reference like `#number`.\n\nNotes:\n * This list is likely not complete.  It is based on the list of common entities described at http://www.freeformatter.com/html-entities.html.\n * Additional entities can be temporarily added via the `hs.http.registerEntity(...)` function.  If you feel you have a more official list of entities which contains items which are currently not included by default, please open up an issue at https://github.com/Hammerspoon/hammerspoon and your link will be considered.\n * To see a list of the currently defined entities, a __tostring meta-method is included so that referencing the table directly as a string will return the current definitions.\n   * For reference, this meta-method is essentially the following:\n\n     for i,v in hs.fnutils.sortByKeys(hs.http.htmlEntities) do print(string.format(\"%-10s %-10s %s\\n\", i, \"&#\"..tostring(hs.utf8.codepoint(v))..\";\", v)) end\n\n   * Note that this list will not include the numeric conversion of entities (e.g. &#65;), as this is handled by an __index metamethod to allow for all possible numeric values."
    },
    "Sends an HTTP POST request to a URL": {
        "prefix": "hs.http.post(url, data, headers) -> int, string, table",
        "body": "hs.http.post(${1:url}, ${2:data}, ${3:headers})",
        "description": "Sends an HTTP POST request to a URL\n\nParameters\n * url - A string containing the URL to submit to\n * data - A string containing the request body, or nil to send no body\n * headers - A table containing string keys and values representing the request headers, or nil to add no headers\n\nReturns:\n * A number containing the HTTP response status\n * A string containing the response body\n * A table containing the response headers\n\nNotes:\n * If authentication is required in order to download the request, the required credentials must be specified as part of the URL (e.g. \"http://user:password@host.com/\"). If authentication fails, or credentials are missing, the connection will attempt to continue without credentials.\n\n * This function is synchronous and will therefore block all other Lua execution while the request is in progress, you are encouraged to use the asynchronous functions\n * If you attempt to connect to a local Hammerspoon server created with `hs.httpserver`, then Hammerspoon will block until the connection times out (60 seconds), return a failed result due to the timeout, and then the `hs.httpserver` callback function will be invoked (so any side effects of the function will occur, but it's results will be lost).  Use [hs.http.asyncPost](#asyncPost) to avoid this."
    },
    "Registers an HTML Entity with the specified Unicode codepoint which can later referenced in your code as `hs.http.htmlEntity[entity]` for convenience and readability.": {
        "prefix": "hs.http.registerEntity(entity, codepoint) -> string",
        "body": "hs.http.registerEntity(${1:entity}, ${2:codepoint})",
        "description": "Registers an HTML Entity with the specified Unicode codepoint which can later referenced in your code as `hs.http.htmlEntity[entity]` for convenience and readability.\n\nParameters:\n * entity -- The full text of the HTML Entity as it appears in HTML encoded documents.  A proper entity starts with & and ends with ; and entity labels which do not meet this will have them added -- future dereferences to get the corresponding UTF8 *must* include this initiator and terminator or they will not be recognized.\n * codepoint -- a Unicode codepoint in numeric or `U+xxxx` format to register with as the given entity.\n\nReturns:\n * Returns the UTF8 byte sequence for the entity registered.\n\nNotes:\n * If an entity label was previously registered, this will overwrite the previous value with a new one.\n * The return value is merely syntactic sugar and you do not need to save it locally; it can be safely ignored -- future access to the pre-converted entity should be retrieved as `hs.http.htmlEntities[entity]` in your code.  It looks good when invoked from the console, though \u263a."
    },
    "Returns a table of keys containing the individual components of the provided url.": {
        "prefix": "hs.http.urlParts(url) -> table",
        "body": "hs.http.${1:url}Parts(url)",
        "description": "Returns a table of keys containing the individual components of the provided url.\n\nParameters:\n * url - the url to parse into it's individual components\n\nReturns:\n * a table containing any of the following keys which apply to the specified url:\n   * absoluteString           - The URL string for the URL as an absolute URL.\n   * absoluteURL              - An absolute URL that refers to the same resource as the provided URL.\n   * baseURL                  - the base URL, if the URL is relative\n   * fileSystemRepresentation - the URL\u2019s unescaped path specified as a file system path\n   * fragment                 - the fragment, if specified in the URL\n   * host                     - the host for the URL\n   * isFileURL                - a boolean value indicating whether or not the URL represents a local file\n   * lastPathComponent        - the last path component specified in the URL\n   * parameterString          - the parameter string, if specified in the URL\n   * password                 - the password, if specified in the URL\n   * path                     - the unescaped path specified in the URL\n   * pathComponents           - an array containing the path components of the URL\n   * pathExtension            - the file extension, if specified in the URL\n   * port                     - the port, if specified in the URL\n   * query                    - the query, if specified in the URL\n   * queryItems               - if the URL contains a query string, then this field contains an array of the unescaped key-value pairs for each item. Each key-value pair is represented as a table in the array to preserve order.  See notes for more information.\n   * relativePath             - the relative path of the URL without resolving against its base URL. If the path has a trailing slash it is stripped. If the URL is already an absolute URL, this contains the same value as path.\n   * relativeString           - a string representation of the relative portion of the URL. If the URL is already an absolute URL this contains the same value as absoluteString.\n   * resourceSpecifier        - the resource specified in the URL\n   * scheme                   - the scheme of the URL\n   * standardizedURL          - the URL with any instances of \"..\" or \".\" removed from its path\n   * user                     - the username, if specified in the URL\n\nNotes:\n * This function assumes that the URL conforms to RFC 1808.  If the URL is malformed or does not conform to RFC1808, then many of these fields may be missing.\n\n * A contrived example for the url `http://user:password@host.site.com:80/path/to%20a/../file.txt;parameter?query1=1&query2=a%28#fragment`:\n\n    > hs.inspect(hs.http.urlParts(\"http://user:password@host.site.com:80/path/to%20a/../file.txt;parameter?query1=1&query2=a%28#fragment\"))\n     {\n       absoluteString = \"http://user:password@host.site.com:80/path/to%20a/../file.txt;parameter?query1=1&query2=a%28#fragment\",\n       absoluteURL = \"http://user:password@host.site.com:80/path/to%20a/../file.txt;parameter?query1=1&query2=a%28#fragment\",\n       fileSystemRepresentation = \"/path/to a/../file.txt\",\n       fragment = \"fragment\",\n       host = \"host.site.com\",\n       isFileURL = false,\n       lastPathComponent = \"file.txt\",\n       parameterString = \"parameter\",\n       password = \"password\",\n       path = \"/path/to a/../file.txt\",\n       pathComponents = { \"/\", \"path\", \"to a\", \"..\", \"file.txt\" },\n       pathExtension = \"txt\",\n       port = 80,\n       query = \"query1=1&query2=a%28\",\n       queryItems = { {\n           query1 = \"1\"\n         }, {\n           query2 = \"a(\"\n         } },\n       relativePath = \"/path/to a/../file.txt\",\n       relativeString = \"http://user:password@host.site.com:80/path/to%20a/../file.txt;parameter?query1=1&query2=a%28#fragment\",\n       resourceSpecifier = \"//user:password@host.site.com:80/path/to%20a/../file.txt;parameter?query1=1&query2=a%28#fragment\",\n       scheme = \"http\",\n       standardizedURL = \"http://user:password@host.site.com:80/path/file.txt;parameter?query1=1&query2=a%28#fragment\",\n       user = \"user\"\n     }\n\n * Because it is valid for a query key-value pair to be missing either the key or the value or both, the following conventions are used:\n   * a missing key (e.g. '=value') will be represented as { \"\" = value }\n   * a missing value (e.g. 'key=') will be represented as { key = \"\" }\n   * a missing value with no = (e.g. 'key') will be represented as { key }\n   * a missing key and value (e.g. '=') will be represente as { \"\" = \"\" }\n   * an empty query item (e.g. a query ending in '&' or a query containing && between two other query items) will be represented as { \"\" }\n\n * At present Hammerspoon does not provide a way to represent a URL as a true Objective-C object within the OS X API.  This affects the following keys:\n   * relative URLs are not possible to express properly so baseURL will always be nil and relativePath and relativeString will always match path and absoluteString.\n   * These limitations may change in a future update if the need for a more fully compliant URL treatment is determined to be necessary."
    },
    "Gets the network interface the server is configured to listen on": {
        "prefix": "hs.httpserver:getInterface() -> string or nil",
        "body": "hs.httpserver:getInterface()",
        "description": "Gets the network interface the server is configured to listen on\n\nParameters:\n * None\n\nReturns:\n * A string containing the network interface name, or nil if the server will listen on all interfaces"
    },
    "Gets the Bonjour name the server is configured to advertise itself as": {
        "prefix": "hs.httpserver:getName() -> string",
        "body": "hs.httpserver:getName()",
        "description": "Gets the Bonjour name the server is configured to advertise itself as\n\nParameters:\n * None\n\nReturns:\n * A string containing the Bonjour name of this server\n\nNotes:\n * This is not the hostname of the server, just its name in Bonjour service lists (e.g. Safari's Bonjour bookmarks menu)"
    },
    "Gets the TCP port the server is configured to listen on": {
        "prefix": "hs.httpserver:getPort() -> number",
        "body": "hs.httpserver:getPort()",
        "description": "Gets the TCP port the server is configured to listen on\n\nParameters:\n * None\n\nReturns:\n * A number containing the TCP port"
    },
    "Get or set the maximum allowed body size for an incoming HTTP request.": {
        "prefix": "hs.httpserver:maxBodySize([size]) -> object | current-value",
        "body": "hs.httpserver:maxBodySize(${1:[size]})",
        "description": "Get or set the maximum allowed body size for an incoming HTTP request.\n\nParameters:\n * size - An optional integer value specifying the maximum body size allowed for an incoming HTTP request in bytes.  Defaults to 10485760 (10 MB).\n\nReturns:\n * If a new size is specified, returns the `hs.httpserver` object; otherwise the current value.\n\nNotes:\n * Because the Hammerspoon http server processes incoming requests completely in memory, this method puts a limit on the maximum size for a POST or PUT request."
    },
    "Creates a new HTTP or HTTPS server": {
        "prefix": "hs.httpserver.new([ssl], [bonjour]) -> object",
        "body": "hs.httpserver.new(${1:[ssl]}, ${2:[bonjour]})",
        "description": "Creates a new HTTP or HTTPS server\n\nParameters:\n * ssl     - An optional boolean. If true, the server will start using HTTPS. Defaults to false.\n * bonjour - An optional boolean. If true, the server will advertise itself with Bonjour.  Defaults to true. Note that in order to change this, you must supply a true or false value for the `ssl` argument.\n\nReturns:\n * An `hs.httpserver` object\n\nNotes:\n * By default, the server will start on a random TCP port and advertise itself with Bonjour. You can check the port with `hs.httpserver:getPort()`\n * By default, the server will listen on all network interfaces. You can override this with `hs.httpserver:setInterface()` before starting the server\n * Currently, in HTTPS mode, the server will use a self-signed certificate, which most browsers will warn about. If you want/need to be able to use `hs.httpserver` with a certificate signed by a trusted Certificate Authority, please file an bug on Hammerspoon requesting support for this."
    },
    "Sends a message to the websocket client": {
        "prefix": "hs.httpserver:send(message) -> object",
        "body": "hs.httpserver:send(${1:message})",
        "description": "Sends a message to the websocket client\n\nParameters:\n * message - A string containing the message to send\n\nReturns:\n * The `hs.httpserver` object"
    },
    "Sets the request handling callback for an HTTP server object": {
        "prefix": "hs.httpserver:setCallback([callback]) -> object",
        "body": "hs.httpserver:setCallback(${1:[callback]})",
        "description": "Sets the request handling callback for an HTTP server object\n\nParameters:\n * callback - An optional function that will be called to process each incoming HTTP request, or nil to remove an existing callback. See the notes section below for more information about this callback\n\nReturns:\n * The `hs.httpserver` object\n\nNotes:\n * The callback will be passed four arguments:\n  * A string containing the type of request (i.e. `GET`/`POST`/`DELETE`/etc)\n  * A string containing the path element of the request (e.g. `/index.html`)\n  * A table containing the request headers\n  * A string containing the raw contents of the request body, or the empty string if no body is included in the request.\n * The callback *must* return three values:\n  * A string containing the body of the response\n  * An integer containing the response code (e.g. 200 for a successful request)\n  * A table containing additional HTTP headers to set (or an empty table, `{}`, if no extra headers are required)\n\nNotes:\n * A POST request, often used by HTML forms, will store the contents of the form in the body of the request."
    },
    "Sets the network interface the server is configured to listen on": {
        "prefix": "hs.httpserver:setInterface(interface) -> object",
        "body": "hs.httpserver:setInterface(${1:interface})",
        "description": "Sets the network interface the server is configured to listen on\n\nParameters:\n * interface - A string containing an interface name\n\nReturns:\n * The `hs.httpserver` object\n\nNotes:\n * As well as real interface names (e.g. `en0`) the following values are valid:\n  * An IP address of one of your interfaces\n  * localhost\n  * loopback\n  * nil (which means all interfaces, and is the default)"
    },
    "Sets the Bonjour name the server should advertise itself as": {
        "prefix": "hs.httpserver:setName(name) -> object",
        "body": "hs.httpserver:setName(${1:name})",
        "description": "Sets the Bonjour name the server should advertise itself as\n\nParameters:\n * name - A string containing the Bonjour name for the server\n\nReturns:\n * The `hs.httpserver` object\n\nNotes:\n * This is not the hostname of the server, just its name in Bonjour service lists (e.g. Safari's Bonjour bookmarks menu)"
    },
    "Sets a password for an HTTP server object": {
        "prefix": "hs.httpserver:setPassword([password]) -> object",
        "body": "hs.httpserver:setPassword(${1:[password]})",
        "description": "Sets a password for an HTTP server object\n\nParameters:\n * password - An optional string that contains the server password, or nil to remove an existing password\n\nReturns:\n * The `hs.httpserver` object\n\nNotes:\n * It is not currently possible to set multiple passwords for different users, or passwords only on specific paths"
    },
    "Sets the TCP port the server is configured to listen on": {
        "prefix": "hs.httpserver:setPort(port) -> object",
        "body": "hs.httpserver:setPort(${1:port})",
        "description": "Sets the TCP port the server is configured to listen on\n\nParameters:\n * port - An integer containing a TCP port to listen on\n\nReturns:\n * The `hs.httpserver` object"
    },
    "Starts an HTTP server object": {
        "prefix": "hs.httpserver:start() -> object",
        "body": "hs.httpserver:start()",
        "description": "Starts an HTTP server object\n\nParameters:\n * None\n\nReturns:\n * The `hs.httpserver` object"
    },
    "Stops an HTTP server object": {
        "prefix": "hs.httpserver:stop() -> object",
        "body": "hs.httpserver:stop()",
        "description": "Stops an HTTP server object\n\nParameters:\n * None\n\nReturns:\n * The `hs.httpserver` object"
    },
    "Enables a websocket endpoint on the HTTP server": {
        "prefix": "hs.httpserver:websocket(path, callback) -> object",
        "body": "hs.httpserver:websocket(${1:path}, ${2:callback})",
        "description": "Enables a websocket endpoint on the HTTP server\n\nParameters:\n * path - A string containing the websocket path such as '/ws'\n * callback - A function returning a string for each recieved websocket message\n\nReturns:\n * The `hs.httpserver` object\n\nNotes:\n * The callback is passed one string parameter containing the received message\n * The callback must return a string containing the response message\n * Given a path '/mysock' and a port of 8000, the websocket URL is as follows:\n  * ws://localhost:8000/mysock\n  * wss://localhost:8000/mysock (if SSL enabled)"
    },
    "Accessed as `self._accessLog`.  If query logging is enabled for the web server, an Apache style common log entry will be appended to this string for each request.  See [hs.httpserver.hsminweb:queryLogging](#queryLogging).": {
        "prefix": "hs.httpserver.hsminweb._accessLog",
        "body": "hs.httpserver.hsminweb._accessLog",
        "description": "Accessed as `self._accessLog`.  If query logging is enabled for the web server, an Apache style common log entry will be appended to this string for each request.  See [hs.httpserver.hsminweb:queryLogging](#queryLogging)."
    },
    "Accessed as `self._errorHandlers[errorCode]`.  A table whose keyed entries specify the function to generate the error response page for an HTTP error.": {
        "prefix": "hs.httpserver.hsminweb._errorHandlers",
        "body": "hs.httpserver.hsminweb._errorHandlers",
        "description": "Accessed as `self._errorHandlers[errorCode]`.  A table whose keyed entries specify the function to generate the error response page for an HTTP error.\n\nHTTP uses a three digit numeric code for error conditions.  Some servers have introduced subcodes, which are appended as a decimal added to the error condition.\n\nYou can assign your own handler to customize the response for a specific error code by specifying a function for the desired error condition as the value keyed to the error code as a string key in this table.  The function should expect three arguments:\n * method  - the method for the HTTP request\n * path    - the full path, including any GET query items\n * headers - a table containing key-value pairs for the HTTP request headers\n\nIf you override the default handler, \"default\", the function should expect four arguments instead:  the error code as a string, followed by the same three arguments defined above.\n\nIn either case, the function should return three values:\n * body    - the content to be returned, usually HTML for a basic error description page\n * code    - a 3 digit integer specifying the HTTP Response status (see https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)\n * headers - a table containing any headers which should be included in the HTTP response."
    },
    "Accessed as `self._serverAdmin`.  A string containing the administrator for the web server.  Defaults to the currently logged in user's short form username and the computer's localized name as returned by `hs.host.localizedName()` (e.g. \"user@computer\").": {
        "prefix": "hs.httpserver.hsminweb._serverAdmin",
        "body": "hs.httpserver.hsminweb._serverAdmin",
        "description": "Accessed as `self._serverAdmin`.  A string containing the administrator for the web server.  Defaults to the currently logged in user's short form username and the computer's localized name as returned by `hs.host.localizedName()` (e.g. \"user@computer\").\n\nThis value is often used in error messages or on error pages indicating a point of contact for administrative help.  It can be accessed from within an error helper functions as `headers._.serverAdmin`."
    },
    "Accessed as `self._supportMethods[method]`.  A table whose keyed entries specify whether or not a specified HTTP method is supported by this server.": {
        "prefix": "hs.httpserver.hsminweb._supportMethods",
        "body": "hs.httpserver.hsminweb._supportMethods",
        "description": "Accessed as `self._supportMethods[method]`.  A table whose keyed entries specify whether or not a specified HTTP method is supported by this server.\n\nThe default methods supported internally are:\n * HEAD - an HTTP method which verifies whether or not a resource is available and it's last modified date\n * GET  - an HTTP method requesting content; the default method used by web browsers for bookmarks or URLs typed in by the user\n * POST - an HTTP method requesting content that includes content in the request body, most often used by forms to include user input or file data which may affect the content being returned.\n\nIf you assign `true` to another method key, then it will be supported if the target URL refers to a CGI script or Lua Template file, and their support has been enabled for the server.\n\nIf you assign `false` to a method key, then *any* request utilizing that method will return a status of 405 (Method Not Supported).  E.g. `self._supportMethods[\"POST\"] = false` will prevent the POST method from being supported.\n\nCommon HTTP request methods can be found at https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods and https://en.wikipedia.org/wiki/WebDAV.  Currently, only HEAD, GET, and POST have built in support for static pages; even if you set other methods to `true`, they will return a status code of 405 (Method Not Supported) if the request does not invoke a CGI file or Lua Template file for dynamic content.\n\nA companion module supporting the methods required for WebDAV is being considered."
    },
    "Get or set the access-list table for the hsminweb web server": {
        "prefix": "hs.httpserver.hsminweb:accessList([table]) -> hsminwebTable | current-value",
        "body": "hs.httpserver.hsminweb:accessList(${1:[table]})",
        "description": "Get or set the access-list table for the hsminweb web server\n\nParameters:\n * table - an optional table or `nil` containing the access list for the web server, default `nil`.\n\nReturns:\n * the hsminwebTable object if a parameter is provided, or the current value if no parameter is specified.\n\nNotes:\n * The access-list feature works by comparing the request headers against a list of tests which either accept or reject the request.  If no access list is set (i.e. it is assigned a value of `nil`), then all requests are served.  If a table is passed into this method, then any request which is not explicitly accepted by one of the tests provided is rejected (i.e. there is an implicit \"reject\" at the end of the list).\n * The access-list table is a list of tests which are evaluated in order.  The first test which matches a given request determines whether or not the request is accepted or rejected.\n * Each entry in the access-list table is also a table with the following format:\n   * { 'header', 'value', isPattern, isAccepted }\n     * header     - a string value matching the name of a header.  While the header name must match exactly, the comparison is case-insensitive (i.e. \"X-Remote-addr\" and \"x-remote-addr\" will both match the actual header name used, which is \"X-Remote-Addr\").\n     * value      - a string value specifying the value to compare the header key's value to.\n     * isPattern  - a boolean indicating whether or not the header key's value should be compared to `value` as a pattern match (true) -- see Lua documentation 6.4.1, `help.lua._man._6_4_1` in the console, or as an exact match (false)\n     * isAccepted - a boolean indicating whether or not a match should be accepted (true) or rejected (false)\n   * A special entry of the form { '\\*', '\\*', '\\*', true } accepts all further requests and can be used as the final entry if you wish for the access list to function as a list of requests to reject, but to accept any requests which do not match a previous test.\n   * A special entry of the form { '\\*', '\\*', '\\*', false } rejects all further requests and can be used as the final entry if you wish for the access list to function as a list of requests to accept, but to reject any requests which do not match a previous test.  This is the implicit \"default\" final test if a table is assigned with the access-list method and does not actually need to be specified, but is included for completeness.\n   * Note that any entry after an entry in which the first two parameters are equal to '\\*' will never actually be used.\n\n * The tests are performed in order; if you wich to allow one IP address in a range, but reject all others, you should list the accepted IP addresses first. For example:\n    ~~~\n    {\n       { 'X-Remote-Addr', '192.168.1.100',  false, true },  -- accept requests from 192.168.1.100\n       { 'X-Remote-Addr', '^192%.168%.1%.', true,  false }, -- reject all others from the 192.168.1 subnet\n       { '*',             '*',              '*',   true }   -- accept all other requests\n    }\n    ~~~\n\n * Most of the headers available are provided by the requesting web browser, so the exact headers available will vary.  You can find some information about common HTTP request headers at: https://en.wikipedia.org/wiki/List_of_HTTP_header_fields.\n\n * The following headers are inserted automatically by `hs.httpserver` and are probably the most useful for use in an access list:\n   * X-Remote-Addr - the remote IPv4 or IPv6 address of the machine making the request,\n   * X-Remote-Port - the TCP port of the remote machine where the request originated.\n   * X-Server-Addr - the server IPv4 or IPv6 address that the web server received the request from.  For machines with multiple interfaces, this will allow you to determine which interface the request was received on.\n   * X-Server-Port - the TCP port of the web server that received the request."
    },
    "Get or set the whether or not a directory index is returned when the requested URL specifies a directory and no file matching an entry in the directory indexes table is found.": {
        "prefix": "hs.httpserver.hsminweb:allowDirectory([flag]) -> hsminwebTable | current-value",
        "body": "hs.httpserver.hsminweb:allowDirectory(${1:[flag]})",
        "description": "Get or set the whether or not a directory index is returned when the requested URL specifies a directory and no file matching an entry in the directory indexes table is found.\n\nParameters:\n * flag - an optional boolean, defaults to false, indicating whether or not a directory index can be returned when a default file cannot be located.\n\nReturns:\n * the hsminwebTable object if a parameter is provided, or the current value if no parameter is specified.\n\nNotes:\n * if this value is false, then an attempt to retrieve a URL specifying a directory that does not contain a default file as identified by one of the entries in the [hs.httpserver.hsminweb:directoryIndex](#directoryIndex) list will result in a \"403.2\" error."
    },
    "Get or set the whether or not the web server should advertise itself via Bonjour when it is running.": {
        "prefix": "hs.httpserver.hsminweb:bonjour([flag]) -> hsminwebTable | current-value",
        "body": "hs.httpserver.hsminweb:bonjour(${1:[flag]})",
        "description": "Get or set the whether or not the web server should advertise itself via Bonjour when it is running.\n\nParameters:\n * flag - an optional boolean, defaults to true, indicating whether or not the server should advertise itself via Bonjour when it is running.\n\nReturns:\n * the hsminwebTable object if a parameter is provided, or the current value if no parameter is specified.\n\nNotes:\n * this flag can only be changed when the server is not running (i.e. the [hs.httpserver.hsminweb:start](#start) method has not yet been called, or the [hs.httpserver.hsminweb:stop](#stop) method is called first.)"
    },
    "Get or set the whether or not CGI file execution is enabled.": {
        "prefix": "hs.httpserver.hsminweb:cgiEnabled([flag]) -> hsminwebTable | current-value",
        "body": "hs.httpserver.hsminweb:cgiEnabled(${1:[flag]})",
        "description": "Get or set the whether or not CGI file execution is enabled.\n\nParameters:\n * flag - an optional boolean, defaults to false, indicating whether or not CGI script execution is enabled for the web server.\n\nReturns:\n * the hsminwebTable object if a parameter is provided, or the current value if no parameter is specified."
    },
    "Get or set the file extensions which identify files which should be executed as CGI scripts to provide the results to an HTTP request.": {
        "prefix": "hs.httpserver.hsminweb:cgiExtensions([table]) -> hsminwebTable | current-value",
        "body": "hs.httpserver.hsminweb:cgiExtensions(${1:[table]})",
        "description": "Get or set the file extensions which identify files which should be executed as CGI scripts to provide the results to an HTTP request.\n\nParameters:\n * table - an optional table or `nil`, defaults to `{ \"cgi\", \"pl\" }`, specifying a list of file extensions which indicate that a file should be executed as CGI scripts to provide the content for an HTTP request.\n\nReturns:\n * the hsminwebTable object if a parameter is provided, or the current value if no parameter is specified.\n\nNotes:\n * this list is ignored if [hs.httpserver.hsminweb:cgiEnabled](#cgiEnabled) is not also set to true."
    },
    "A format string, usable with `os.date`, which will display a date in the format expected for HTTP communications as described in RFC 822, updated by RFC 1123.": {
        "prefix": "hs.httpserver.hsminweb.dateFormatString",
        "body": "hs.httpserver.hsminweb.dateFormatString",
        "description": "A format string, usable with `os.date`, which will display a date in the format expected for HTTP communications as described in RFC 822, updated by RFC 1123."
    },
    "Get or set the file names to look for when the requested URL specifies a directory.": {
        "prefix": "hs.httpserver.hsminweb:directoryIndex([table]) -> hsminwebTable | current-value",
        "body": "hs.httpserver.hsminweb:directoryIndex(${1:[table]})",
        "description": "Get or set the file names to look for when the requested URL specifies a directory.\n\nParameters:\n * table - an optional table or `nil`, defaults to `{ \"index.html\", \"index.htm\" }`, specifying a list of file names to look for when the requested URL specifies a directory.  If a file with one of the names is found in the directory, this file is served instead of the directory.\n\nReturns:\n * the hsminwebTable object if a parameter is provided, or the current value if no parameter is specified.\n\nNotes:\n * Files listed in this table are checked in order, so the first matched is served.  If no file match occurs, then the server will return a generated list of the files in the directory, or a \"403.2\" error, depending upon the value controlled by [hs.httpserver.hsminweb:allowDirectory](#allowDirectory)."
    },
    "Get or set the whether or not DNS lookups are performed.": {
        "prefix": "hs.httpserver.hsminweb:dnsLookup([flag]) -> hsminwebTable | current-value",
        "body": "hs.httpserver.hsminweb:dnsLookup(${1:[flag]})",
        "description": "Get or set the whether or not DNS lookups are performed.\n\nParameters:\n * flag - an optional boolean, defaults to false, indicating whether or not DNS lookups are performed.\n\nReturns:\n * the hsminwebTable object if a parameter is provided, or the current value if no parameter is specified.\n\nNotes:\n * DNS lookups can be time consuming or even block Hammerspoon for a short time, so they are disabled by default.\n * Currently DNS lookups are (optionally) performed for CGI scripts, but may be added for other purposes in the future (logging, etc.)."
    },
    "Get or set the document root for the web server.": {
        "prefix": "hs.httpserver.hsminweb:documentRoot([path]) -> hsminwebTable | current-value",
        "body": "hs.httpserver.hsminweb:documentRoot(${1:[path]})",
        "description": "Get or set the document root for the web server.\n\nParameters:\n * path - an optional string, default `os.getenv(\"HOME\") .. \"/Sites\"`, specifying where documents for the web server should be served from.\n\nReturns:\n * the hsminwebTable object if a parameter is provided, or the current value if no parameter is specified."
    },
    "Returns the current or specified time in the format expected for HTTP communications as described in RFC 822, updated by RFC 1123.": {
        "prefix": "hs.httpserver.hsminweb.formattedDate([date]) -> string",
        "body": "hs.httpserver.hsminweb.formattedDate(${1:[date]})",
        "description": "Returns the current or specified time in the format expected for HTTP communications as described in RFC 822, updated by RFC 1123.\n\nParameters:\n * date - an optional integer specifying the date as the number of seconds since 00:00:00 UTC on 1 January 1970.  Defaults to the current time as returned by `os.time()`\n\nReturns:\n * the time indicated as a string in the format expected for HTTP communications as described in RFC 822, updated by RFC 1123."
    },
    "Get or set the network interface that the hsminweb web server will listen on": {
        "prefix": "hs.httpserver.hsminweb:interface([interface]) -> hsminwebTable | current-value",
        "body": "hs.httpserver.hsminweb:interface(${1:[interface]})",
        "description": "Get or set the network interface that the hsminweb web server will listen on\n\nParameters:\n * interface - an optional string, or nil, specifying the network interface the web server will listen on.  An explicit nil specifies that the web server should listen on all active interfaces for the machine.  Defaults to nil.\n\nReturns:\n * the hsminwebTable object if a parameter is provided, or the current value if no parameter is specified.\n\nNotes:\n * See `hs.httpserver.setInterface` for a description of valid values that can be specified as the `interface` argument to this method.\n * the interface can only be specified before the hsminweb web server has been started.  If you wish to change the listening interface for a running web server, you must stop it with [hs.httpserver.hsminweb:stop](#stop) before invoking this method and then restart it with [hs.httpserver.hsminweb:start](#start)."
    },
    "The `hs.logger` instance for the `hs.httpserver.hsminweb` module. See the documentation for `hs.logger` for more information.": {
        "prefix": "hs.httpserver.hsminweb.log",
        "body": "hs.httpserver.hsminweb.log",
        "description": "The `hs.logger` instance for the `hs.httpserver.hsminweb` module. See the documentation for `hs.logger` for more information."
    },
    "Get or set the extension of files which contain Lua code which should be executed within Hammerspoon to provide the results to an HTTP request.": {
        "prefix": "hs.httpserver.hsminweb:luaTemplateExtension([string]) -> hsminwebTable | current-value",
        "body": "hs.httpserver.hsminweb:luaTemplateExtension(${1:[string]})",
        "description": "Get or set the extension of files which contain Lua code which should be executed within Hammerspoon to provide the results to an HTTP request.\n\nParameters:\n * string - an optional string or `nil`, defaults to `nil`, specifying the file extension which indicates that a file should be executed as Lua code within the Hammerspoon environment to provide the content for an HTTP request.\n\nReturns:\n * the hsminwebTable object if a parameter is provided, or the current value if no parameter is specified.\n\nNotes:\n * This extension is checked after the extensions given to [hs.httpserver.hsminweb:cgiExtensions](#cgiExtensions); this means that if the same extension set by this method is also in the CGI extensions list, then the file will be interpreted as a CGI script and ignore this setting."
    },
    "Get or set the maximum body size for an HTTP request": {
        "prefix": "hs.httpserver.hsminweb:maxBodySize([size]) -> hsminwebTable | current-value",
        "body": "hs.httpserver.hsminweb:maxBodySize(${1:[size]})",
        "description": "Get or set the maximum body size for an HTTP request\n\nParameters:\n * size - An optional integer value specifying the maximum body size allowed for an incoming HTTP request in bytes.  Defaults to 10485760 (10 MB).\n\nReturns:\n * the hsminwebTable object if a parameter is provided, or the current value if no parameter is specified.\n\nNotes:\n * Because the Hammerspoon http server processes incoming requests completely in memory, this method puts a limit on the maximum size for a POST or PUT request.\n * If the request body excedes this size, `hs.httpserver` will respond with a status code of 405 for the method before this module ever receives the request."
    },
    "Get or set the name the web server uses in Bonjour advertisement when the web server is running.": {
        "prefix": "hs.httpserver.hsminweb:name([name]) -> hsminwebTable | current-value",
        "body": "hs.httpserver.hsminweb:name(${1:[name]})",
        "description": "Get or set the name the web server uses in Bonjour advertisement when the web server is running.\n\nParameters:\n * name - an optional string specifying the name the server advertises itself as when Bonjour is enabled and the web server is running.  Defaults to `nil`, which causes the server to be advertised with the computer's name as defined in the Sharing preferences panel for the computer.\n\nReturns:\n * the hsminwebTable object if a parameter is provided, or the current value if no parameter is specified."
    },
    "Create a new hsminweb table object representing a Hammerspoon Web Server.": {
        "prefix": "hs.httpserver.hsminweb.new([documentRoot]) -> hsminwebTable",
        "body": "hs.httpserver.hsminweb.new(${1:[documentRoot]})",
        "description": "Create a new hsminweb table object representing a Hammerspoon Web Server.\n\nParameters:\n * documentRoot - an optional string specifying the document root for the new web server.  Defaults to the Hammerspoon users `Sites` sub-directory (i.e. `os.getenv(\"HOME\")..\"/Sites\"`).\n\nReturns:\n * a table representing the hsminweb object.\n\nNotes:\n * a web server's document root is the directory which contains the documents or files to be served by the web server.\n * while an hs.minweb object is actually represented by a Lua table, it has been assigned a meta-table which allows methods to be called directly on it like a user-data object.  For most purposes, you should think of this table as the module's userdata."
    },
    "Set a password for the hsminweb web server, or return a boolean indicating whether or not a password is currently set for the web server.": {
        "prefix": "hs.httpserver.hsminweb:password([password]) -> hsminwebTable | boolean",
        "body": "hs.httpserver.hsminweb:password(${1:[password]})",
        "description": "Set a password for the hsminweb web server, or return a boolean indicating whether or not a password is currently set for the web server.\n\nParameters:\n * password - An optional string that contains the server password, or an explicit `nil` to remove an existing password.\n\nReturns:\n * the hsminwebTable object if a parameter is provided, or a boolean indicathing whether or not a password has been set if no parameter is specified.\n\nNotes:\n * the password, if set, is server wide and causes the server to use the Basic authentication scheme with an empty string for the username.\n * this module is an extension to the Hammerspoon core module `hs.httpserver`, so it has the same limitations regarding server passwords. See the documentation for `hs.httpserver.setPassword` (`help.hs.httpserver.setPassword` in the Hammerspoon console)."
    },
    "Get or set the name the port the web server listens on": {
        "prefix": "hs.httpserver.hsminweb:port([port]) -> hsminwebTable | current-value",
        "body": "hs.httpserver.hsminweb:port(${1:[port]})",
        "description": "Get or set the name the port the web server listens on\n\nParameters:\n * port - an optional integer specifying the TCP port the server listens for requests on when it is running.  Defaults to `nil`, which causes the server to randomly choose a port when it is started.\n\nReturns:\n * the hsminwebTable object if a parameter is provided, or the current value if no parameter is specified.\n\nNotes:\n * due to security restrictions enforced by OS X, the port must be a number greater than 1023"
    },
    "Get or set the whether or not requests to this web server are logged.": {
        "prefix": "hs.httpserver.hsminweb:queryLogging([flag]) -> hsminwebTable | current-value",
        "body": "hs.httpserver.hsminweb:queryLogging(${1:[flag]})",
        "description": "Get or set the whether or not requests to this web server are logged.\n\nParameters:\n * flag - an optional boolean, defaults to false, indicating whether or not query requests are logged.\n\nReturns:\n * the hsminwebTable object if a parameter is provided, or the current value if no parameter is specified.\n\nNotes:\n * If logging is enabled, an Apache common style log entry is appended to [self._accesslog](#_accessLog) for each request made to the web server.\n * Error messages during content generation are always logged to the Hammerspoon console via the `hs.logger` instance saved to [hs.httpserver.hsminweb.log](#log)."
    },
    "Get or set the timeout for a CGI script": {
        "prefix": "hs.httpserver.hsminweb:scriptTimeout([integer]) -> hsminwebTable | current-value",
        "body": "hs.httpserver.hsminweb:scriptTimeout(${1:[integer]})",
        "description": "Get or set the timeout for a CGI script\n\nParameters:\n * integer - an optional integer, defaults to 30, specifying the length of time in seconds a CGI script should be allowed to run before being forcibly terminated if it has not yet completed its task.\n\nReturns:\n * the hsminwebTable object if a parameter is provided, or the current value if no parameter is specified.\n\nNotes:\n * With the current functionality available in `hs.httpserver`, any script which is expected to return content for an HTTP request must run in a blocking manner -- this means that no other Hammerspoon activity can be occurring while the script is executing.  This parameter lets you set the maximum amount of time such a script can hold things up before being terminated.\n * An alternative implementation of at least some of the methods available in `hs.httpserver` is being considered which may make it possible to use `hs.task` for these scripts, which would alleviate this blocking behavior.  However, even if this is addressed, a timeout for scripts is still desirable so that a client making a request doesn't sit around waiting forever if a script is malformed."
    },
    "Get or set the whether or not the web server utilizes SSL for HTTP request and response communications.": {
        "prefix": "hs.httpserver.hsminweb:ssl([flag]) -> hsminwebTable | current-value",
        "body": "hs.httpserver.hsminweb:ssl(${1:[flag]})",
        "description": "Get or set the whether or not the web server utilizes SSL for HTTP request and response communications.\n\nParameters:\n * flag - an optional boolean, defaults to false, indicating whether or not the server utilizes SSL for HTTP request and response traffic.\n\nReturns:\n * the hsminwebTable object if a parameter is provided, or the current value if no parameter is specified.\n\nNotes:\n * this flag can only be changed when the server is not running (i.e. the [hs.httpserver.hsminweb:start](#start) method has not yet been called, or the [hs.httpserver.hsminweb:stop](#stop) method is called first.)\n * this module is an extension to the Hammerspoon core module `hs.httpserver`, so it has the same considerations regarding SSL. See the documentation for `hs.httpserver.new` (`help.hs.httpserver.new` in the Hammerspoon console)."
    },
    "Start serving pages for the hsminweb web server.": {
        "prefix": "hs.httpserver.hsminweb:start() -> hsminwebTable",
        "body": "hs.httpserver.hsminweb:start()",
        "description": "Start serving pages for the hsminweb web server.\n\nParameters:\n * None\n\nReturns:\n * the hsminWebTable object"
    },
    "HTTP Response Status Codes": {
        "prefix": "hs.httpserver.hsminweb.statusCodes",
        "body": "hs.httpserver.hsminweb.statusCodes",
        "description": "HTTP Response Status Codes\n\nThis table contains a list of common HTTP status codes identified from various sources (see Notes below). Because some web servers append a subcode after the official HTTP status codes, the keys in this table are the string representation of the numeric code so a distinction can be made between numerically \"identical\" keys (for example, \"404.1\" and \"404.10\").  You can reference this table with a numeric key, however, and it will be converted to its string representation internally.\n\nNotes:\n * The keys and labels in this table have been combined from a variety of sources including, but not limited to:\n   * \"Official\" list at https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n   * KeplerProject's wsapi at https://github.com/keplerproject/wsapi\n   * IIS additions from https://support.microsoft.com/en-us/kb/943891\n * This table has metatable additions which allow you to review its contents from the Hammerspoon console by typing `hs.httpserver.hsminweb.statusCodes`"
    },
    "Stop serving pages for the hsminweb web server.": {
        "prefix": "hs.httpserver.hsminweb:stop() -> hsminwebTable",
        "body": "hs.httpserver.hsminweb:stop()",
        "description": "Stop serving pages for the hsminweb web server.\n\nParameters:\n * None\n\nReturns:\n * the hsminWebTable object\n\nNotes:\n * this method is called automatically during garbage collection."
    },
    "Parse the specified URL into it's constituant parts.": {
        "prefix": "hs.httpserver.hsminweb.urlParts(url) -> table",
        "body": "hs.httpserver.hsminweb.${1:url}Parts(url)",
        "description": "Parse the specified URL into it's constituant parts.\n\nParameters:\n * url - the url to parse\n\nReturns:\n * a table containing the constituant parts of the provided url.  The table will contain one or more of the following key-value pairs:\n   * fragment           - the anchor name a URL refers to within an HTML document.  Appears after '#' at the end of a URL.  Note that not all web clients include this in an HTTP request since its normal purpose is to indicate where to scroll to within a page after the content has been retrieved.\n   * host               - the host name portion of the URL, if any\n   * lastPathComponent  - the last component of the path portion of the URL\n   * password           - the password specified in the URL.  Note that this is not the password that would be entered when using Basic or Digest authentication; rather it is a password included in the URL itself -- for security reasons, use of this field has been deprecated in most situations and modern browsers will often prompt for confirmation before allowing URL's which contain a password to be transmitted.\n   * path               - the full path specified in the URL\n   * pathComponents     - an array containing the path components as individual strings.  Components which specify a sub-directory of the path will end with a \"/\" character.\n   * pathExtension      - if the final component of the path refers to a file, the file's extension, if any.\n   * port               - the port specified in the URL, if any\n   * query              - the portion of the URL after a '?' character, if any; used to contain query information often from a form submitting it's input with the GET method.\n   * resourceSpecifier  - the portion of the URL after the scheme\n   * scheme             - the URL scheme; for web traffic, this will be \"http\" or \"https\"\n   * standardizedURL    - the URL with any path components of \"..\" or \".\" normalized.  The use of \"..\" that would cause the URL to refer to something preceding its root is simply removed.\n   * URL                - the URL as it was provided to this function (no changes)\n   * user               - the user name specified in the URL.  Note that this is not the user name that would be entered when using Basic or Digest authentication; rather it is a user name included in the URL itself -- for security reasons, use of this field has been deprecated in most situations and modern browsers will often prompt for confirmation before allowing URL's which contain a user name to be transmitted.\n\nNotes:\n * This function differs from the similar function `hs.http.urlParts` in a few ways:\n   * To simplify the logic used by this module to determine if a request for a directory is properly terminated with a \"/\", the path components returned by this function do not remove this character from the component, if present.\n   * Some extraneous or duplicate keys have been removed.\n   * This function is patterned after RFC 3986 while `hs.http.urlParts` uses OS X API functions which are patterned after RFC 1808. RFC 3986 obsoletes 1808.  The primary distinction that affects this module is in regards to `parameters` for path components in the URI -- RFC 3986 disallows them in schema based URI's (like the URL's that are used for web based traffic)."
    },
    "Sets the HTTP response type for the content being generated to maintype/subtype.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.contentheader(maintype, subtype) -> none",
        "body": "hs.httpserver.hsminweb.cgilua.contentheader(${1:maintype}, ${2:subtype})",
        "description": "Sets the HTTP response type for the content being generated to maintype/subtype.\n\nParameters:\n * maintype - the primary content type (e.g. \"text\")\n * subtype  - the sub-type for the content (e.g. \"plain\")\n\nReturns:\n * None\n\nNotes:\n * This sets the `Content-Type` header field for the HTTP response being generated.  This will override any previous setting, including the default of \"text/html\"."
    },
    "Executes a lua file (given by filepath) if it exists.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.doif(filename) -> results",
        "body": "hs.httpserver.hsminweb.cgilua.doif(${1:filename})",
        "description": "Executes a lua file (given by filepath) if it exists.\n\nParameters:\n * filepath - the file to interpret as Lua code\n\nReturns:\n * the values returned by the execution, or nil followed by an error message if the file does not exists.\n\nNotes:\n * This function only interprets the file if it exists; if the file does not exist, it returns an error to the calling code (not the web client)\n * During the processing of a web request, the local directory is temporarily changed to match the local directory of the path of the file being served, as determined by the URL of the request.  This is usually different than the Hammerspoon default directory which corresponds to the directory which contains the `init.lua` file for Hammerspoon."
    },
    "Executes a lua file (given by filepath).": {
        "prefix": "hs.httpserver.hsminweb.cgilua.doscript(filename) -> results",
        "body": "hs.httpserver.hsminweb.cgilua.doscript(${1:filename})",
        "description": "Executes a lua file (given by filepath).\n\nParameters:\n * filepath - the file to interpret as Lua code\n\nReturns:\n * the values returned by the execution, or nil followed by an error message if the file does not exists.\n\nNotes:\n * If the file does not exist, an Internal Server error is returned to the client and an error is logged to the Hammerspoon console.\n * During the processing of a web request, the local directory is temporarily changed to match the local directory of the path of the file being served, as determined by the URL of the request.  This is usually different than the Hammerspoon default directory which corresponds to the directory which contains the `init.lua` file for Hammerspoon."
    },
    "Sends the message to the `hs.httpserver.hsminweb` log, tagged as an error.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.errorlog(msg) -> nil",
        "body": "hs.httpserver.hsminweb.cgilua.errorlog(${1:msg})",
        "description": "Sends the message to the `hs.httpserver.hsminweb` log, tagged as an error.\n\nParameters:\n * msg - the message to send to the module's error log\n\nReturns:\n * None\n\nNotes:\n * Available within a lua template file as `cgilua.errorlog`\n * By default, messages logged with this method will appear in the Hammerspoon console and are available in the `hs.logger` history."
    },
    "Sets the HTTP response header `key` to `value`": {
        "prefix": "hs.httpserver.hsminweb.cgilua.header(key, value) -> none",
        "body": "hs.httpserver.hsminweb.cgilua.header(${1:key}, ${2:value})",
        "description": "Sets the HTTP response header `key` to `value`\n\nParameters:\n * key - the HTTP response header to set a value to.  This should be a string.\n * value - the value for the header.  This should be a string or a value representable as a string.\n\nReturns:\n * None\n\nNotes:\n * You should not use this function to set the value for the \"Content-Type\" key; instead use [cgilua.contentheader](#contentheader) or [cgilua.htmlheader](#htmlheader)."
    },
    "Sets the HTTP response type to \"text/html\"": {
        "prefix": "hs.httpserver.hsminweb.cgilua.htmlheader() -> none",
        "body": "hs.httpserver.hsminweb.cgilua.htmlheader()",
        "description": "Sets the HTTP response type to \"text/html\"\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This sets the `Content-Type` header field for the HTTP response being generated to \"text/html\".  This is the default value, so generally you should not need to call this function unless you have previously changed it with the [cgilua.contentheader](#contentheader) function."
    },
    "Returns an absolute URL for the given URI by prepending the path with the scheme, hostname, and port of this web server.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.mkabsoluteurl(uri) -> string",
        "body": "hs.httpserver.hsminweb.cgilua.mkabsoluteurl(${1:uri})",
        "description": "Returns an absolute URL for the given URI by prepending the path with the scheme, hostname, and port of this web server.\n\nParameters:\n * URI - A path to a resource served by this web server.  A \"/\" will be prepended to the path if it is not present.\n\nReturns:\n * An absolute URL for the given path of the form \"scheme://hostname:port/path\" where `scheme` will be either \"http\" or \"https\", and the hostname and port will match that of this web server.\n\nNotes:\n * If you wish to append query items to the path or expand a relative path into it's full path, see [cgilua.mkurlpath](#mkurlpath)."
    },
    "Creates a full document URI from a partial URI, including query arguments if present.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.mkurlpath(uri, [args]) -> string",
        "body": "hs.httpserver.hsminweb.cgilua.mkurlpath(${1:uri}, ${2:[args]})",
        "description": "Creates a full document URI from a partial URI, including query arguments if present.\n\nParameters:\n * uri  - the full or partial URI (path and file component of a URL) of the document\n * args - an optional table which should have key-value pairs that will be encoded to form a valid query at the end of the URI (see [cgilua.urlcode.encodetable](#encodetable).\n\nReturns:\n * A full URI including any query arguments, if present.\n\nNotes:\n * This function is intended to be used in conjunction with [cgilua.mkabsoluteurl](#mkabsoluteurl) to generate a full URL.  If the `uri` provided does not begin with a \"/\", then the current directory path is prepended to the uri and any query arguments are appended.\n * e.g. `cgilua.mkabsoluteurl(cgiurl.mkurlpath(\"file.lp\", { key = value, ... }))` will return a full URL specifying the file `file.lp` in the current directory with the specified key-value pairs as query arguments."
    },
    "Appends the given arguments to the response body.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.print(...) -> nil",
        "body": "hs.httpserver.hsminweb.cgilua.print(${1:...})",
        "description": "Appends the given arguments to the response body.\n\nParameters:\n * ... - a list of comma separated arguments to add to the response body\n\nReturns:\n * None\n\nNotes:\n * Available within a lua template file as `cgilua.print`\n * This function works like the lua builtin `print` command in that it converts all its arguments to strings, separates them with tabs (`\\t`), and ends the line with a newline (`\\n`) before appending them to the current response body."
    },
    "Appends the given arguments to the response body._1": {
        "prefix": "hs.httpserver.hsminweb.cgilua.put(...) -> nil",
        "body": "hs.httpserver.hsminweb.cgilua.put(${1:...})",
        "description": "Appends the given arguments to the response body.\n\nParameters:\n * ... - a list of comma separated arguments to add to the response body\n\nReturns:\n * None\n\nNotes:\n * Available within a lua template file as `cgilua.put`\n * This function works by flattening tables and converting all values except for `nil` and `false` to their string representation and then appending them in order to the response body. Unlike `cgilua.print`, it does not separate values with a tab character or terminate the line with a newline character."
    },
    "Sends the headers to force a redirection to the given URL adding the parameters in table args to the new URL.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.redirect(url, [args]) -> none",
        "body": "hs.httpserver.hsminweb.cgilua.redirect(${1:url}, ${2:[args]})",
        "description": "Sends the headers to force a redirection to the given URL adding the parameters in table args to the new URL.\n\nParameters:\n * url  - the URL the client should be redirected to\n * args - an optional table which should have key-value pairs that will be encoded to form a valid query at the end of the URL (see [cgilua.urlcode.encodetable](#encodetable).\n\nReturns:\n * None\n\nNotes:\n * This function should generally be followed by a `return` in your lua template page as no additional processing or output should occur when a request is to be redirected."
    },
    "The file name of the running script. Obtained from cgilua.script_path.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.script_file",
        "body": "hs.httpserver.hsminweb.cgilua.script_file",
        "description": "The file name of the running script. Obtained from cgilua.script_path.\n\nNotes:\n * CGILua supports being invoked through a URL that amounts to set of chained paths and script names; this is not necessary for this module, so these variables may differ somewhat from a true CGILua installation; the intent of the variable has been maintained as closely as I can determine at present.  If this changes, so will this documentation."
    },
    "The system path of the running script. Equivalent to the CGI environment variable SCRIPT_FILENAME.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.script_path",
        "body": "hs.httpserver.hsminweb.cgilua.script_path",
        "description": "The system path of the running script. Equivalent to the CGI environment variable SCRIPT_FILENAME.\n\nNotes:\n * CGILua supports being invoked through a URL that amounts to set of chained paths and script names; this is not necessary for this module, so these variables may differ somewhat from a true CGILua installation; the intent of the variable has been maintained as closely as I can determine at present.  If this changes, so will this documentation."
    },
    "The directory of the running script. Obtained from cgilua.script_path.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.script_pdir",
        "body": "hs.httpserver.hsminweb.cgilua.script_pdir",
        "description": "The directory of the running script. Obtained from cgilua.script_path.\n\nNotes:\n * CGILua supports being invoked through a URL that amounts to set of chained paths and script names; this is not necessary for this module, so these variables may differ somewhat from a true CGILua installation; the intent of the variable has been maintained as closely as I can determine at present.  If this changes, so will this documentation."
    },
    "If PATH_INFO represents a directory (i.e. ends with \"/\"), then this is equal to `cgilua.script_vpath`.  Otherwise, this contains the directory portion of `cgilua.script_vpath`.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.script_vdir",
        "body": "hs.httpserver.hsminweb.cgilua.script_vdir",
        "description": "If PATH_INFO represents a directory (i.e. ends with \"/\"), then this is equal to `cgilua.script_vpath`.  Otherwise, this contains the directory portion of `cgilua.script_vpath`.\n\nNotes:\n * CGILua supports being invoked through a URL that amounts to set of chained paths and script names; this is not necessary for this module, so these variables may differ somewhat from a true CGILua installation; the intent of the variable has been maintained as closely as I can determine at present.  If this changes, so will this documentation."
    },
    "Equivalent to the CGI environment variable PATH_INFO or \"/\", if no PATH_INFO is set.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.script_vpath",
        "body": "hs.httpserver.hsminweb.cgilua.script_vpath",
        "description": "Equivalent to the CGI environment variable PATH_INFO or \"/\", if no PATH_INFO is set.\n\nNotes:\n * CGILua supports being invoked through a URL that amounts to set of chained paths and script names; this is not necessary for this module, so these variables may differ somewhat from a true CGILua installation; the intent of the variable has been maintained as closely as I can determine at present.  If this changes, so will this documentation."
    },
    "Returns a string with the value of the CGI environment variable correspoding to varname.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.servervariable(varname) -> string",
        "body": "hs.httpserver.hsminweb.cgilua.servervariable(${1:varname})",
        "description": "Returns a string with the value of the CGI environment variable correspoding to varname.\n\nParameters:\n * varname - the name of the CGI variable to get the value of.\n\nReturns:\n * the value of the CGI variable as a string, or nil if no such variable exists.\n\nNotes:\n * CGI Variables include server defined values commonly shared with CGI scripts and the HTTP request headers from the web request.  The server variables include the following (note that depending upon the request and type of resource the URL refers to, not all values may exist for every request):\n   * \"AUTH_TYPE\"         - If the server supports user authentication, and the script is protected, this is the protocol-specific authentication method used to validate the user.\n   * \"CONTENT_LENGTH\"    - The length of the content itself as given by the client.\n   * \"CONTENT_TYPE\"      - For queries which have attached information, such as HTTP POST and PUT, this is the content type of the data.\n   * \"DOCUMENT_ROOT\"     - the real directory on the server that corresponds to a DOCUMENT_URI of \"/\".  This is the first directory which contains files or sub-directories which are served by the web server.\n   * \"DOCUMENT_URI\"      - the path portion of the HTTP URL requested\n   * \"GATEWAY_INTERFACE\" - The revision of the CGI specification to which this server complies. Format: CGI/revision\n   * \"PATH_INFO\"         - The extra path information, as given by the client. In other words, scripts can be accessed by their virtual pathname, followed by extra information at the end of this path. The extra information is sent as PATH_INFO. This information should be decoded by the server if it comes from a URL before it is passed to the CGI script.\n   * \"PATH_TRANSLATED\"   - The server provides a translated version of PATH_INFO, which takes the path and does any virtual-to-physical mapping to it.\n   * \"QUERY_STRING\"      - The information which follows the \"?\" in the URL which referenced this script. This is the query information. It should not be decoded in any fashion. This variable should always be set when there is query information, regardless of command line decoding.\n   * \"REMOTE_ADDR\"       - The IP address of the remote host making the request.\n   * \"REMOTE_HOST\"       - The hostname making the request. If the server does not have this information, it should set REMOTE_ADDR and leave this unset.\n   * \"REMOTE_IDENT\"      - If the HTTP server supports RFC 931 identification, then this variable will be set to the remote user name retrieved from the server. Usage of this variable should be limited to logging only.\n   * \"REMOTE_USER\"       - If the server supports user authentication, and the script is protected, this is the username they have authenticated as.\n   * \"REQUEST_METHOD\"    - The method with which the request was made. For HTTP, this is \"GET\", \"HEAD\", \"POST\", etc.\n   * \"REQUEST_TIME\"      - the time the server received the request represented as the number of seconds since 00:00:00 UTC on 1 January 1970.  Usable with `os.date` to provide the date and time in whatever format you require.\n   * \"REQUEST_URI\"       - the DOCUMENT_URI with any query string present in the request appended.  Usually this corresponds to the URL without the scheme or host information.\n   * \"SCRIPT_FILENAME\"   - the actual path to the script being executed.\n   * \"SCRIPT_NAME\"       - A virtual path to the script being executed, used for self-referencing URLs.\n   * \"SERVER_NAME\"       - The server's hostname, DNS alias, or IP address as it would appear in self-referencing URLs.\n   * \"SERVER_PORT\"       - The port number to which the request was sent.\n   * \"SERVER_PROTOCOL\"   - The name and revision of the information protcol this request came in with. Format: protocol/revision\n   * \"SERVER_SOFTWARE\"   - The name and version of the web server software answering the request (and running the gateway). Format: name/version\n\n* The HTTP Request header names are prefixed with \"HTTP_\", converted to all uppercase, and have all hyphens converted into underscores.  Common headers (converted to their CGI format) might include, but are not limited to:\n   * HTTP_ACCEPT, HTTP_ACCEPT_ENCODING, HTTP_ACCEPT_LANGUAGE, HTTP_CACHE_CONTROL, HTTP_CONNECTION, HTTP_DNT, HTTP_HOST, HTTP_USER_AGENT\n * This server also defines the following (which are replicated in the CGI variables above, so those should be used for portability):\n   * HTTP_X_REMOTE_ADDR, HTTP_X_REMOTE_PORT, HTTP_X_SERVER_ADDR, HTTP_X_SERVER_PORT\n * A list of common request headers and their definitions can be found at https://en.wikipedia.org/wiki/List_of_HTTP_header_fields"
    },
    "Returns two strings with the \"first directory\" and the \"remaining paht\" of the given path string splitted on the first separator (\"/\" or \"\\\").": {
        "prefix": "hs.httpserver.hsminweb.cgilua.splitfirst(path) -> path component, path remainder",
        "body": "hs.httpserver.hsminweb.cgilua.splitfirst(${1:path})",
        "description": "Returns two strings with the \"first directory\" and the \"remaining paht\" of the given path string splitted on the first separator (\"/\" or \"\\\").\n\nParameters:\n * path - the path to split\n\nReturns:\n * the first directory component, the remainder of the path"
    },
    "Returns two strings with the \"directory path\" and \"file\" parts of the given path string splitted on the last separator (\"/\" or \"\\\").": {
        "prefix": "hs.httpserver.hsminweb.cgilua.splitonlast(path) -> directory, file",
        "body": "hs.httpserver.hsminweb.cgilua.splitonlast(${1:path})",
        "description": "Returns two strings with the \"directory path\" and \"file\" parts of the given path string splitted on the last separator (\"/\" or \"\\\").\n\nParameters:\n * path - the path to split\n\nReturns:\n * the directory path, the file\n\nNotes:\n * This function used to be called cgilua.splitpath and still can be accessed by this name for compatibility reasons. cgilua.splitpath may be deprecated in future versions."
    },
    "The directory used by `cgilua.tmpfile`": {
        "prefix": "hs.httpserver.hsminweb.cgilua.tmp_path",
        "body": "hs.httpserver.hsminweb.cgilua.tmp_path",
        "description": "The directory used by `cgilua.tmpfile`\n\nThis variable contains the location where temporary files should be created.  Defaults to the user's temporary directory as returned by `hs.fs.temporaryDirectory`."
    },
    "Returns the file handle to a temporary file for writing, or nil and an error message if the file could not be created for any reason.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.tmpfile([dir], [namefunction]) -> file[, err]",
        "body": "hs.httpserver.hsminweb.cgilua.tmpfile(${1:[dir]}, ${2:[namefunction]})",
        "description": "Returns the file handle to a temporary file for writing, or nil and an error message if the file could not be created for any reason.\n\nParameters:\n * dir          - the system directory where the temporary file should be created.  Defaults to `cgilua.tmp_path`.\n * namefunction - an optional function used to generate unique file names for use as temporary files.  Defaults to `cgilua.tmpname`.\n\nReturns:\n * the created file's handle and the filename or nil and an error message if the file could not be created.\n\nNotes:\n * The file is automatically deleted when the HTTP request has been completed, so if you need for the data to persist, make sure to `io.flush` or `io.close` the file handle yourself and copy the file to a more permanent location."
    },
    "Returns a temporary file name used by `cgilua.tmpfile`.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.tmpname() -> string",
        "body": "hs.httpserver.hsminweb.cgilua.tmpname()",
        "description": "Returns a temporary file name used by `cgilua.tmpfile`.\n\nParameters:\n * None\n\nReturns:\n * a temporary filename, without the path.\n\nNotes:\n * This function uses `hs.host.globallyUniqueString` to generate a unique file name."
    },
    "The name of the script as requested in the URL. Equivalent to the CGI environment variable SCRIPT_NAME.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.urlpath",
        "body": "hs.httpserver.hsminweb.cgilua.urlpath",
        "description": "The name of the script as requested in the URL. Equivalent to the CGI environment variable SCRIPT_NAME.\n\nNotes:\n * CGILua supports being invoked through a URL that amounts to set of chained paths and script names; this is not necessary for this module, so these variables may differ somewhat from a true CGILua installation; the intent of the variable has been maintained as closely as I can determine at present.  If this changes, so will this documentation."
    },
    "Converts the specified Lua template source into a Lua function.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.lp.compile(source, name, [env]) -> function",
        "body": "hs.httpserver.hsminweb.cgilua.lp.compile(${1:source}, ${2:name}, ${3:[env]})",
        "description": "Converts the specified Lua template source into a Lua function.\n\nParameters:\n * source - a string containing the contents of a Lua/HTML template to be converted into a function\n * name   - a label used in an error message if execution of the returned function results in a run-time error\n * env    - an optional table specifying the environment to be used by the lua builtin function `load` when converting the source into a function.  By default, the function will inherit its caller's environment.\n\nReturns:\n * A lua function which should take no arguments.\n\nNotes:\n * The source provided is first compared to a stored cache of previously translated templates and will re-use an existing translation if the template has been seen before.  If the source is unique, [cgilua.lp.translate](#translate) is called on the template source.\n * This function is used internally by [cgilua.lp.include](#include), and probably won't be useful unless you want to translate a dynamically generated template -- which has security implications, depending upon what inputs you use to generate this template, because the resulting Lua code will execute within your Hammerspoon environment.  Be very careful about your inputs if you choose to ignore this warning."
    },
    "Includes the template specified by the `file` parameter.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.lp.include(file, [env]) -> none",
        "body": "hs.httpserver.hsminweb.cgilua.lp.include(${1:file}, ${2:[env]})",
        "description": "Includes the template specified by the `file` parameter.\n\nParameters:\n * file - a string containing the file system path to the template to include.\n * env  - an optional table specifying the environment to be used by the included template.  By default, the template will inherit its caller's environment.\n\nReturns:\n * None\n\nNotes:\n* This function is called by the web server to process the template specified by the requested URL.  Subsequent invocations of this function can be used to include common or re-used code from other template files and will be included in-line where the `cgilua.lp.include` function is invoked in the originating template.\n * During the processing of a web request, the local directory is temporarily changed to match the local directory of the path of the file being served, as determined by the URL of the request.  This is usually different than the Hammerspoon default directory which corresponds to the directory which contains the `init.lua` file for Hammerspoon.\n\n* The default template environment provides the following:\n  * the `__index` metamethod points to the `_G` environment variable in the Hammerspoon Lua instance; this means that any global variable in the Hammerspoon environment is available to the lua code in a template file.\n  * the `__newindex` metamethod points to a function which creates new \"global\" variables in the template files environment; this means that if a template includes another template file, and that second template file creates a \"global\" variable, that new variable will be available in the environment of the calling template, but will not be shared with the Hammerspoon global variable space;  \"global\" variables created in this manner will be released when the HTTP request is completed.\n\n  * `print` is overridden so that its output is streamed into the response body to be returned when the web request completes.  It follows the traditional pattern of the `print` builtin function: multiple arguments are separated by a tab character, the output is terminated with a new-line character, non-string arguments are converted to strings via the `tostring` builtin function.\n  * `write` is defined as an alternative to `print` and differs in the following ways from the `print` function described above:  no intermediate tabs or newline are included in the output streamed to the response body.\n  * `cgilua` is defined as a table containing all of the functions included in this support sub-module.\n  * `hsminweb` is defined as a table which contains the following tables which may be of use:\n    * CGIVariables - a table containing key-value pairs of the same data available through the [cgilua.servervariable](#servervariable) function.\n    * id           - a string, generated via `hs.host.globallyUniqueString`, unique to this specific HTTP request.\n    * log          - a table/object representing the `hs.httpserver.hsminweb` instance of `hs.logger`.  This can be used to log messages to the Hammerspoon console as described in the documentation for `hs.logger`.\n    * request      - a table containing data representing the details of the HTTP request as it was made by the web client to the server.  The following keys are commonly found:\n      * headers - a table containing key-value pairs representing the headers included in the HTTP request; unlike the values available through [cgilua.servervariable](#servervariable) or found in `CGIVariables`, these are available in their raw form.\n        * this table also contains a table with the key \"_\".  This table contains functions and data used internally, and is described more fully in a supporting document (TBD).  It is targeted primarily at custom error functions designed for use with `hs.httpserver.hsminweb` and should not generally be necessary for Lua template files.\n      * method  - the method of the HTTP request, most commonly \"GET\" or \"POST\"\n      * path    - the path portion of the requested URL.\n    * response     - a table containing data representing the response being formed for the response to the HTTP request.  This is generally handled for you by the `cgilua` support functions, but for special cases, you can modify it directly; this should contain only the following keys:\n      * body    - a string containing the response body.  As the lua template outputs content, this string is appended to.\n      * code    - an integer representing the currently expected response code for the HTTP request.\n      * headers - a table containing key-value pairs of the currently defined response headers\n    * _tmpfiles    - used internally to track temporary files used in the completion of this HTTP request; do not modify directly."
    },
    "Converts the specified Lua template source into Lua code executable within the Hammerspoon environment.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.lp.translate(source) -> luaCode",
        "body": "hs.httpserver.hsminweb.cgilua.lp.translate(${1:source})",
        "description": "Converts the specified Lua template source into Lua code executable within the Hammerspoon environment.\n\nParameters:\n * source - a string containing the contents of a Lua/HTML template to be converted into true Lua code\n\nReturns:\n * The lua code corresponding to the provided source which can be fed into the `load` lua builtin to generate a Lua function.\n\nNotes:\n * This function is used internally by [cgilua.lp.include](#include), and probably won't be useful unless you want to translate a dynamically generated template -- which has security implications, depending upon what inputs you use to generate this template, because the resulting Lua code will execute within your Hammerspoon environment.  Be very careful about your inputs if you choose to ignore this warning.\n * To ensure that the translated code has access to the `cgilua` support functions, pass `_ENV` as the environment argument to the `load` lua builtin; otherwise any output generated by the resulting function will be sent to the Hammerspoon console and not included in the HTTP response sent back to the client."
    },
    "Encodes the table of key-value pairs as a query string suitable for inclusion in a URL.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.urlcode.encodetable(table) -> string",
        "body": "hs.httpserver.hsminweb.cgilua.urlcode.encode${1:table}(table)",
        "description": "Encodes the table of key-value pairs as a query string suitable for inclusion in a URL.\n\nParameters:\n * table - a table of key-value pairs to be converted into a query string\n\nReturns:\n * a query string as specified in RFC 3986.\n\nNotes:\n * the string will be of the form: \"key1=value1&key2=value2...\" where all of the keys and values are properly escaped using [cgilua.urlcode.escape](#escape).  If you are crafting a URL by hand, the result of this function should be appended to the end of the URL after a \"?\" character to specify where the query string begins."
    },
    "URL encodes the provided string, making it safe as a component within a URL.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.urlcode.escape(string) -> string",
        "body": "hs.httpserver.hsminweb.cgilua.urlcode.escape(${1:string})",
        "description": "URL encodes the provided string, making it safe as a component within a URL.\n\nParameters:\n * string - the string to encode\n\nReturns:\n * a string with non-alphanumeric characters percent encoded and spaces converted into \"+\" as per RFC 3986.\n\nNotes:\n * this function assumes that the provided string is a single component and URL encodes *all* non-alphanumeric characters.  Do not use this function to generate a URL query string -- use [cgilua.urlcode.encodetable](#encodetable)."
    },
    "Inserts the specified key and value into the table of key-value pairs.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.urlcode.insertfield(table, key, value) -> none",
        "body": "hs.httpserver.hsminweb.cgilua.urlcode.insertfield(${1:table}, ${2:key}, ${3:value})",
        "description": "Inserts the specified key and value into the table of key-value pairs.\n\nParameters:\n * table - the table of arguments being built\n * key   - the key name\n * value - the value to assign to the key specified\n\nReturns:\n * None\n\nNotes:\n * If the key already exists in the table, its value is converted to a table (if it isn't already) and the new value is added to the end of the array of values for the key.\n * This function is used internally by [cgilua.urlcode.parsequery](#parsequery) or can be used to prepare a table of key-value pairs for [cgilua.urlcode.encodetable](#encodetable)."
    },
    "Parse the query string and store the key-value pairs in the provided table.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.urlcode.parsequery(query, table) -> none",
        "body": "hs.httpserver.hsminweb.cgilua.urlcode.parse${1:query}(query, ${2:table})",
        "description": "Parse the query string and store the key-value pairs in the provided table.\n\nParameters:\n * query - a URL encoded query string, either from a URL or from the body of a POST request encoded in the \"x-www-form-urlencoded\" format.\n * table - the table to add the key-value pairs to\n\nReturns:\n * None\n\nNotes:\n * The specification allows for the same key to be assigned multiple values in an encoded string, but does not specify the behavior; by convention, web servers assign these multiple values to the same key in an array (table).  This function follows that convention.  This is most commonly used by forms which allow selecting multiple options via check boxes or in a selection list.\n * This function uses [cgilua.urlcode.insertfield](#insertfield) to build the key-value table."
    },
    "Removes any URL encoding in the provided string.": {
        "prefix": "hs.httpserver.hsminweb.cgilua.urlcode.unescape(string) -> string",
        "body": "hs.httpserver.hsminweb.cgilua.urlcode.unescape(${1:string})",
        "description": "Removes any URL encoding in the provided string.\n\nParameters:\n * string - the string to decode\n\nReturns:\n * a string with all \"+\" characters converted to spaces and all percent encoded sequences converted to their ascii equivalents."
    },
    "Table of arrays containing the names of additional internal system images which may also be available for use with `hs.drawing.image` and [hs.image.imageFromName](#imageFromName).": {
        "prefix": "hs.image.additionalImageNames[]",
        "body": "hs.image.additionalImageNames",
        "description": "Table of arrays containing the names of additional internal system images which may also be available for use with `hs.drawing.image` and [hs.image.imageFromName](#imageFromName).\n\nNotes:\n * The list of these images was pulled from a collection located in the repositories at https://github.com/hetima?tab=repositories.  As these image names are (for the most part) not formally listed in Apple's documentation or published APIs, their use cannot be guaranteed across all OS X versions.  If you identify any images which may be missing or could be added, please file an issue at https://github.com/Hammerspoon/hammerspoon."
    },
    "Reads the color of the pixel at the specified location.": {
        "prefix": "hs.image:colorAt(point) -> table",
        "body": "hs.image:colorAt(${1:point})",
        "description": "Reads the color of the pixel at the specified location.\n\nParameters:\n * `point` - a `hs.geometry.point`\n\nReturns:\n * A `hs.drawing.color` object"
    },
    "Returns a copy of the image": {
        "prefix": "hs.image:copy() -> imageObject",
        "body": "hs.image:copy()",
        "description": "Returns a copy of the image\n\nParameters:\n * None\n\nReturns:\n * a new hs.image object"
    },
    "Returns a copy of the portion of the image specified by the rectangle specified.": {
        "prefix": "hs.image:croppedCopy(rectangle) -> object",
        "body": "hs.image:croppedCopy(${1:rectangle})",
        "description": "Returns a copy of the portion of the image specified by the rectangle specified.\n\nParameters:\n * rectangle - a table with 'x', 'y', 'h', and 'w' keys specifying the portion of the image to return in the new image.\n\nReturns:\n * a copy of the portion of the image specified"
    },
    "Returns a bitmap representation of the image as a base64 encoded URL string": {
        "prefix": "hs.image:encodeAsURLString([scale], [type]) -> string",
        "body": "hs.image:encodeAsURLString(${1:[scale]}, ${2:[type]})",
        "description": "Returns a bitmap representation of the image as a base64 encoded URL string\n\nParameters:\n * scale - an optional boolean, default false, which indicates that the image size (which macOS represents as points) should be scaled to pixels.  For images that have Retina scale representations, this may result in an encoded image which is scaled down from the original source.\n * type  - optional case-insensitive string paramater specifying the bitmap image type for the encoded string (default PNG)\n   * PNG  - save in Portable Network Graphics (PNG) format\n   * TIFF - save in Tagged Image File Format (TIFF) format\n   * BMP  - save in Windows bitmap image (BMP) format\n   * GIF  - save in Graphics Image Format (GIF) format\n   * JPEG - save in Joint Photographic Experts Group (JPEG) format\n\nReturns:\n * the bitmap image representation as a Base64 encoded string\n\nNotes:\n * You can convert the string back into an image object with [hs.image.imageFromURL](#URL), e.g. `hs.image.imageFromURL(string)`"
    },
    "Gets the EXIF metadata information from an image file.": {
        "prefix": "hs.image.getExifFromPath(path) -> table | nil",
        "body": "hs.image.getExifFromPath(${1:path})",
        "description": "Gets the EXIF metadata information from an image file.\n\nParameters:\n * path - The path to the image file.\n\nReturns:\n * A table of EXIF metadata, or `nil` if no metadata can be found or the file path is invalid."
    },
    "Creates an `hs.image` object for the file or files specified": {
        "prefix": "hs.image.iconForFile(file) -> object",
        "body": "hs.image.iconForFile(${1:file})",
        "description": "Creates an `hs.image` object for the file or files specified\n\nParameters:\n * file - the path to a file or an array of files to generate an icon for.\n\nReturns:\n * An `hs.image` object or nil, if there was an error.  The image will be the icon for the specified file or an icon representing multiple files if an array of multiple files is specified."
    },
    "Creates an `hs.image` object of the icon for the specified file type.": {
        "prefix": "hs.image.iconForFileType(fileType) -> object",
        "body": "hs.image.iconForFileType(${1:fileType})",
        "description": "Creates an `hs.image` object of the icon for the specified file type.\n\nParameters:\n * fileType - the file type, specified as a filename extension or a universal type identifier (UTI).\n\nReturns:\n * An `hs.image` object or nil, if there was an error"
    },
    "Creates an `hs.image` object using the icon from an App": {
        "prefix": "hs.image.imageFromAppBundle(bundleID) -> object",
        "body": "hs.image.imageFromAppBundle(${1:bundleID})",
        "description": "Creates an `hs.image` object using the icon from an App\n\nParameters:\n * bundleID - A string containing the bundle identifier of an application\n\nReturns:\n * An `hs.image` object or nil, if no app icon was found"
    },
    "Creates an image from an ASCII representation with the specified context.": {
        "prefix": "hs.image.imageFromASCII(ascii[, context]) -> object",
        "body": "hs.image.imageFromASCII(${1:ascii[}, ${2:context]})",
        "description": "Creates an image from an ASCII representation with the specified context.\n\nParameters:\n * ascii - A string containing a representation of an image\n * context - An optional table containing the context for each shape in the image.  A shape is considered a single drawing element (point, ellipse, line, or polygon) as defined at https://github.com/cparnot/ASCIImage and http://cocoamine.net/blog/2015/03/20/replacing-photoshop-with-nsstring/.\n   * The context table is an optional (possibly sparse) array in which the index represents the order in which the shapes are defined.  The last (highest) numbered index in the sparse array specifies the default settings for any unspecified index and any settings which are not explicitly set in any other given index.\n   * Each index consists of a table which can contain one or more of the following keys:\n     * fillColor - the color with which the shape will be filled (defaults to black)  Color is defined in a table containing color component values between 0.0 and 1.0 for each of the keys:\n       * red (default 0.0)\n       * green (default 0.0)\n       * blue (default 0.0)\n       * alpha (default 1.0)\n     * strokeColor - the color with which the shape will be stroked (defaults to black)\n     * lineWidth - the line width (number) for the stroke of the shape (defaults to 1 if anti-aliasing is on or (\u221a2)/2 if it is off -- approximately 0.7)\n     * shouldClose - a boolean indicating whether or not the shape should be closed (defaults to true)\n     * antialias - a boolean indicating whether or not the shape should be antialiased (defaults to true)\n\nReturns:\n * An `hs.image` object, or nil if an error occured\n\nNotes:\n * To use the ASCII diagram image support, see https://github.com/cparnot/ASCIImage and http://cocoamine.net/blog/2015/03/20/replacing-photoshop-with-nsstring\n * The default for lineWidth, when antialiasing is off, is defined within the ASCIImage library. Geometrically it represents one half of the hypotenuse of the unit right-triangle and is a more accurate representation of a \"real\" point size when dealing with arbitrary angles and lines than 1.0 would be."
    },
    "Creates an `hs.image` object from a video file or the album artwork of an audio file or directory": {
        "prefix": "hs.image.imageFromMediaFile(file) -> object",
        "body": "hs.image.imageFromMediaFile(${1:file})",
        "description": "Creates an `hs.image` object from a video file or the album artwork of an audio file or directory\n\nParameters:\n * file - A string containing the path to an audio or video file or an album directory\n\nReturns:\n * An `hs.image` object\n\nNotes:\n * If a thumbnail can be generated for a video file, it is returned as an `hs.image` object, otherwise the filetype icon\n * For audio files, this function first determines the containing directory (if not already a directory)\n * It checks if any of the following common filenames for album art are present:\n  * cover.jpg\n  * front.jpg\n  * art.jpg\n  * album.jpg\n  * folder.jpg\n * If one of the common album art filenames is found, it is returned as an `hs.image` object\n * This is faster than extracting image metadata and allows for obtaining artwork associated with file formats such as .flac/.ogg\n * If no common album art filenames are found, it attempts to extract image metadata from the file. This works for .mp3/.m4a files\n * If embedded image metadata is found, it is returned as an `hs.image` object, otherwise the filetype icon"
    },
    "Returns the hs.image object for the specified name, if it exists.": {
        "prefix": "hs.image.imageFromName(string) -> object",
        "body": "hs.image.imageFromName(${1:string})",
        "description": "Returns the hs.image object for the specified name, if it exists.\n\nParameters:\n * Name - the name of the image to return.\n\nReturns:\n * An hs.image object or nil, if no image was found with the specified name.\n\nNotes:\n * Some predefined labels corresponding to OS X System default images can be found in `hs.image.systemImageNames`.\n * Names are not required to be unique: The search order is as follows, and the first match found is returned:\n    * an image whose name was explicitly set with the `setName` method since the last full restart of Hammerspoon\n    * Hammerspoon's main application bundle\n    * the Application Kit framework (this is where most of the images listed in `hs.image.systemImageNames` are located)\n * Image names can be assigned by the image creator or by calling the `hs.image:setName` method on an hs.image object."
    },
    "Loads an image file": {
        "prefix": "hs.image.imageFromPath(path) -> object",
        "body": "hs.image.imageFromPath(${1:path})",
        "description": "Loads an image file\n\nParameters:\n * path - A string containing the path to an image file on disk\n\nReturns:\n * An `hs.image` object, or nil if an error occured"
    },
    "Creates an `hs.image` object from the contents of the specified URL.": {
        "prefix": "hs.image.imageFromURL(url[, callbackFn]) -> object",
        "body": "hs.image.imageFromURL(${1:url[}, ${2:callbackFn]})",
        "description": "Creates an `hs.image` object from the contents of the specified URL.\n\nParameters:\n * url - a web url specifying the location of the image to retrieve\n * callbackFn - an optional callback function to be called when the image fetching is complete\n\nReturns:\n * An `hs.image` object or nil, if the url does not specify image contents or is unreachable, or if a callback function is supplied\n\nNotes:\n * If a callback function is supplied, this function will return nil immediately and the image will be fetched asynchronously"
    },
    "Get or set the name of the image represented by the hs.image object.": {
        "prefix": "hs.image:name([name]) -> imageObject | string",
        "body": "hs.image:name(${1:[name]})",
        "description": "Get or set the name of the image represented by the hs.image object.\n\nParameters:\n * `name` - an optional string specifying the new name for the hs.image object.\n\nReturns:\n * if no argument is provided, returns the current name.  If a new name is specified, returns the hs.image object or nil if the name cannot be changed.\n\nNotes:\n * see also [hs.image:setName](#setName) for a variant that returns a boolean instead."
    },
    "Save the hs.image object as an image of type `filetype` to the specified filename.": {
        "prefix": "hs.image:saveToFile(filename, [scale], [filetype]) -> boolean",
        "body": "hs.image:saveToFile(${1:filename}, ${2:[scale]}, ${3:[filetype]})",
        "description": "Save the hs.image object as an image of type `filetype` to the specified filename.\n\nParameters:\n * filename - the path and name of the file to save.\n * scale    - an optional boolean, default false, which indicates that the image size (which macOS represents as points) should be scaled to pixels.  For images that have Retina scale representations, this may result in a saved image which is scaled down from the original source.\n * filetype - optional case-insensitive string paramater specifying the file type to save (default PNG)\n   * PNG  - save in Portable Network Graphics (PNG) format\n   * TIFF - save in Tagged Image File Format (TIFF) format\n   * BMP  - save in Windows bitmap image (BMP) format\n   * GIF  - save in Graphics Image Format (GIF) format\n   * JPEG - save in Joint Photographic Experts Group (JPEG) format\n\nReturns:\n * Status - a boolean value indicating success (true) or failure (false)\n\nNotes:\n * Saves image at the size in points (or pixels, if `scale` is true) as reported by [hs.image:size()](#size) for the image object"
    },
    "Assigns the name assigned to the hs.image object.": {
        "prefix": "hs.image:setName(Name) -> boolean",
        "body": "hs.image:set${1:Name}(Name)",
        "description": "Assigns the name assigned to the hs.image object.\n\nParameters:\n * Name - the name to assign to the hs.image object.\n\nReturns:\n * Status - a boolean value indicating success (true) or failure (false) when assigning the specified name.\n\nNotes:\n * This method is included for backwards compatibility and is considered deprecated.  It is equivalent to `hs.image:name(name) and true or false`."
    },
    "Returns a copy of the image resized to the height and width specified in the size table.": {
        "prefix": "hs.image:setSize(size [, absolute]) -> object",
        "body": "hs.image:setSize(${1:size [}, ${2:absolute]})",
        "description": "Returns a copy of the image resized to the height and width specified in the size table.\n\nParameters:\n * size     - a table with 'h' and 'w' keys specifying the size for the new image.\n * absolute - an optional boolean specifying whether or not the copied image should be resized to the height and width specified (true), or whether the copied image should be scaled proportionally to fit within the height and width specified (false).  Defaults to false.\n\nReturns:\n * a copy of the image object at the new size\n\nNotes:\n * This method is included for backwards compatibility and is considered deprecated.  It is equivalent to `hs.image:copy():size(size, [absolute])`."
    },
    "Get or set the size of the image represented byt he hs.image object.": {
        "prefix": "hs.image:size([size, [absolute]] ) -> imageObject | size",
        "body": "hs.image:size(${1:[size}, ${2:[absolute]]} )",
        "description": "Get or set the size of the image represented byt he hs.image object.\n\nParameters:\n * `size`     - an optional table with 'h' and 'w' keys specifying the size for the image.\n * `absolute` - when specifying a new size, an optional boolean, default false, specifying whether or not the image should be resized to the height and width specified (true), or whether the copied image should be scaled proportionally to fit within the height and width specified (false).\n\nReturns:\n * If arguments are provided, return the hs.image object; otherwise returns the current size\n\nNotes:\n * See also [hs.image:setSize](#setSize) for creating a copy of the image at a new size."
    },
    "Table containing the names of internal system images for use with hs.drawing.image": {
        "prefix": "hs.image.systemImageNames[]",
        "body": "hs.image.systemImageNames",
        "description": "Table containing the names of internal system images for use with hs.drawing.image\n\nNotes:\n * Image names pulled from NSImage.h\n * This table has a __tostring() metamethod which allows listing it's contents in the Hammerspoon console by typing `hs.image.systemImageNames`."
    },
    "Get or set whether the image is considered a template image.": {
        "prefix": "hs.image:template([state]) -> imageObject | boolean",
        "body": "hs.image:template(${1:[state]})",
        "description": "Get or set whether the image is considered a template image.\n\nParameters:\n * `state` - an optional boolean specifying whether or not the image should be a template.\n\nReturns:\n * if a parameter is provided, returns the hs.image object; otherwise returns the current value\n\nNotes:\n * Template images consist of black and clear colors (and an alpha channel). Template images are not intended to be used as standalone images and are usually mixed with other content to create the desired final appearance.\n * Images with this flag set to true usually appear lighter than they would with this flag set to false."
    },
    "Gets a human readable version of the supplied Lua variable": {
        "prefix": "hs.inspect.inspect(variable[, options]) -> string",
        "body": "hs.inspect.inspect(${1:variable[}, ${2:options]})",
        "description": "Gets a human readable version of the supplied Lua variable\n\nParameters:\n * variable - A lua variable of some kind\n * options - An optional table which can be used to influence the inspector. Valid keys are as follows:\n  * depth - A number representing the maximum depth to recurse into `variable`. Below that depth, data will be displayed as `{...}`\n  * newline - A string to use for line breaks. Defaults to `\\n`\n  * indent - A string to use for indentation. Defaults to `  ` (two spaces)\n  * process - A function that will be called for each item. It should accept two arguments, `item` (the current item being processed) and `path` (the item's position in the variable being inspected. The function should either return a processed form of the variable, the original variable itself if it requires no processing, or `nil` to remove the item from the inspected output.\n  * metatables - If `true`, include (and traverse) metatables\n\nReturns:\n * A string containing the human readable version of `variable`\n\nNotes:\n * For convenience, you can call this function as `hs.inspect(variable)`\n * For more information on the options, and some examples, see [the upstream docs](https://github.com/kikito/inspect.lua)"
    },
    "Get or set the terminal escape codes used to produce colorized output in the `hs` command line tool": {
        "prefix": "hs.ipc.cliColors([colors]) -> table",
        "body": "hs.ipc.cliColors(${1:[colors]})",
        "description": "Get or set the terminal escape codes used to produce colorized output in the `hs` command line tool\n\nParameters:\n * colors - an optional table or explicit nil specifying the colors to use when colorizing output for the command line tool.  If you specify an explicit nil, the colors will revert to their defaults.  If you specify a table it must contain one or more of the following keys with the terminal key sequence as a string for the value:\n   * initial - this color is used for the initial tagline when starting the command line tool and for output to the Hammerspoon console that is redirected to the instance.  Defaults to \"\\27[35m\" (foreground magenta).\n   * input   - this color is used for input typed in by the user into the cli instance.  Defaults to \"\\27[33m\" (foreground yellow).\n   * output  - this color is used for output generated by the commands executed within the instance and the results returned.  Defaults to \"\\27[36m\" (foreground cyan).\n   * error   - this color is used for lua errors generated by the commands executed within the instance.  Defaults to \"\\27[31m\" (foreground red).\n\nReturns:\n * a table describing the colors used when colorizing output in the `hs` command line tool.\n\nNotes:\n * For a brief intro into terminal colors, you can visit a web site like this one [http://jafrog.com/2013/11/23/colors-in-terminal.html](http://jafrog.com/2013/11/23/colors-in-terminal.html)\n * Lua doesn't support octal escapes in it's strings, so use `\\x1b` or `\\27` to indicate the `escape` character e.g. `ipc.cliSetColors{ initial = \"\", input = \"\\27[33m\", output = \"\\27[38;5;11m\" }`\n\n * Changes made with this function are saved with `hs.settings` with the following labels and will persist through a reload or restart of Hammerspoon: \"ipc.cli.color_initial\", \"ipc.cli.color_input\", \"ipc.cli.color_output\", and \"ipc.cli.color_error\""
    },
    "See [hs.ipc.cliColors](#cliColors).": {
        "prefix": "hs.ipc.cliSetColors(table) -> table",
        "body": "hs.ipc.cliSetColors(${1:table})",
        "description": "See [hs.ipc.cliColors](#cliColors)."
    },
    "Installs the `hs` command line tool": {
        "prefix": "hs.ipc.cliInstall([path][,silent]) -> bool",
        "body": "hs.ipc.cliInstall(${1:[path][},${2:silent]})",
        "description": "Installs the `hs` command line tool\n\nParameters:\n * path - An optional string containing a path to install the tool in. Defaults to `/usr/local`\n * silent - An optional boolean indicating whether or not to print errors to the Hammerspoon Console\n\nReturns:\n * A boolean, true if the tool was successfully installed, otherwise false\n\nNotes:\n * If this function fails, it is likely that you have some old/broken symlinks. You can use `hs.ipc.cliUninstall()` to forcibly tidy them up"
    },
    "Get or set whether or not the command line tool saves a history of the commands you type.": {
        "prefix": "hs.ipc.cliSaveHistory([state]) -> boolean",
        "body": "hs.ipc.cliSaveHistory(${1:[state]})",
        "description": "Get or set whether or not the command line tool saves a history of the commands you type.\n\nParameters:\n * state - an optional boolean (default false) specifying whether or not a history of the commands you type into the command line tool should be saved between sessions.\n\nReturns:\n * the current, possibly changed, value\n\nNotes:\n * If this is enabled, your history is saved in `hs.configDir .. \".cli.history\"`, which is usually \"~/.hammerspoon/.cli.history\".\n * If you have multiple invocations of the command line tool running at the same time, only the history of the last one cleanly exited is saved; this is a limitation of the readline wrapper Apple has provided for libedit and at present no workaround is known.\n\n * Changes made with this function are saved with `hs.settings` with the label \"ipc.cli.saveHistory\" and will persist through a reload or restart of Hammerspoon."
    },
    "Get or set whether the maximum number of commands saved when command line tool history saving is enabled.": {
        "prefix": "hs.ipc.cliSaveHistorySize([size]) -> number",
        "body": "hs.ipc.cliSaveHistorySize(${1:[size]})",
        "description": "Get or set whether the maximum number of commands saved when command line tool history saving is enabled.\n\nParameters:\n * size - an optional integer (default 1000) specifying the maximum number of commands to save when [hs.ipc.cliSaveHistory](#cliSaveHistory) is set to true.\n\nReturns:\n * the current, possibly changed, value\n\nNotes:\n * When [hs.ipc.cliSaveHistory](#cliSaveHistory) is enabled, your history is saved in `hs.configDir .. \".cli.history\"`, which is usually \"~/.hammerspoon/.cli.history\".\n * If you have multiple invocations of the command line tool running at the same time, only the history of the last one cleanly exited is saved; this is a limitation of the readline wrapper Apple has provided for libedit and at present no workaround is known.\n\n * Changes made with this function are saved with `hs.settings` with the label \"ipc.cli.historyLimit\" and will persist through a reload or restart of Hammerspoon."
    },
    "Gets the status of the `hs` command line tool": {
        "prefix": "hs.ipc.cliStatus([path][,silent]) -> bool",
        "body": "hs.ipc.cliStatus(${1:[path][},${2:silent]})",
        "description": "Gets the status of the `hs` command line tool\n\nParameters:\n * path - An optional string containing a path to look for the `hs` tool. Defaults to `/usr/local`\n * silent - An optional boolean indicating whether or not to print errors to the Hammerspoon Console\n\nReturns:\n * A boolean, true if the `hs` command line tool is correctly installed, otherwise false"
    },
    "Uninstalls the `hs` command line tool": {
        "prefix": "hs.ipc.cliUninstall([path][,silent]) -> bool",
        "body": "hs.ipc.cliUninstall(${1:[path][},${2:silent]})",
        "description": "Uninstalls the `hs` command line tool\n\nParameters:\n * path - An optional string containing a path to remove the tool from. Defaults to `/usr/local`\n * silent - An optional boolean indicating whether or not to print errors to the Hammerspoon Console\n\nReturns:\n * A boolean, true if the tool was successfully removed, otherwise false\n\nNotes:\n * This function used to be very conservative and refuse to remove symlinks it wasn't sure about, but now it will unconditionally remove whatever it finds at `path/bin/hs` and `path/share/man/man1/hs.1`. This is more likely to be useful in situations where this command is actually needed (please open an Issue on GitHub if you disagree!)"
    },
    "Deletes the ipcObject, stopping it as well if necessary": {
        "prefix": "hs.ipc:delete() -> None",
        "body": "hs.ipc:delete()",
        "description": "Deletes the ipcObject, stopping it as well if necessary\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Returns whether or not the ipcObject represents a remote or local port": {
        "prefix": "hs.ipc:isRemote() -> boolean",
        "body": "hs.ipc:isRemote()",
        "description": "Returns whether or not the ipcObject represents a remote or local port\n\nParameters:\n * None\n\nReturns:\n * true if the object is a remote port, otherwise false\n\nNotes:\n * a remote port can send messages at any time to a local port; a local port can only respond to messages from a remote port"
    },
    "Returns whether or not the ipcObject port is still valid or not": {
        "prefix": "hs.ipc:isValid() -> boolean",
        "body": "hs.ipc:isValid()",
        "description": "Returns whether or not the ipcObject port is still valid or not\n\nParameters:\n * None\n\nReturns:\n * true if the object is a valid port, otherwise false"
    },
    "Create a new local ipcObject for receiving and responding to messages from a remote port": {
        "prefix": "hs.ipc.localPort(name, fn) -> ipcObject",
        "body": "hs.ipc.localPort(${1:name}, ${2:fn})",
        "description": "Create a new local ipcObject for receiving and responding to messages from a remote port\n\nParameters:\n * name - a string acting as the message port name.\n * fn   - the callback function which will receive messages.\n\nReturns:\n * the ipc object\n\nNotes:\n * a remote port can send messages at any time to a local port; a local port can only respond to messages from a remote port"
    },
    "Returns the name the ipcObject uses for its port when active": {
        "prefix": "hs.ipc:name() -> string",
        "body": "hs.ipc:name()",
        "description": "Returns the name the ipcObject uses for its port when active\n\nParameters:\n * None\n\nReturns:\n * the port name as a string"
    },
    "Create a new remote ipcObject for sending messages asynchronously to a local port": {
        "prefix": "hs.ipc.remotePort(name) -> ipcObject",
        "body": "hs.ipc.remotePort(${1:name})",
        "description": "Create a new remote ipcObject for sending messages asynchronously to a local port\n\nParameters:\n * name - a string acting as the message port name.\n\nReturns:\n * the ipc object\n\nNotes:\n * a remote port can send messages at any time to a local port; a local port can only respond to messages from a remote port"
    },
    "Sends a message from a remote port to a local port": {
        "prefix": "hs.ipc:sendMessage(data, msgID, [waitTimeout], [oneWay]) -> status, response",
        "body": "hs.ipc:sendMessage(${1:data}, ${2:msgID}, ${3:[waitTimeout]}, ${4:[oneWay]})",
        "description": "Sends a message from a remote port to a local port\n\nParameters:\n * data        - any data type which is to be sent to the local port.  The data will be converted into its string representation\n * msgID       - an integer message ID\n * waitTimeout - an optional number, default 2.0, representing the number of seconds the method will wait to send the message and then wait for a response.  The method *may* block up to twice this number of seconds, though usually it will be shorter.\n * oneWay      -  an optional boolean, default false, indicating whether or not to wait for a response.  It this is true, the second returned argument will be nil.\n\nReturns:\n * status   - a boolean indicathing whether or not the local port responded before the timeout (true) or if an error or timeout occurred waiting for the response (false)\n * response - the response from the local port, usually a string, but may be nil if there was no response returned.  If status is false, will contain an error message describing the error."
    },
    "Skips the current playback forwards by 5 seconds": {
        "prefix": "hs.itunes.ff()",
        "body": "hs.itunes.ff()",
        "description": "Skips the current playback forwards by 5 seconds\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Gets the name of the current Album": {
        "prefix": "hs.itunes.getCurrentAlbum() -> string or nil",
        "body": "hs.itunes.getCurrentAlbum()",
        "description": "Gets the name of the current Album\n\nParameters:\n * None\n\nReturns:\n * A string containing the Album of the current track, or nil if an error occurred"
    },
    "Gets the name of the current Artist": {
        "prefix": "hs.itunes.getCurrentArtist() -> string or nil",
        "body": "hs.itunes.getCurrentArtist()",
        "description": "Gets the name of the current Artist\n\nParameters:\n * None\n\nReturns:\n * A string containing the Artist of the current track, or nil if an error occurred"
    },
    "Gets the duration (in seconds) of the current song": {
        "prefix": "hs.spotify.getDuration()",
        "body": "hs.spotify.getDuration()",
        "description": "Gets the duration (in seconds) of the current song\n\nParameters:\n * None\n\nReturns:\n * The number of seconds long the current song is, 0 if no song is playing"
    },
    "Gets the current playback state of iTunes": {
        "prefix": "hs.itunes.getPlaybackState()",
        "body": "hs.itunes.getPlaybackState()",
        "description": "Gets the current playback state of iTunes\n\nParameters:\n * None\n\nReturns:\n * A string containing one of the following constants:\n   - `hs.itunes.state_stopped`\n   - `hs.itunes.state_paused`\n   - `hs.itunes.state_playing`"
    },
    "Gets the playback position (in seconds) of the current song": {
        "prefix": "hs.itunes.getPosition()",
        "body": "hs.itunes.getPosition()",
        "description": "Gets the playback position (in seconds) of the current song\n\nParameters:\n * None\n\nReturns:\n * A number indicating the current position in the song"
    },
    "Gets the current iTunes volume setting": {
        "prefix": "hs.itunes.getVolume()",
        "body": "hs.itunes.getVolume()",
        "description": "Gets the current iTunes volume setting\n\nParameters:\n * None\n\nReturns:\n * A number, between 1 and 100, containing the current iTunes playback volume"
    },
    "Returns whether iTunes is currently playing": {
        "prefix": "hs.itunes.isPlaying()",
        "body": "hs.itunes.isPlaying()",
        "description": "Returns whether iTunes is currently playing\n\nParameters:\n * None\n\nReturns:\n * A boolean value indicating whether iTunes is currently playing a track, or nil if an error occurred (unknown player state). Also returns false if the application is not running"
    },
    "Returns whether iTunes is currently open. Most other functions in hs.itunes will automatically start the application, so this function can be used to guard against that.": {
        "prefix": "hs.itunes.isRunning()",
        "body": "hs.itunes.isRunning()",
        "description": "Returns whether iTunes is currently open. Most other functions in hs.itunes will automatically start the application, so this function can be used to guard against that.\n\nParameters:\n * None\n\nReturns:\n * A boolean value indicating whether the iTunes application is running."
    },
    "Skips to the next itunes track": {
        "prefix": "hs.itunes.next()",
        "body": "hs.itunes.next()",
        "description": "Skips to the next itunes track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Pauses the current iTunes track": {
        "prefix": "hs.itunes.pause()",
        "body": "hs.itunes.pause()",
        "description": "Pauses the current iTunes track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Plays the current iTunes track": {
        "prefix": "hs.itunes.play()",
        "body": "hs.itunes.play()",
        "description": "Plays the current iTunes track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Toggles play/pause of current iTunes track": {
        "prefix": "hs.itunes.playpause()",
        "body": "hs.itunes.playpause()",
        "description": "Toggles play/pause of current iTunes track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Skips to previous itunes track": {
        "prefix": "hs.itunes.previous()",
        "body": "hs.itunes.previous()",
        "description": "Skips to previous itunes track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Skips the current playback backwards by 5 seconds": {
        "prefix": "hs.itunes.rw()",
        "body": "hs.itunes.rw()",
        "description": "Skips the current playback backwards by 5 seconds\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Sets the playback position of the current song": {
        "prefix": "hs.itunes.setPosition(pos)",
        "body": "hs.itunes.setPosition(${1:pos})",
        "description": "Sets the playback position of the current song\n\nParameters:\n * pos - A number indicating the playback position (in seconds) to skip to\n\nReturns:\n * None"
    },
    "Sets the iTunes playback volume": {
        "prefix": "hs.itunes.setVolume(vol)",
        "body": "hs.itunes.setVolume(${1:vol})",
        "description": "Sets the iTunes playback volume\n\nParameters:\n * vol - A number, between 1 and 100\n\nReturns:\n * None"
    },
    "Returned by `hs.itunes.getPlaybackState()` to indicates iTunes is paused": {
        "prefix": "hs.itunes.state_paused",
        "body": "hs.itunes.state_paused",
        "description": "Returned by `hs.itunes.getPlaybackState()` to indicates iTunes is paused"
    },
    "Returned by `hs.itunes.getPlaybackState()` to indicates iTunes is playing": {
        "prefix": "hs.itunes.state_playing",
        "body": "hs.itunes.state_playing",
        "description": "Returned by `hs.itunes.getPlaybackState()` to indicates iTunes is playing"
    },
    "Returned by `hs.itunes.getPlaybackState()` to indicates iTunes is stopped": {
        "prefix": "hs.itunes.state_stopped",
        "body": "hs.itunes.state_stopped",
        "description": "Returned by `hs.itunes.getPlaybackState()` to indicates iTunes is stopped"
    },
    "Decreases the iTunes playback volume by 5": {
        "prefix": "hs.itunes.volumeDown()",
        "body": "hs.itunes.volumeDown()",
        "description": "Decreases the iTunes playback volume by 5\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Increases the iTunes playback volume by 5": {
        "prefix": "hs.itunes.volumeUp()",
        "body": "hs.itunes.volumeUp()",
        "description": "Increases the iTunes playback volume by 5\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Decodes JSON into a table": {
        "prefix": "hs.json.decode(jsonString) -> table",
        "body": "hs.json.decode(${1:jsonString})",
        "description": "Decodes JSON into a table\n\nParameters:\n * jsonString - A string containing some JSON data\n\nReturns:\n * A table representing the supplied JSON data\n\nNotes:\n * This is useful for retrieving some of the more complex lua table structures as a persistent setting (see `hs.settings`)"
    },
    "Encodes a table as JSON": {
        "prefix": "hs.json.encode(val[, prettyprint]) -> string",
        "body": "hs.json.encode(${1:val[}, ${2:prettyprint]})",
        "description": "Encodes a table as JSON\n\nParameters:\n * val - A table containing data to be encoded as JSON\n * prettyprint - An optional boolean, true to format the JSON for human readability, false to format the JSON for size efficiency. Defaults to false\n\nReturns:\n * A string containing a JSON representation of the supplied table\n\nNotes:\n * This is useful for storing some of the more complex lua table structures as a persistent setting (see `hs.settings`)"
    },
    "Decodes JSON file into a table.": {
        "prefix": "hs.json.read(path) -> table | nil",
        "body": "hs.json.read(${1:path})",
        "description": "Decodes JSON file into a table.\n\nParameters:\n * path - The path and filename of the JSON file to read.\n\nReturns:\n * A table representing the supplied JSON data, or `nil` if an error occurs."
    },
    "Encodes a table as JSON to a file": {
        "prefix": "hs.json.write(data, path, [prettyprint], [replace]) -> boolean",
        "body": "hs.json.write(${1:data}, ${2:path}, ${3:[prettyprint]}, ${4:[replace]})",
        "description": "Encodes a table as JSON to a file\n\nParameters:\n * data - A table containing data to be encoded as JSON\n * path - The path and filename of the JSON file to write to\n * prettyprint - An optional boolean, `true` to format the JSON for human readability, `false` to format the JSON for size efficiency. Defaults to `false`\n * replace - An optional boolean, `true` to replace an existing file at the same path if one exists. Defaults to `false`\n\nReturns:\n * `true` if successful otherwise `false` if an error has occurred"
    },
    "Gets the name of the current keyboard layout": {
        "prefix": "hs.keycodes.currentLayout() -> string",
        "body": "hs.keycodes.currentLayout()",
        "description": "Gets the name of the current keyboard layout\n\nParameters:\n * None\n\nReturns:\n * A string containing the name of the current keyboard layout"
    },
    "Gets the icon of the current keyboard layout": {
        "prefix": "hs.keycodes.currentLayoutIcon() -> hs.image object",
        "body": "hs.keycodes.currentLayoutIcon()",
        "description": "Gets the icon of the current keyboard layout\n\nParameters:\n * None\n\nReturns:\n * An hs.image object containing the icon, if available"
    },
    "Get current input method": {
        "prefix": "hs.keycodes.currentMethod() -> string",
        "body": "hs.keycodes.currentMethod()",
        "description": "Get current input method\n\nParameters:\n * None\n\nReturns:\n * Name of current input method, or nil"
    },
    "Get or set the source id for the keyboard input source": {
        "prefix": "hs.keycodes.currentSourceID([sourceID]) -> string | boolean",
        "body": "hs.keycodes.currentSourceID(${1:[sourceID]})",
        "description": "Get or set the source id for the keyboard input source\n\nParameters:\n * sourceID - an optional string specifying the input source to set for keyboard input\n\nReturns:\n * If no parameter is provided, returns a string containing the source id for the current keyboard layout or input method; if a parameter is provided, returns true or false specifying whether or not the input source was able to be changed."
    },
    "Gets an hs.image object for a given keyboard layout or input method": {
        "prefix": "hs.keycodes.iconForLayoutOrMethod(sourceName) -> hs.image object",
        "body": "hs.keycodes.iconForLayoutOrMethod(${1:sourceName})",
        "description": "Gets an hs.image object for a given keyboard layout or input method\n\nParameters:\n * sourceName - A string containing the name of an input method or keyboard layout\n\nReturns:\n * An hs.image object, or nil if no image could be found\n\nNotes:\n * Not all layouts/methods have icons, so you should assume this will return nil at some point"
    },
    "Sets the function to be called when your input source (i.e. qwerty, dvorak, colemac) changes.": {
        "prefix": "hs.keycodes.inputSourceChanged(fn)",
        "body": "hs.keycodes.inputSourceChanged(${1:fn})",
        "description": "Sets the function to be called when your input source (i.e. qwerty, dvorak, colemac) changes.\n\nParameters:\n * fn - A function that will be called when the input source changes. No arguments are supplied to the function.\n\nReturns:\n * None\n\nNotes:\n * This may be helpful for rebinding your hotkeys to appropriate keys in the new layout\n * Setting this will un-set functions previously registered by this function."
    },
    "Gets all of the enabled keyboard layouts that the keyboard input source can be switched to": {
        "prefix": "hs.keycodes.layouts([sourceID]) -> table",
        "body": "hs.keycodes.layouts(${1:[sourceID]})",
        "description": "Gets all of the enabled keyboard layouts that the keyboard input source can be switched to\n\nParameters:\n * sourceID - an optional boolean, default false, indicating whether the keyboard layout names should be returned (false) or their source IDs (true).\n\nReturns:\n * A table containing a list of keyboard layouts enabled in System Preferences\n\nNotes:\n * Only those layouts which can be explicitly switched to will be included in the table.  Keyboard layouts which are part of input methods are not included.  See `hs.keycodes.methods`."
    },
    "A mapping from string representation of a key to its keycode, and vice versa.": {
        "prefix": "hs.keycodes.map",
        "body": "hs.keycodes.map",
        "description": "A mapping from string representation of a key to its keycode, and vice versa.\nFor example: keycodes[1] == \"s\", and keycodes[\"s\"] == 1, and so on.\nThis is primarily used by the hs.eventtap and hs.hotkey extensions.\n\nValid strings are any single-character string, or any of the following strings:\n\n    f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15,\n    f16, f17, f18, f19, f20, pad, pad*, pad+, pad/, pad-, pad=,\n    pad0, pad1, pad2, pad3, pad4, pad5, pad6, pad7, pad8, pad9,\n    padclear, padenter, return, tab, space, delete, escape, help,\n    home, pageup, forwarddelete, end, pagedown, left, right, down, up,\n    shift, rightshift, cmd, rightcmd, alt, rightalt, ctrl, rightctrl,\n    capslock, fn"
    },
    "Gets all of the enabled input methods that the keyboard input source can be switched to": {
        "prefix": "hs.keycodes.methods([sourceID]) -> table",
        "body": "hs.keycodes.methods(${1:[sourceID]})",
        "description": "Gets all of the enabled input methods that the keyboard input source can be switched to\n\nParameters:\n * sourceID - an optional boolean, default false, indicating whether the keyboard input method names should be returned (false) or their source IDs (true).\n\nReturns:\n * A table containing a list of input methods enabled in System Preferences\n\nNotes:\n * Keyboard layouts which are not part of an input method are not included in this table.  See `hs.keycodes.layouts`."
    },
    "Changes the system keyboard layout": {
        "prefix": "hs.keycodes.setLayout(layoutName) -> boolean",
        "body": "hs.keycodes.setLayout(${1:layoutName})",
        "description": "Changes the system keyboard layout\n\nParameters:\n * layoutName - A string containing the name of an enabled keyboard layout\n\nReturns:\n * A boolean, true if the layout was successfully changed, otherwise false"
    },
    "Changes the system input method": {
        "prefix": "hs.keycodes.setMethod(methodName) -> boolean",
        "body": "hs.keycodes.setMethod(${1:methodName})",
        "description": "Changes the system input method\n\nParameters:\n * methodName - A string containing the name of an enabled input method\n\nReturns:\n * A boolean, true if the method was successfully changed, otherwise false"
    },
    "Applies a layout to applications/windows": {
        "prefix": "hs.layout.apply(table[, windowTitleComparator])",
        "body": "hs.layout.apply(${1:table[}, ${2:windowTitleComparator]})",
        "description": "Applies a layout to applications/windows\n\nParameters:\n * table - A table describing your desired layout. Each element in the table should be another table describing a set of windows to match, and their desired size/position. The fields in each of these tables are:\n  * A string containing an application name, or an `hs.application` object, or nil\n  * A string containing a window title, or an `hs.window` object, or a function, or nil\n  * A string containing a screen name, or an `hs.screen` object, or a function that accepts no parameters and returns an `hs.screen` object, or nil to select the first available screen\n  * A Unit rect, or a function which is called for each window and returns a unit rect (see `hs.window.moveToUnit()`). The function should accept one parameter, which is the window object.\n  * A Frame rect, or a function which is called for each window and returns a frame rect (see `hs.screen:frame()`). The function should accept one parameter, which is the window object.\n  * A Full-frame rect, of a function which is called for each window and returns a full-frame rect (see `hs.screen:fullFrame()`). The function should accept one parameter, which is the window object.\n * windowTitleComparator - (optional) Function to use for window title comparison. It is called with two string arguments (below) and its return value is evaluated as a boolean. If no comparator is provided, the '==' operator is used\n  * windowTitle: The `:title()` of the window object being examined\n  * layoutWindowTitle: The window title string (second field) specified in each element of the layout table\n  * Optionally a final element, the key \"options\" and a table value that can contain the following keys:\n    * `absolute_x`: A boolean indicating that the x value in a frame rect above, is an absolute co-ordinate (ie useful for negative absolute co-ordinates)\n    * `absolute_y`: A boolean indicating that the y value in a frame rect above, is an absolute co-ordinate (ie useful for negative absolute co-ordinates)\n\nReturns:\n * None\n\nNotes:\n * If the application name argument is nil, window titles will be matched regardless of which app they belong to\n * If the window title argument is nil, all windows of the specified application will be matched\n * If the window title argument is a function, the function will be called with the application name argument (which may be nil), and should return a table of `hs.window` objects (even if there is only one window it must be in a table)\n * You can specify both application name and window title if you want to match only one window of a particular application\n * If you specify neither application name or window title, no windows will be matched :)\n * Monitor name is a string, as found in `hs.screen:name()` or `hs.screen:getUUID()`. You can also pass an `hs.screen` object, or a function that returns an `hs.screen` object. If you pass nil, the first screen will be selected\n * The final three arguments use `hs.geometry.rect()` objects to describe the desired position and size of matched windows:\n   * Unit rect will be passed to `hs.window.moveToUnit()`\n   * Frame rect will be passed to `hs.window.setFrame()` (including menubar and dock)\n   * Full-frame rect will be passed to `hs.window.setFrame()` (ignoring menubar and dock)\n * If either the x or y components of frame/full-frame rect are negative, they will be applied as offsets against the opposite edge of the screen (e.g. If x is -100 then the left edge of the window will be 100 pixels from the right edge of the screen)\n * Only one of the rect arguments will apply to any matched windows. If you specify more than one, the first will win\n * An example usage:\n\n    ```layout1 = {\n        {\"Mail\", nil, \"Color LCD\", hs.layout.maximized, nil, nil},\n        {\"Safari\", nil, \"Thunderbolt Display\", hs.layout.maximized, nil, nil},\n        {\"iTunes\", \"iTunes\", \"Color LCD\", hs.layout.maximized, nil, nil},\n        {\"iTunes\", \"MiniPlayer\", \"Color LCD\", nil, nil, hs.geometry.rect(0, -48, 400, 48)},\n      }```\n * An example of a function that works well as a `windowTitleComparator` is the Lua built-in `string.match`, which uses Lua Patterns to match strings"
    },
    "A unit rect which will make a window occupy the left 25% of a screen": {
        "prefix": "hs.layout.left25",
        "body": "hs.layout.left25",
        "description": "A unit rect which will make a window occupy the left 25% of a screen"
    },
    "A unit rect which will make a window occupy the left 30% of a screen": {
        "prefix": "hs.layout.left30",
        "body": "hs.layout.left30",
        "description": "A unit rect which will make a window occupy the left 30% of a screen"
    },
    "A unit rect which will make a window occupy the left 50% of a screen": {
        "prefix": "hs.layout.left50",
        "body": "hs.layout.left50",
        "description": "A unit rect which will make a window occupy the left 50% of a screen"
    },
    "A unit rect which will make a window occupy the left 70% of a screen": {
        "prefix": "hs.layout.left70",
        "body": "hs.layout.left70",
        "description": "A unit rect which will make a window occupy the left 70% of a screen"
    },
    "A unit rect which will make a window occupy the left 75% of a screen": {
        "prefix": "hs.layout.left75",
        "body": "hs.layout.left75",
        "description": "A unit rect which will make a window occupy the left 75% of a screen"
    },
    "A unit rect which will make a window occupy all of a screen": {
        "prefix": "hs.layout.maximized",
        "body": "hs.layout.maximized",
        "description": "A unit rect which will make a window occupy all of a screen"
    },
    "A unit rect which will make a window occupy the right 25% of a screen": {
        "prefix": "hs.layout.right25",
        "body": "hs.layout.right25",
        "description": "A unit rect which will make a window occupy the right 25% of a screen"
    },
    "A unit rect which will make a window occupy the right 30% of a screen": {
        "prefix": "hs.layout.right30",
        "body": "hs.layout.right30",
        "description": "A unit rect which will make a window occupy the right 30% of a screen"
    },
    "A unit rect which will make a window occupy the right 50% of a screen": {
        "prefix": "hs.layout.right50",
        "body": "hs.layout.right50",
        "description": "A unit rect which will make a window occupy the right 50% of a screen"
    },
    "A unit rect which will make a window occupy the right 70% of a screen": {
        "prefix": "hs.layout.right70",
        "body": "hs.layout.right70",
        "description": "A unit rect which will make a window occupy the right 70% of a screen"
    },
    "A unit rect which will make a window occupy the right 75% of a screen": {
        "prefix": "hs.layout.right75",
        "body": "hs.layout.right75",
        "description": "A unit rect which will make a window occupy the right 75% of a screen"
    },
    "Adds a region to be monitored by Location Services": {
        "prefix": "hs.location:addMonitoredRegion(regionTable) -> locationObject | nil",
        "body": "hs.location:addMonitoredRegion(${1:regionTable})",
        "description": "Adds a region to be monitored by Location Services\n\nParameters:\n * `regionTable` - a region table as described in the module header\n\nReturns:\n * if the region table was able to be added to Location Services for monitoring, returns the locationObject; otherwise returns nil\n\nNotes:\n * This method activates Location Services for Hammerspoon, so the first time you call this, you may be prompted to authorise Hammerspoon to use Location Services.\n * If the `identifier` key is not provided, a new UUID string is generated and used as the identifier.\n * If the `identifier` key matches an already monitored region, this region will replace the existing one."
    },
    "Returns a string describing the authorization status of Hammerspoon's use of Location Services.": {
        "prefix": "hs.location.authorizationStatus() -> string",
        "body": "hs.location.authorizationStatus()",
        "description": "Returns a string describing the authorization status of Hammerspoon's use of Location Services.\n\nParameters:\n * None\n\nReturns:\n * a string matching one of the following:\n   * \"undefined\"  - The user has not yet made a choice regarding whether Hammerspoon can use location services.\n   * \"restricted\" - Hammerspoon is not authorized to use location services. The user cannot change this status, possibly due to active restrictions such as parental controls being in place.\n   * \"denied\"     - The user explicitly denied the use of location services for Hammerspoon or location services are currently disabled in System Preferences.\n   * \"authorized\" - Hammerspoon is authorized to use location services.\n\nNotes:\n * The first time you use a function which requires Location Services, you will be prompted to grant Hammerspoon access. If you wish to change this permission after the initial prompt, you may do so from the Location Services section of the Security & Privacy section in the System Preferences application."
    },
    "Sets or removes the callback function for this locationObject": {
        "prefix": "hs.location:callback(fn | nil) -> locationObject",
        "body": "hs.location:callback(${1:fn | nil})",
        "description": "Sets or removes the callback function for this locationObject\n\nParameters:\n * a function, or nil to remove the current function, which will be invoked as a callback for messages generated by this locationObject.  The callback function should expect 3 or 4 arguments as follows:\n   * the locationObject itself\n   * a string specifying the message generated by the locationObject:\n     * \"didChangeAuthorizationStatus\" - the user has changed the authorization status for Hammerspoon's use of Location Services.  The third argument will be a string as described in the [hs.location.authorizationStatus](#authorizationStatus) function.\n     * \"didUpdateLocations\"           - the current location has changed or been refined.  This message will only occur if location tracking has been enabled with [hs.location:startTracking](#startTracking). The third argument will be a table containing one or more locationTables as array elements.  The most recent location update is contained in the last element of the array.\n     * \"didFailWithError\"             - there was an error retrieving location information. The third argument will be a string describing the error that occurred.\n     * \"didStartMonitoringForRegion\"  - a new region has successfully been added to the regions being monitored.  The third argument will be the regionTable for the region which was just added.\n     * \"monitoringDidFailForRegion\"   - an error occurred while trying to add a new region to the list of monitored regions. The third argument will be the regionTable for the region that could not be added, and the fourth argument will be a string containing an error message describing why monitoring for the region failed.\n     * \"didEnterRegion\"               - the current location has entered a region with the `notifyOnEntry` field set to true specified with the [hs.location:addMonitoredRegion](#addMonitoredRegion) method. The third argument will be the regionTable for the region entered.\n     * \"didExitRegion\"                - the current location has exited a region with the `notifyOnExit` field set to true specified with the [hs.location:addMonitoredRegion](#addMonitoredRegion) method. The third argument will be the regionTable for the region exited.\n\nReturns:\n * the locationObject"
    },
    "Returns the string identifier for the current region": {
        "prefix": "hs.location:currentRegion() -> identifier | nil",
        "body": "hs.location:currentRegion()",
        "description": "Returns the string identifier for the current region\n\nParameters:\n * None\n\nReturns:\n * the string identifier for the region that the current location is within, or nil if the current location is not within a currently monitored region or location services cannot be enabled for Hammerspoon.\n\nNotes:\n * This method activates Location Services for Hammerspoon, so the first time you call this, you may be prompted to authorise Hammerspoon to use Location Services."
    },
    "Measures the distance between two points of latitude and longitude": {
        "prefix": "hs.location.distance(from, to) -> meters",
        "body": "hs.location.distance(${1:from}, ${2:to})",
        "description": "Measures the distance between two points of latitude and longitude\n\nParameters:\n * `from` - A locationTable as described in the module header\n * `to`   - A locationTable as described in the module header\n\nReturns:\n * A number containing the distance between `from` and `to` in meters. The measurement is made by tracing a line that follows an idealised curvature of the earth\n\nNotes:\n * This function does not require Location Services to be enabled for Hammerspoon."
    },
    "Enable callbacks for location changes/refinements for this locationObject": {
        "prefix": "hs.location:startTracking() -> locationObject",
        "body": "hs.location:startTracking()",
        "description": "Enable callbacks for location changes/refinements for this locationObject\n\nParameters:\n * None\n\nReturns:\n * the locationObject\n\nNotes:\n * This function activates Location Services for Hammerspoon, so the first time you call this, you may be prompted to authorise Hammerspoon to use Location Services."
    },
    "Returns a number giving the current daylight savings time offset": {
        "prefix": "hs.location.dstOffset() -> number",
        "body": "hs.location.dstOffset()",
        "description": "Returns a number giving the current daylight savings time offset\n\nParameters:\n * None\n\nReturns:\n * The number of minutes of daylight savings offset, zero if there is no offset\n\nNotes:\n * This value is derived from the currently configured system timezone, it does not use Location Services"
    },
    "Returns a table representing the current location": {
        "prefix": "hs.location.get() -> locationTable or nil",
        "body": "hs.location.get()",
        "description": "Returns a table representing the current location\n\nParameters:\n * None\n\nReturns:\n * If successful, a locationTable as described in the module header, otherwise nil.\n\nNotes:\n * This function activates Location Services for Hammerspoon, so the first time you call this, you may be prompted to authorise Hammerspoon to use Location Services.\n * If access to Location Services is enabled for Hammerspoon, this function will return the most recent cached data for the computer's location.\n   * Internally, the Location Services cache is updated whenever additional WiFi networks are detected or lost (not necessarily joined). When update tracking is enabled with the [hs.location.start](#start) function, calculations based upon the RSSI of all currently seen networks are preformed more often to provide a more precise fix, but it's still based on the WiFi networks near you."
    },
    "Returns the current location": {
        "prefix": "hs.location:location() -> locationTable | nil",
        "body": "hs.location:location()",
        "description": "Returns the current location\n\nParameters:\n * None\n\nReturns:\n * If successful, a locationTable as described in the module header, otherwise nil.\n\nNotes:\n * This function activates Location Services for Hammerspoon, so the first time you call this, you may be prompted to authorise Hammerspoon to use Location Services.\n * If access to Location Services is enabled for Hammerspoon, this function will return the most recent cached data for the computer's location.\n   * Internally, the Location Services cache is updated whenever additional WiFi networks are detected or lost (not necessarily joined). When update tracking is enabled with the [hs.location.start](#start) function, calculations based upon the RSSI of all currently seen networks are preformed more often to provide a more precise fix, but it's still based on the WiFi networks near you."
    },
    "Returns a table containing the regionTables for the regions currently being monitored for this locationObject": {
        "prefix": "hs.location:monitoredRegions() -> table | nil",
        "body": "hs.location:monitoredRegions()",
        "description": "Returns a table containing the regionTables for the regions currently being monitored for this locationObject\n\nParameters:\n * None\n\nReturns:\n * if Location Services can be enabled for Hammerspoon, returns a table containing regionTables for each region which is being monitored for this locationObject; otherwise nil\n\nNotes:\n * This method activates Location Services for Hammerspoon, so the first time you call this, you may be prompted to authorise Hammerspoon to use Location Services."
    },
    "Create a new location object which can receive callbacks independant of other Hammerspoon use of Location Services.": {
        "prefix": "hs.location.new() -> locationObject",
        "body": "hs.location.new()",
        "description": "Create a new location object which can receive callbacks independant of other Hammerspoon use of Location Services.\n\nParameters:\n * None\n\nReturns:\n * a locationObject\n\nNotes:\n * The locationObject created will receive callbacks independant of all other locationObjects and the legacy callback functions created with [hs.location.register](#register).  It can also receive callbacks for region changes which are not available through the legacy callback mechanism."
    },
    "Registers a callback function to be called when the system location is updated": {
        "prefix": "hs.location.register(tag, fn[, distance])",
        "body": "hs.location.register(${1:tag}, ${2:fn[}, ${3:distance]})",
        "description": "Registers a callback function to be called when the system location is updated\n\nParameters:\n * `tag`      - A string containing a unique tag, used to identify the callback later\n * `fn`       - A function to be called when the system location is updated. The function should expect a single argument which will be a locationTable as described in the module header.\n * `distance` - An optional number containing the minimum distance in meters that the system should have moved, before calling the callback. Defaults to 0\n\nReturns:\n * None"
    },
    "Removes a monitored region from Location Services": {
        "prefix": "hs.location:removeMonitoredRegion(identifier) -> locationObject | false | nil",
        "body": "hs.location:removeMonitoredRegion(${1:identifier})",
        "description": "Removes a monitored region from Location Services\n\nParameters:\n * `identifier` - a string which should contain the identifier of the region to remove from monitoring\n\nReturns:\n * if the region identifier matches a currently monitored region, returns the locationObject; if it does not match a currently monitored region, returns false; returns nil if an error occurs or if Location Services is not currently active (no function or method which activates Location Services has been invoked yet) or enabled for Hammerspoon.\n\nNotes:\n * This method activates Location Services for Hammerspoon, so the first time you call this, you may be prompted to authorise Hammerspoon to use Location Services.\n * If the `identifier` key is not provided, a new UUID string is generated and used as the identifier.\n * If the `identifier` key matches an already monitored region, this region will replace the existing one."
    },
    "Gets the state of OS X Location Services": {
        "prefix": "hs.location.servicesEnabled() -> bool",
        "body": "hs.location.servicesEnabled()",
        "description": "Gets the state of OS X Location Services\n\nParameters:\n * None\n\nReturns:\n * True if Location Services are enabled, otherwise false"
    },
    "Begins location tracking using OS X's Location Services so that registered callback functions can be invoked as the computer location changes.": {
        "prefix": "hs.location.start() -> boolean",
        "body": "hs.location.start()",
        "description": "Begins location tracking using OS X's Location Services so that registered callback functions can be invoked as the computer location changes.\n\nParameters:\n * None\n\nReturns:\n * True if the operation succeeded, otherwise false\n\nNotes:\n * This function activates Location Services for Hammerspoon, so the first time you call this, you may be prompted to authorise Hammerspoon to use Location Services."
    },
    "Stops location tracking.  Registered callback functions will cease to receive notification of location changes.": {
        "prefix": "hs.location.stop()",
        "body": "hs.location.stop()",
        "description": "Stops location tracking.  Registered callback functions will cease to receive notification of location changes.\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Disable callbacks for location changes/refinements for this locationObject": {
        "prefix": "hs.location:stopTracking() -> locationObject",
        "body": "hs.location:stopTracking()",
        "description": "Disable callbacks for location changes/refinements for this locationObject\n\nParameters:\n * None\n\nReturns:\n * the locationObject"
    },
    "Returns the time of official sunrise for the supplied location": {
        "prefix": "hs.location.sunrise(latitude, longitude, offset[, date]) -> number or string",
        "body": "hs.location.sunrise(${1:latitude}, ${2:longitude}, ${3:offset[}, ${4:date]})",
        "description": "Returns the time of official sunrise for the supplied location\n\nParameters:\n * `latitude`  - A number containing a latitude\n * `longitude` - A number containing a longitude\n * `offset`    - A number containing the offset from UTC (in hours) for the given latitude/longitude.\n * `date`      - An optional table containing date information (equivalent to the output of ```os.date(\"*t\")```). Defaults to the current date\n\nReturns:\n * A number containing the time of sunrise (represented as seconds since the epoch) for the given date. If no date is given, the current date is used. If the sun doesn't rise on the given day, the string \"N/R\" is returned.\n\nNotes:\n * You can turn the return value into a more useful structure, with ```os.date(\"*t\", returnvalue)```\n * For compatibility with the locationTable object returned by [hs.location.get](#get), this function can also be invoked as `hs.location.sunrise(locationTable, offset[, date])`."
    },
    "Returns the time of official sunset for the supplied location": {
        "prefix": "hs.location.sunset(latitude, longitude, offset[, date]) -> number or string",
        "body": "hs.location.sunset(${1:latitude}, ${2:longitude}, ${3:offset[}, ${4:date]})",
        "description": "Returns the time of official sunset for the supplied location\n\nParameters:\n * `latitude`  - A number containing a latitude\n * `longitude` - A number containing a longitude\n * `offset`    - A number containing the offset from UTC (in hours) for the given latitude/longitude.\n * `date`      - An optional table containing date information (equivalent to the output of ```os.date(\"*t\")```). Defaults to the current date\n\nReturns:\n * A number containing the time of sunset (represented as seconds since the epoch) for the given date. If no date is given, the current date is used. If the sun doesn't set on the given day, the string \"N/S\" is returned.\n\nNotes:\n * You can turn the return value into a more useful structure, with ```os.date(\"*t\", returnvalue)```\n * For compatibility with the locationTable object returned by [hs.location.get](#get), this function can also be invoked as `hs.location.sunset(locationTable, offset[, date])`."
    },
    "Unregisters a callback": {
        "prefix": "hs.location.unregister(tag)",
        "body": "hs.location.unregister(${1:tag})",
        "description": "Unregisters a callback\n\nParameters:\n * `tag` - A string containing the unique tag a callback was registered with\n\nReturns:\n * None"
    },
    "Cancels the pending or in progress geocoding request.": {
        "prefix": "hs.location.geocoder:cancel() -> nil",
        "body": "hs.location.geocoder:cancel()",
        "description": "Cancels the pending or in progress geocoding request.\n\nParameters:\n * None\n\nReturns:\n * nil to facilitate garbage collection by assigning this result to the geocodeObject\n\nNotes:\n * This method has no effect if the geocoding process has already completed."
    },
    "Returns a boolean indicating whether or not the geocoding process is still active.": {
        "prefix": "hs.location.geocoder:geocoding() -> boolean",
        "body": "hs.location.geocoder:geocoding()",
        "description": "Returns a boolean indicating whether or not the geocoding process is still active.\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating if the geocoding process is still active.  If false, then the callback function either has already been called or will be as soon as the main thread of Hammerspoon becomes idle again."
    },
    "Look up geocoding information for the specified address.": {
        "prefix": "hs.location.geocoder.lookupAddress(address, fn) -> geocoderObject",
        "body": "hs.location.geocoder.lookupAddress(${1:address}, ${2:fn})",
        "description": "Look up geocoding information for the specified address.\n\nParameters:\n * `address` - a string containing address information as commonly expressed in your locale.\n * `fn`      - A callback function which should expect 2 arguments and return none:\n   * `state`  - a boolean indicating whether or not geocoding data was provided\n   * `result` - if `state` is true indicating that geocoding was successful, this argument will be a table containing one or more placemarkTables (as described in the module header) containing the geocoding data available for the location.  If `state` is false, this argument will be a string containing an error message describing the problem encountered.\n\nReturns:\n * a geocodingObject\n\nNotes:\n * This constructor requires internet access and the callback will be invoked with an error message if the internet is not currently accessible.\n * This constructor does not require Location Services to be enabled for Hammerspoon."
    },
    "Look up geocoding information for the specified address._1": {
        "prefix": "hs.location.geocoder.lookupAddressNear(address, [regionTable], fn) -> geocoderObject",
        "body": "hs.location.geocoder.lookupAddressNear(${1:address}, ${2:[regionTable]}, ${3:fn})",
        "description": "Look up geocoding information for the specified address.\n\nParameters:\n * `address`     - a string containing address information as commonly expressed in your locale.\n * `regionTable` - an optional regionTable as described in the `hs.location` header used to prioritize the order of the results found.  If this parameter is not provided and Location Services is enabled for Hammerspoon, a region containing current location is used.\n * `fn`          - A callback function which should expect 2 arguments and return none:\n   * `state`  - a boolean indicating whether or not geocoding data was provided\n   * `result` - if `state` is true indicating that geocoding was successful, this argument will be a table containing one or more placemarkTables (as described in the module header) containing the geocoding data available for the location.  If `state` is false, this argument will be a string containing an error message describing the problem encountered.\n\nReturns:\n * a geocodingObject\n\nNotes:\n * This constructor requires internet access and the callback will be invoked with an error message if the internet is not currently accessible.\n * This constructor does not require Location Services to be enabled for Hammerspoon.\n * While a partial address can be given, the more information you provide, the more likely the results will be useful.  The `regionTable` only determines sort order if multiple entries are returned, it does not constrain the search."
    },
    "Look up geocoding information for the specified location.": {
        "prefix": "hs.location.geocoder.lookupLocation(locationTable, fn) -> geocoderObject",
        "body": "hs.location.geocoder.lookupLocation(${1:locationTable}, ${2:fn})",
        "description": "Look up geocoding information for the specified location.\n\nParameters:\n * `locationTable` - a locationTable as described in the `hs.location` header specifying a location to obtain geocoding information about.\n * `fn`            - A callback function which should expect 2 arguments and return none:\n   * `state`  - a boolean indicating whether or not geocoding data was provided\n   * `result` - if `state` is true indicating that geocoding was successful, this argument will be a table containing one or more placemarkTables (as described in the module header) containing the geocoding data available for the location.  If `state` is false, this argument will be a string containing an error message describing the problem encountered.\n\nReturns:\n * a geocodingObject\n\nNotes:\n * This constructor requires internet access and the callback will be invoked with an error message if the internet is not currently accessible.\n * This constructor does not require Location Services to be enabled for Hammerspoon."
    },
    "Logs debug info to the console": {
        "prefix": "hs.logger:d(...)",
        "body": "hs.logger:d(${1:...})",
        "description": "Logs debug info to the console\n\nParameters:\n * ... - one or more message strings\n\nReturns:\n * None"
    },
    "Default log level for new logger instances.": {
        "prefix": "hs.logger.defaultLogLevel",
        "body": "hs.logger.defaultLogLevel",
        "description": "Default log level for new logger instances.\n\nThe starting value is 'warning'; set this (to e.g. 'info') at the top of your `init.lua` to affect\nall logger instances created without specifying a `loglevel` parameter"
    },
    "Logs formatted debug info to the console": {
        "prefix": "hs.logger:df(fmt,...)",
        "body": "hs.logger:df(${1:fmt},${2:...})",
        "description": "Logs formatted debug info to the console\n\nParameters:\n * fmt - formatting string as per string.format\n * ... - arguments to fmt\n\nReturns:\n * None"
    },
    "Logs an error to the console": {
        "prefix": "hs.logger:e(...)",
        "body": "hs.logger:e(${1:...})",
        "description": "Logs an error to the console\n\nParameters:\n * ... - one or more message strings\n\nReturns:\n * None"
    },
    "Logs a formatted error to the console": {
        "prefix": "hs.logger:ef(fmt,...)",
        "body": "hs.logger:ef(${1:fmt},${2:...})",
        "description": "Logs a formatted error to the console\n\nParameters:\n * fmt - formatting string as per string.format\n * ... - arguments to fmt\n\nReturns:\n * None"
    },
    "Logs formatted info to the console": {
        "prefix": "hs.logger:f(fmt,...)",
        "body": "hs.logger:f(${1:fmt},${2:...})",
        "description": "Logs formatted info to the console\n\nParameters:\n * fmt - formatting string as per string.format\n * ... - arguments to fmt\n\nReturns:\n * None"
    },
    "Gets the log level of the logger instance": {
        "prefix": "hs.logger:getLogLevel() -> number",
        "body": "hs.logger:getLogLevel()",
        "description": "Gets the log level of the logger instance\n\nParameters:\n * None\n\nReturns:\n * The log level of this logger as a number between 0 and 5"
    },
    "Returns the global log history": {
        "prefix": "hs.logger.history() -> list of log entries",
        "body": "hs.logger.history()",
        "description": "Returns the global log history\n\nParameters:\n * None\n\nReturns:\n * a list of (at most `hs.logger.historySize()`) log entries produced by all the logger instances, in chronological order;\n   each entry is a table with the following fields:\n   * time - timestamp in seconds since the epoch\n   * level - a number between 1 (error) and 5 (verbose)\n   * id - a string containing the id of the logger instance that produced this entry\n   * message - a string containing the logged message"
    },
    "Sets or gets the global log history size": {
        "prefix": "hs.logger.historySize([size]) -> number",
        "body": "hs.logger.historySize(${1:[size]})",
        "description": "Sets or gets the global log history size\n\nParameters:\n * size - (optional) the desired number of log entries to keep in the history;\n   if omitted, will return the current size; the starting value is 0 (disabled)\n\nReturns:\n * the current or new history size\n\nNotes:\n * if you change history size (other than from 0) after creating any logger instances, things will likely break"
    },
    "Logs info to the console": {
        "prefix": "hs.logger:i(...)",
        "body": "hs.logger:i(${1:...})",
        "description": "Logs info to the console\n\nParameters:\n * ... - one or more message strings\n\nReturns:\n * None"
    },
    "The log level of the logger instance, as a number between 0 and 5": {
        "prefix": "hs.logger.level",
        "body": "hs.logger.level",
        "description": "The log level of the logger instance, as a number between 0 and 5"
    },
    "Creates a new logger instance": {
        "prefix": "hs.logger.new(id, loglevel) -> logger",
        "body": "hs.logger.new(${1:id}, ${2:loglevel})",
        "description": "Creates a new logger instance\n\nParameters:\n * id - a string identifier for the instance (usually the module name)\n * loglevel - (optional) can be 'nothing', 'error', 'warning', 'info', 'debug', or 'verbose', or a corresponding number\n   between 0 and 5; uses `hs.logger.defaultLogLevel` if omitted\n\nReturns:\n * the new logger instance\n\nNotes:\n * the logger instance created by this method is not a regular object, but a plain table with \"static\" functions;\n   therefore, do not use the colon syntax for so-called \"methods\" in this module (as in `mylogger:setLogLevel(3)`);\n   you must instead use the regular dot syntax: `mylogger.setLogLevel(3)`\n\nExample:\n```lua\nlocal log = hs.logger.new('mymodule','debug')\nlog.i('Initializing') -- will print \"[mymodule] Initializing\" to the console\n```"
    },
    "Prints the global log history to the console": {
        "prefix": "hs.logger.printHistory([entries[, level[, filter[, caseSensitive]]]])",
        "body": "hs.logger.printHistory(${1:[entries[}, ${2:level[}, ${3:filter[}, ${4:caseSensitive]]]]})",
        "description": "Prints the global log history to the console\n\nParameters:\n * entries - (optional) the maximum number of entries to print; if omitted, all entries in the history will be printed\n * level - (optional) the desired log level (see `hs.logger:setLogLevel()`); if omitted, defaults to `verbose`\n * filter - (optional) a string to filter the entries (by logger id or message) via `string.find` plain matching\n * caseSensitive - (optional) if true, filtering is case sensitive\n\nReturns:\n * None"
    },
    "Sets the log level for all logger instances (including objects' loggers)": {
        "prefix": "hs.logger.setGlobalLogLevel(lvl)",
        "body": "hs.logger.setGlobalLogLevel(${1:lvl})",
        "description": "Sets the log level for all logger instances (including objects' loggers)\n\nParameters:\n * lvl\n\nReturns:\n * None"
    },
    "Sets the log level of the logger instance": {
        "prefix": "hs.logger:setLogLevel(loglevel)",
        "body": "hs.logger:setLogLevel(${1:loglevel})",
        "description": "Sets the log level of the logger instance\n\nParameters:\n * loglevel - can be 'nothing', 'error', 'warning', 'info', 'debug', or 'verbose'; or a corresponding number between 0 and 5\n\nReturns:\n * None"
    },
    "Sets the log level for all currently loaded modules": {
        "prefix": "hs.logger.setModulesLogLevel(lvl)",
        "body": "hs.logger.setModulesLogLevel(${1:lvl})",
        "description": "Sets the log level for all currently loaded modules\n\nParameters:\n * lvl\n\nReturns:\n * None\n\nNotes:\n * This function only affects *module*-level loggers, object instances with their own loggers (e.g. windowfilters) won't be affected;\n   you can use `hs.logger.setGlobalLogLevel()` for those"
    },
    "Logs verbose info to the console": {
        "prefix": "hs.logger:v(...)",
        "body": "hs.logger:v(${1:...})",
        "description": "Logs verbose info to the console\n\nParameters:\n * ... - one or more message strings\n\nReturns:\n * None"
    },
    "Logs formatted verbose info to the console": {
        "prefix": "hs.logger:vf(fmt,...)",
        "body": "hs.logger:vf(${1:fmt},${2:...})",
        "description": "Logs formatted verbose info to the console\n\nParameters:\n * fmt - formatting string as per string.format\n * ... - arguments to fmt\n\nReturns:\n * None"
    },
    "Logs a warning to the console": {
        "prefix": "hs.logger:w(...)",
        "body": "hs.logger:w(${1:...})",
        "description": "Logs a warning to the console\n\nParameters:\n * ... - one or more message strings\n\nReturns:\n * None"
    },
    "Logs a formatted warning to the console": {
        "prefix": "hs.logger:wf(fmt,...)",
        "body": "hs.logger:wf(${1:fmt},${2:...})",
        "description": "Logs a formatted warning to the console\n\nParameters:\n * fmt - formatting string as per string.format\n * ... - arguments to fmt\n\nReturns:\n * None"
    },
    "Returns whether or not the value is a finite number": {
        "prefix": "hs.math.isFinite(value) -> boolean",
        "body": "hs.math.isFinite(${1:value})",
        "description": "Returns whether or not the value is a finite number\n\nParamters:\n * `value` - the value to be tested\n\nReturns:\n * true if the value is a finite number, or false otherwise\n\nNotes:\n * This function returns true if the value is a number and both [hs.math.isNaN](#isNaN) and [hs.math.isInfinite](#isInfinite) return false."
    },
    "Returns whether or not the value is the mathematical equivalent of either positive or negative \"Infinity\"": {
        "prefix": "hs.math.isInfinite(value) -> 1, -1, false",
        "body": "hs.math.isInfinite(${1:value})",
        "description": "Returns whether or not the value is the mathematical equivalent of either positive or negative \"Infinity\"\n\nParameters:\n * `value` - the value to be tested\n\nReturns:\n * 1 if the value is equivalent to positive infinity, -1 if the value is equivalent to negative infinity, or false otherwise.\n\nNotes:\n * This function specifically checks if the `value` is equivalent to positive or negative infinity --- it does not do type checking. If `value` is not a numeric value (e.g. a string), it *cannot* be equivalent to positive or negative infinity and will return false.\n * Because lua treats any value other than `nil` and `false` as `true`, the return value of this function can be safely used in conditionals when you don't care about the sign of the infinite value."
    },
    "Returns whether or not the value is the mathematical equivalent of \"Not-A-Number\"": {
        "prefix": "hs.math.isNaN(value) -> boolean",
        "body": "hs.math.isNaN(${1:value})",
        "description": "Returns whether or not the value is the mathematical equivalent of \"Not-A-Number\"\n\nParameters:\n * `value` - the value to be tested\n\nReturns:\n * true if `value` is equal to the mathematical \"value\" of NaN, or false otherwise\n\nNotes:\n * Mathematical `NaN` represents an impossible value, usually the result of a calculation, yet is still considered within the domain of mathematics. The most common case is the result of `n / 0` as division by 0 is considered undefined or \"impossible\".\n * This function specifically checks if the `value` is `NaN` --- it does not do type checking. If `value` is not a numeric value (e.g. a string), it *cannot* be equivalent to `NaN` and this function will return false."
    },
    "Smallest positive floating point number representable in Hammerspoon": {
        "prefix": "hs.math.minFloat",
        "body": "hs.math.minFloat",
        "description": "Smallest positive floating point number representable in Hammerspoon\n\nNotes:\n * Because specifying a delay of 0 to `hs.timer.doAfter` results in the event not triggering, use this value to indicate that the action should occur as soon as possible after the current code block has completed execution."
    },
    "Returns a random floating point number between 0 and 1": {
        "prefix": "hs.math.randomFloat() -> number",
        "body": "hs.math.randomFloat()",
        "description": "Returns a random floating point number between 0 and 1\n\nParameters:\n * None\n\nReturns:\n * A random number between 0 and 1"
    },
    "Returns a random integer between the start and end paramters": {
        "prefix": "hs.math.randomFromRange(start, end) -> integer",
        "body": "hs.math.randomFromRange(${1:start}, ${2:end})",
        "description": "Returns a random integer between the start and end paramters\n\nParameters:\n * start - A number to start the range, must be greater than or equal to zero\n * end - A number to end the range, must be greater than zero and greater than `start`\n\nReturns:\n * A randomly chosen integer between `start` and `end`"
    },
    "Removes the menubar item from the menubar and destroys it": {
        "prefix": "hs.menubar:delete()",
        "body": "hs.menubar:delete()",
        "description": "Removes the menubar item from the menubar and destroys it\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Returns the menubar item frame": {
        "prefix": "hs.menubar:frame() -> hs.geometry rect",
        "body": "hs.menubar:frame()",
        "description": "Returns the menubar item frame\n\nParameters\n * None\n\nReturns:\n * an hs.geometry rect describing the menubar item's frame or nil if the menubar item is not currently in the menubar.\n\nNotes:\n * This will return a frame even if no icon or title is set"
    },
    "Returns the current icon of the menubar item object.": {
        "prefix": "hs.menubar:icon() -> hs.image object",
        "body": "hs.menubar:icon()",
        "description": "Returns the current icon of the menubar item object.\n\nParameters:\n * None\n\nReturns:\n * the menubar item icon as an hs.image object, or nil, if there isn't one."
    },
    "Returns a boolean indicating whether or not the specified menu is currently in the OS X menubar.": {
        "prefix": "hs.menubar:isInMenuBar() -> boolean",
        "body": "hs.menubar:isInMenuBar()",
        "description": "Returns a boolean indicating whether or not the specified menu is currently in the OS X menubar.\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the specified menu is currently in the OS X menubar"
    },
    "Creates a new menu bar item object and optionally add it to the system menubar": {
        "prefix": "hs.menubar.new([inMenuBar]) -> menubaritem or nil",
        "body": "hs.menubar.new(${1:[inMenuBar]})",
        "description": "Creates a new menu bar item object and optionally add it to the system menubar\n\nParameters:\n * inMenuBar -- an optional parameter which defaults to true.  If it is true, the menubaritem is added to the system menubar, otherwise the menubaritem is hidden.\n\nReturns:\n * menubar item object to use with other API methods, or nil if it could not be created\n\nNotes:\n * You should call hs.menubar:setTitle() or hs.menubar:setIcon() after creating the object, otherwise it will be invisible\n\n * Calling this method with inMenuBar equal to false is equivalent to calling hs.menubar.new():removeFromMenuBar().\n * A hidden menubaritem can be added to the system menubar by calling hs.menubar:returnToMenuBar() or used as a pop-up menu by calling hs.menubar:popupMenu()."
    },
    "Creates a new menu bar item object with the specified priority": {
        "prefix": "hs.menubar.newWithPriority(priority) -> menubaritem or nil",
        "body": "hs.menubar.newWithPriority(${1:priority})",
        "description": "Creates a new menu bar item object with the specified priority\n\nParameters:\n * priority - an integer specifying the menubar item's priority.  A menubar item's position is determined by its priority value.\n\nReturns:\n * menubar item object to use with other API methods, or nil if it could not be created\n\nNotes:\n * Default priority levels can be found in the [hs.menubar.priorities](#priorities) table.\n\n * This constructor uses undocumented methods in the NSStatusBar and NSStatusItem classes; because of this, we cannot guarantee that it will work with future versions of OS X.  This constructor has been written so that if the necessary private methods are not present, then a warning will be sent to the Hammerspoon console and the menubar item will be created in its default position -- the equivalent of using the [hs.menubar.new](#new) constructor instead of this one."
    },
    "Display a menubaritem as a pop up menu at the specified screen point.": {
        "prefix": "hs.menubar:popupMenu(point[, darkMode]) -> menubaritem",
        "body": "hs.menubar:popupMenu(${1:point[}, ${2:darkMode]})",
        "description": "Display a menubaritem as a pop up menu at the specified screen point.\n\nParameters:\n * point - the location of the upper left corner of the pop-up menu to be displayed.\n * darkMode - (optional) `true` to force the menubar dark (defaults to your macOS General Appearance settings)\n\nReturns:\n * The menubaritem\n\nNotes:\n * Items which trigger hs.menubar:setClickCallback() will invoke the callback function, but we cannot control the positioning of any visual elements the function may create -- calling this method on such an object is the equivalent of invoking its callback function directly.\n * This method is blocking. Hammerspoon will be unable to respond to any other activity while the pop-up menu is being displayed.\n * `darkMode` uses an undocumented macOS API call, so may break in a future release."
    },
    "Pre-defined list of priority levels which can be used for positioning menubar items.": {
        "prefix": "hs.menubar.priorities[]",
        "body": "hs.menubar.priorities",
        "description": "Pre-defined list of priority levels which can be used for positioning menubar items.\n\nThe constants defined are as follows:\n * default            - the default priority -- to the left of existing menubar items\n * system             - the default priority for Apple system menubar icons (Wifi, Bluetooth, etc.)\n * spotlight          - the Spotlight menubar icon priority\n * notificationCenter - the Notification Center icon priority\n\nYou are not limited to these priorities, but the behavior is undefined if you specify a priority less than 0 or greater than 2147483647 (the `notificationCenter` priority)."
    },
    "Get or set a menubar item's priority": {
        "prefix": "hs.menubar:priority([priority]) -> menubaritem | current-value",
        "body": "hs.menubar:priority(${1:[priority]})",
        "description": "Get or set a menubar item's priority\n\nParameters:\n * priority - an optional integer specifying the menubar item's priority.  A menubar item's position is determined by its priority value.\n\nReturns:\n * if a priority is provided, then the menubaritem object is returned; otherwise the current priority value is returned.\n\nNotes:\n * Default priority levels can be found in the [hs.menubar.priorities](#priorities) table.\n\n * This method uses undocumented methods in the NSStatusBar and NSStatusItem classes, which appear to have been removed in macOS 10.15 (Catalina), so this method will no longer work correctly."
    },
    "Removes a menu from the system menu bar.  The item can still be used as a pop-up menu, unless you also delete it.": {
        "prefix": "hs.menubar:removeFromMenuBar() -> menubaritem",
        "body": "hs.menubar:removeFromMenuBar()",
        "description": "Removes a menu from the system menu bar.  The item can still be used as a pop-up menu, unless you also delete it.\n\nParameters:\n * None\n\nReturns:\n * the menubaritem"
    },
    "Returns a previously removed menu back to the system menu bar.": {
        "prefix": "hs.menubar:returnToMenuBar() -> menubaritem",
        "body": "hs.menubar:returnToMenuBar()",
        "description": "Returns a previously removed menu back to the system menu bar.\n\nParameters:\n * None\n\nReturns:\n * the menubaritem"
    },
    "Registers a function to be called when the menubar item is clicked": {
        "prefix": "hs.menubar:setClickCallback([fn]) -> menubaritem",
        "body": "hs.menubar:setClickCallback(${1:[fn]})",
        "description": "Registers a function to be called when the menubar item is clicked\n\nParameters:\n * `fn` - An optional function to be called when the menubar item is clicked. If this argument is not provided, any existing function will be removed. The function can optionally accept a single argument, which will be a table containing boolean values indicating which keyboard modifiers were held down when the menubar item was clicked; The possible keys are:\n  * cmd\n  * alt\n  * shift\n  * ctrl\n  * fn\n\nReturns:\n * the menubaritem\n\nNotes:\n * If a menu has been attached to the menubar item, this callback will never be called\n * Has no affect on the display of a pop-up menu, but changes will be be in effect if hs.menubar:returnToMenuBar() is called on the menubaritem."
    },
    "Sets the image of a menubar item object. The image will be displayed in the system menubar": {
        "prefix": "hs.menubar:setIcon(imageData[, template]) -> menubaritem or nil",
        "body": "hs.menubar:setIcon(${1:imageData[}, ${2:template]})",
        "description": "Sets the image of a menubar item object. The image will be displayed in the system menubar\n\nParameters:\n * imageData - This can one of the following:\n  * An `hs.image` object\n  * A string containing a path to an image file\n  * A string beginning with `ASCII:` which signifies that the rest of the string is interpreted as a special form of ASCII diagram, which will be rendered to an image and used as the icon. See the notes below for information about the special format of ASCII diagram.\n  * nil, indicating that the current image is to be removed\n * template - An optional boolean value which defaults to true. If it's true, the provided image will be treated as a \"template\" image, which allows it to automatically support OS X 10.10's Dark Mode. If it's false, the image will be used as is, supporting colour.\n\nReturns:\n * the menubaritem if the image was loaded and set, `nil` if it could not be found or loaded\n\nNotes:\n * ** API Change **\n   * This method used to return true on success -- this has been changed to return the menubaritem on success to facilitate method chaining.  Since Lua treats any value which is not nil or false as \"true\", this should only affect code where the return value was actually being compared to true, e.g. `if result == true then...` rather than the (unaffected) `if result then...`.\n\n * If you set a title as well as an icon, they will both be displayed next to each other\n * Has no affect on the display of a pop-up menu, but changes will be be in effect if hs.menubar:returnToMenuBar() is called on the menubaritem.\n\n * Icons should be small, transparent images that roughly match the size of normal menubar icons, otherwise they will look very strange. Note that if you're using an `hs.image` image object as the icon, you can force it to be resized with `hs.image:setSize({w=16,h=16})`\n * Retina scaling is supported if the image is either scalable (e.g. a PDF produced by Adobe Illustrator) or contain multiple sizes (e.g. a TIFF with small and large images). Images will not automatically do the right thing if you have a @2x version present\n * Icons are by default specified as \"templates\", which allows them to automatically support OS X 10.10's Dark Mode, but this also means they cannot be complicated, colour images.\n * For examples of images that work well, see Hammerspoon.app/Contents/Resources/statusicon.tiff (for a retina-capable multi-image TIFF icon) or [https://github.com/jigish/slate/blob/master/Slate/status.pdf](https://github.com/jigish/slate/blob/master/Slate/status.pdf) (for a scalable vector PDF icon)\n * For guidelines on the sizing of images, see [http://alastairs-place.net/blog/2013/07/23/nsstatusitem-what-size-should-your-icon-be/](http://alastairs-place.net/blog/2013/07/23/nsstatusitem-what-size-should-your-icon-be/)"
    },
    "Attaches a dropdown menu to the menubar item": {
        "prefix": "hs.menubar:setMenu(menuTable) -> menubaritem",
        "body": "hs.menubar:setMenu(${1:menuTable})",
        "description": "Attaches a dropdown menu to the menubar item\n\nParameters:\n * `menuTable`:\n     * If this argument is `nil`:\n        * Removes any previously registered menu\n     * If this argument is a table:\n        * Sets the menu for this menubar item to the supplied table. The format of the table is documented below\n     * If this argument is a function:\n        * The function will be called each time the user clicks on the menubar item and the function should return a table that specifies the menu to be displayed. The table should be of the same format as described below. The function can optionally accept a single argument, which will be a table containing boolean values indicating which keyboard modifiers were held down when the menubar item was clicked; The possible keys are:\n           * cmd\n           * alt\n           * shift\n           * ctrl\n           * fn\n\nTable Format:\n```\n   {\n       { title = \"my menu item\", fn = function() print(\"you clicked my menu item!\") end },\n       { title = \"-\" },\n       { title = \"other item\", fn = some_function },\n       { title = \"disabled item\", disabled = true },\n       { title = \"checked item\", checked = true },\n   }\n```\n * The available keys for each menu item are (note that `title` is the only required key -- all other keys are optional):\n     * `title`           - A string or `hs.styledtext` object to be displayed in the menu. If this is the special string `\"-\"` the item will be rendered as a menu separator.  This key can be set to the empty string (\"\"), but it must be present.\n     * `fn`              - A function to be executed when the menu item is clicked\n        * The function will be called with two arguments. The first argument will be a table containing boolean values indicating which keyboard modifiers were held down when the menubar item was clicked (see `menuTable` parameter for possible keys) and the second is the table representing the item.\n     * `checked`         - A boolean to indicate if the menu item should have a checkmark (by default) next to it or not. Defaults to false.\n     * `state`           - a text value of \"on\", \"off\", or \"mixed\" indicating the menu item state.  \"on\" and \"off\" are equivalent to `checked` being true or false respectively, and \"mixed\" will have a dash (by default) beside it.\n     * `disabled`        - A boolean to indicate if the menu item should be unselectable or not. Defaults to false (i.e. menu items are selectable by default)\n     * `menu`            - a table, in the same format as above, which will be presented as a sub-menu for this menu item.\n        * a menu item that is disabled and has a sub-menu will show the arrow at the right indicating that it has a sub-menu, but the items within the sub-menu will not be available, even if the sub-menu items are not disabled themselves.\n        * a menu item with a sub-menu is also a clickable target, so it can also have an `fn` key.\n     * `image`           - An image to display in the menu to the right of any state image or checkmark and to the left of the menu item title.  This image is not constrained by the size set with [hs.menubar:stateImageSize](#stateImageSize), so you should adjust it with `hs.image:setSize` if your image is extremely large or small.\n     * `tooltip`         - A tool tip to display if you hover the cursor over a menu item for a few seconds.\n     * `shortcut`        - A string containing a single character, which will be used as the keyboard shortcut for the menu item. Note that if you use a capital letter, the Shift key will be required to activate the shortcut.\n     * `indent`          - An integer from 0 to 15 indicating how far to the right a menu item should be indented.  Defaults to 0.\n     * `onStateImage`    - An image to display when `checked` is true or `state` is set to \"on\".  This image size is constrained to the size set by [hs.menubar:stateImageSize](#stateImageSize).  If this key is not set, a checkmark will be displayed for checked or \"on\" menu items.\n     * `offStateImage`   - An image to display when `checked` is false or `state` is set to \"off\".  This image size is constrained to the size set by [hs.menubar:stateImageSize](#stateImageSize).  If this key is not set, no special marking appears next to the menu item.\n     * `mixedStateImage` - An image to display when `state` is set to \"mixed\".  This image size is constrained to the size set by [hs.menubar:stateImageSize](#stateImageSize).  If this key is not set, a dash will be displayed for menu items with a state of \"mixed\".\n\nReturns:\n * the menubaritem\n\nNotes:\n * If you are using the callback function, you should take care not to take too long to generate the menu, as you will block the process and the OS may decide to remove the menubar item"
    },
    "Sets the title of a menubar item object. The title will be displayed in the system menubar": {
        "prefix": "hs.menubar:setTitle(title) -> menubaritem",
        "body": "hs.menubar:setTitle(${1:title})",
        "description": "Sets the title of a menubar item object. The title will be displayed in the system menubar\n\nParameters:\n * `title` - A string or `hs.styledtext` object to use as the title, or nil to remove the title\n\nReturns:\n * the menubar item\n\nNotes:\n * If you set an icon as well as a title, they will both be displayed next to each other\n * Has no affect on the display of a pop-up menu, but changes will be be in effect if hs.menubar:returnToMenuBar() is called on the menubaritem."
    },
    "Sets the tooltip text on a menubar item": {
        "prefix": "hs.menubar:setTooltip(tooltip) -> menubaritem",
        "body": "hs.menubar:setTooltip(${1:tooltip})",
        "description": "Sets the tooltip text on a menubar item\n\nParameters:\n * `tooltip` - A string to use as the tooltip\n\nReturns:\n * the menubaritem\n\nNotes:\n * Has no affect on the display of a pop-up menu, but changes will be be in effect if hs.menubar:returnToMenuBar() is called on the menubaritem."
    },
    "Get or set the size for state images when the menu is displayed.": {
        "prefix": "hs.menubar:stateImageSize([size]) -> hs.image object | current value",
        "body": "hs.menubar:stateImageSize(${1:[size]})",
        "description": "Get or set the size for state images when the menu is displayed.\n\nParameters:\n * size - an optional table specifying the size for state images displayed when using the `checked` or `state` key in a menu table definition.  Defaults to a size determined by the system menu font point size.  If you specify an explicit nil, the size is reset to this default.\n\nReturns:\n * if a parameter is provided, returns the menubar item; otherwise returns the current value.\n\nNotes:\n * An image is used rather than a checkmark or dash only when you set them with the `onStateImage`, `offStateImage`, or `mixedStateImage` keys.  If you are not using these keys, then this method will have no visible effect on the menu's rendering.  See  [hs.menubar:setMenu](#setMenu) for more information.\n * If you are setting the menu contents with a static table, you should invoke this method before invoking [hs.menubar:setMenu](#setMenu), as changes will only go into effect when the table is next converted to a menu structure."
    },
    "Returns the current title of the menubar item object.": {
        "prefix": "hs.menubar:title([styled]) -> string | styledtextObject",
        "body": "hs.menubar:title(${1:[styled]})",
        "description": "Returns the current title of the menubar item object.\n\nParameters:\n * styled - an optional boolean, defaulting to false, indicating that a styledtextObject representing the text of the menu title should be returned\n\nReturns:\n * the menubar item title, or an empty string, if there isn't one.  If `styled` is not set or is false, then a string is returned; otherwise a styledtextObject will be returned."
    },
    "Sends an iMessage": {
        "prefix": "hs.messages.iMessage(targetAddress, message)",
        "body": "hs.${2:message}s.iMessage(${1:targetAddress}, message)",
        "description": "Sends an iMessage\n\nParameters:\n * targetAddress - A string containing a phone number or email address registered with iMessage, to send the iMessage to\n * message - A string containing the message to send\n\nReturns:\n * None"
    },
    "Sends an SMS using SMS Relay": {
        "prefix": "hs.messages.SMS(targetNumber, message)",
        "body": "hs.${2:message}s.SMS(${1:targetNumber}, message)",
        "description": "Sends an SMS using SMS Relay\n\nParameters:\n * targetNumber - A string containing a phone number to send an SMS to\n * message - A string containing the message to send\n\nReturns:\n * None"
    },
    "Sets or removes a callback function for the `hs.midi` object.": {
        "prefix": "hs.midi:callback(callbackFn | nil)",
        "body": "hs.midi:callback(${1:callbackFn | nil})",
        "description": "Sets or removes a callback function for the `hs.midi` object.\n\nParameters:\n * `callbackFn` - a function to set as the callback for this `hs.midi` object.  If the value provided is `nil`, any currently existing callback function is removed.\n\nReturns:\n * The `hs.midi` object\n\nNotes:\n * Most MIDI keyboards produce a `noteOn` when you press a key, then `noteOff` when you release. However, some MIDI keyboards will return a `noteOn` with 0 `velocity` instead of `noteOff`, so you will recieve two `noteOn` commands for every key press/release.\n * The callback function should expect 5 arguments and should not return anything:\n   * `object`       - The `hs.midi` object.\n   * `deviceName`   - The device name as a string.\n   * `commandType`  - Type of MIDI message as defined as a string. See `hs.midi.commandTypes[]` for a list of possibilities.\n   * `description`  - Description of the event as a string. This is only really useful for debugging.\n   * `metadata`     - A table of data for the MIDI command (see below).\n\n * The `metadata` table will return the following, depending on the `commandType` for the callback:\n\n   * `noteOff` - Note off command:\n     * note                - The note number for the command. Must be between 0 and 127.\n     * velocity            - The velocity for the command. Must be between 0 and 127.\n     * channel             - The channel for the command. Must be a number between 15.\n     * timestamp           - The timestamp for the command as a string.\n     * data                - Raw MIDI Data as Hex String.\n     * isVirtual           - `true` if Virtual MIDI Source otherwise `false`.\n\n   * `noteOn` - Note on command:\n     * note                - The note number for the command. Must be between 0 and 127.\n     * velocity            - The velocity for the command. Must be between 0 and 127.\n     * channel             - The channel for the command. Must be a number between 15.\n     * timestamp           - The timestamp for the command as a string.\n     * data                - Raw MIDI Data as Hex String.\n     * isVirtual           - `true` if Virtual MIDI Source otherwise `false`.\n\n   * `polyphonicKeyPressure` - Polyphonic key pressure command:\n     * note                - The note number for the command. Must be between 0 and 127.\n     * pressure            - Key pressure of the polyphonic key pressure message. In the range 0-127.\n     * channel             - The channel for the command. Must be a number between 15.\n     * timestamp           - The timestamp for the command as a string.\n     * data                - Raw MIDI Data as Hex String.\n     * isVirtual           - `true` if Virtual MIDI Source otherwise `false`.\n\n   * `controlChange` - Control change command. This is the most common command sent by MIDI controllers:\n     * controllerNumber    - The MIDI control number for the command.\n     * controllerValue     - The controllerValue of the command. Only the lower 7-bits of this are used.\n     * channel             - The channel for the command. Must be a number between 15.\n     * timestamp           - The timestamp for the command as a string.\n     * data                - Raw MIDI Data as Hex String.\n     * fourteenBitValue    - The 14-bit value of the command.\n     * fourteenBitCommand  - `true` if the command contains 14-bit value data otherwise, `false`.\n     * isVirtual           - `true` if Virtual MIDI Source otherwise `false`.\n\n   * `programChange` - Program change command:\n     * programNumber       - The program (aka patch) number. From 0-127.\n     * channel             - The channel for the command. Must be a number between 15.\n     * timestamp           - The timestamp for the command as a string.\n     * data                - Raw MIDI Data as Hex String.\n     * isVirtual           - `true` if Virtual MIDI Source otherwise `false`.\n\n   * `channelPressure` - Channel pressure command:\n     * pressure            - Key pressure of the channel pressure message. In the range 0-127.\n     * channel             - The channel for the command. Must be a number between 15.\n     * timestamp           - The timestamp for the command as a string.\n     * data                - Raw MIDI Data as Hex String.\n     * isVirtual           - `true` if Virtual MIDI Source otherwise `false`.\n\n   * `pitchWheelChange` - Pitch wheel change command:\n     * pitchChange         -  A 14-bit value indicating the pitch bend. Center is 0x2000 (8192). Valid range is from 0-16383.\n     * channel             - The channel for the command. Must be a number between 15.\n     * timestamp           - The timestamp for the command as a string.\n     * data                - Raw MIDI Data as Hex String.\n     * isVirtual           - `true` if Virtual MIDI Source otherwise `false`.\n\n   * `systemMessage` - System message command:\n     * dataByte1           - Data Byte 1 as integer.\n     * dataByte2           - Data Byte 2 as integer.\n     * timestamp           - The timestamp for the command as a string.\n     * data                - Raw MIDI Data as Hex String.\n     * isVirtual           - `true` if Virtual MIDI Source otherwise `false`.\n\n   * `systemExclusive` - System message command:\n     * manufacturerID      - The manufacturer ID for the command. This is used by devices to determine if the message is one they support.\n     * sysexChannel        - The channel of the message. Only valid for universal exclusive messages, will always be 0 for non-universal messages.\n     * sysexData           - The system exclusive data for the message. For universal messages subID's are included in sysexData, for non-universal messages, any device specific information (such as modelID, versionID or whatever manufactures decide to include) will be included in sysexData.\n     * timestamp           - The timestamp for the command as a string.\n     * data                - Raw MIDI Data as Hex String.\n     * isVirtual           - `true` if Virtual MIDI Source otherwise `false`.\n\n   * `systemTimecodeQuarterFrame` - System exclusive (SysEx) command:\n     * dataByte1           - Data Byte 1 as integer.\n     * dataByte2           - Data Byte 2 as integer.\n     * timestamp           - The timestamp for the command as a string.\n     * data                - Raw MIDI Data as Hex String.\n     * isVirtual           - `true` if Virtual MIDI Source otherwise `false`.\n\n   * `systemSongPositionPointer` - System song position pointer command:\n     * dataByte1           - Data Byte 1 as integer.\n     * dataByte2           - Data Byte 2 as integer.\n     * timestamp           - The timestamp for the command as a string.\n     * data                - Raw MIDI Data as Hex String.\n     * isVirtual           - `true` if Virtual MIDI Source otherwise `false`.\n\n   * `systemSongSelect` - System song select command:\n     * dataByte1           - Data Byte 1 as integer.\n     * dataByte2           - Data Byte 2 as integer.\n     * timestamp           - The timestamp for the command as a string.\n     * data                - Raw MIDI Data as Hex String.\n     * isVirtual           - `true` if Virtual MIDI Source otherwise `false`.\n\n   * `systemTuneRequest` - System tune request command:\n     * dataByte1           - Data Byte 1 as integer.\n     * dataByte2           - Data Byte 2 as integer.\n     * timestamp           - The timestamp for the command as a string.\n     * data                - Raw MIDI Data as Hex String.\n     * isVirtual           - `true` if Virtual MIDI Source otherwise `false`.\n\n   * `systemTimingClock` - System timing clock command:\n     * dataByte1           - Data Byte 1 as integer.\n     * dataByte2           - Data Byte 2 as integer.\n     * timestamp           - The timestamp for the command as a string.\n     * data                - Raw MIDI Data as Hex String.\n     * isVirtual           - `true` if Virtual MIDI Source otherwise `false`.\n\n   * `systemStartSequence` - System timing clock command:\n     * dataByte1           - Data Byte 1 as integer.\n     * dataByte2           - Data Byte 2 as integer.\n     * timestamp           - The timestamp for the command as a string.\n     * data                - Raw MIDI Data as Hex String.\n     * isVirtual           - `true` if Virtual MIDI Source otherwise `false`.\n\n   * `systemContinueSequence` - System start sequence command:\n     * dataByte1           - Data Byte 1 as integer.\n     * dataByte2           - Data Byte 2 as integer.\n     * timestamp           - The timestamp for the command as a string.\n     * data                - Raw MIDI Data as Hex String.\n     * isVirtual           - `true` if Virtual MIDI Source otherwise `false`.\n\n   * `systemStopSequence` -  System continue sequence command:\n     * dataByte1           - Data Byte 1 as integer.\n     * dataByte2           - Data Byte 2 as integer.\n     * timestamp           - The timestamp for the command as a string.\n     * data                - Raw MIDI Data as Hex String.\n     * isVirtual           - `true` if Virtual MIDI Source otherwise `false`.\n\n   * `systemKeepAlive` - System keep alive message:\n     * dataByte1           - Data Byte 1 as integer.\n     * dataByte2           - Data Byte 2 as integer.\n     * timestamp           - The timestamp for the command as a string.\n     * data                - Raw MIDI Data as Hex String.\n     * isVirtual           - `true` if Virtual MIDI Source otherwise `false`.\n\n * Example Usage:\n   ```\n   midiDevice = hs.midi.new(hs.midi.devices()[3])\n   midiDevice:callback(function(object, deviceName, commandType, description, metadata)\n              print(\"object: \" .. tostring(object))\n              print(\"deviceName: \" .. deviceName)\n              print(\"commandType: \" .. commandType)\n              print(\"description: \" .. description)\n              print(\"metadata: \" .. hs.inspect(metadata))\n              end)\n   ```"
    },
    "A table containing the numeric value for the possible flags returned by the `commandType` parameter of the callback function.": {
        "prefix": "hs.midi.commandTypes[]",
        "body": "hs.midi.commandTypes",
        "description": "A table containing the numeric value for the possible flags returned by the `commandType` parameter of the callback function.\n\nDefined keys are:\n  * noteOff                       - Note off command.\n  * noteOn                        - Note on command.\n  * polyphonicKeyPressure         - Polyphonic key pressure command.\n  * controlChange                 - Control change command. This is the most common command sent by MIDI controllers.\n  * programChange                 - Program change command.\n  * channelPressure               - Channel pressure command.\n  * pitchWheelChange              - Pitch wheel change command.\n  * systemMessage                 - System message command.\n  * systemExclusive               - System message command.\n  * SystemTimecodeQuarterFrame    - System exclusive (SysEx) command.\n  * systemSongPositionPointer     - System song position pointer command.\n  * systemSongSelect              - System song select command.\n  * systemTuneRequest             - System tune request command.\n  * systemTimingClock             - System timing clock command.\n  * systemStartSequence           - System timing clock command.\n  * systemContinueSequence        - System start sequence command.\n  * systemStopSequence            - System continue sequence command.\n  * systemKeepAlive               - System keep alive message."
    },
    "A callback that's triggered when a physical or virtual MIDI device is added or removed from the system.": {
        "prefix": "hs.midi.deviceCallback(callbackFn) -> none",
        "body": "hs.midi.deviceCallback(${1:callbackFn})",
        "description": "A callback that's triggered when a physical or virtual MIDI device is added or removed from the system.\n\nParameters:\n * callbackFn - the callback function to trigger.\n\nReturns:\n * None\n\nNotes:\n * The callback function should expect 2 argument and should not return anything:\n   * `devices` - A table containing the names of any physically connected MIDI devices as strings.\n   * `virtualDevices` - A table containing the names of any virtual MIDI devices as strings.\n * Example Usage:\n   ```\n   hs.midi.deviceCallback(function(devices, virtualDevices)\n        print(hs.inspect(devices))\n        print(hs.inspect(virtualDevices))\n   end)\n   ```"
    },
    "Returns a table of currently connected physical MIDI devices.": {
        "prefix": "hs.midi.devices() -> table",
        "body": "hs.midi.devices()",
        "description": "Returns a table of currently connected physical MIDI devices.\n\nParameters:\n * None\n\nReturns:\n * A table containing the names of any physically connected MIDI devices as strings."
    },
    "Returns the display name of a `hs.midi` object.": {
        "prefix": "hs.midi:displayName() -> string",
        "body": "hs.midi:displayName()",
        "description": "Returns the display name of a `hs.midi` object.\n\nParameters:\n * None\n\nReturns:\n * The name as a string."
    },
    "Sends an Identity Request message to the `hs.midi` device. You can use `hs.midi:callback()` to receive the `systemExclusive` response.": {
        "prefix": "hs.midi:identityRequest() -> none",
        "body": "hs.midi:identityRequest()",
        "description": "Sends an Identity Request message to the `hs.midi` device. You can use `hs.midi:callback()` to receive the `systemExclusive` response.\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * Example Usage:\n  ```\n  midiDevice = hs.midi.new(hs.midi.devices()[3])\n  midiDevice:callback(function(object, deviceName, commandType, description, metadata)\n                        print(\"object: \" .. tostring(object))\n                        print(\"deviceName: \" .. deviceName)\n                        print(\"commandType: \" .. commandType)\n                        print(\"description: \" .. description)\n                        print(\"metadata: \" .. hs.inspect(metadata))\n                      end)\n  midiDevice:identityRequest()\n  ```"
    },
    "Returns the online status of a `hs.midi` object.": {
        "prefix": "hs.midi:isOnline() -> boolean",
        "body": "hs.midi:isOnline()",
        "description": "Returns the online status of a `hs.midi` object.\n\nParameters:\n * None\n\nReturns:\n * `true` if online, otherwise `false`"
    },
    "Returns `true` if an `hs.midi` object is virtual, otherwise `false`.": {
        "prefix": "hs.midi:isVirtual() -> boolean",
        "body": "hs.midi:isVirtual()",
        "description": "Returns `true` if an `hs.midi` object is virtual, otherwise `false`.\n\nParameters:\n * None\n\nReturns:\n * `true` if virtual, otherwise `false`"
    },
    "Returns the manufacturer name of a `hs.midi` object.": {
        "prefix": "hs.midi:manufacturer() -> string",
        "body": "hs.midi:manufacturer()",
        "description": "Returns the manufacturer name of a `hs.midi` object.\n\nParameters:\n * None\n\nReturns:\n * The manufacturer name as a string."
    },
    "Returns the model name of a `hs.midi` object.": {
        "prefix": "hs.midi:model() -> string",
        "body": "hs.midi:model()",
        "description": "Returns the model name of a `hs.midi` object.\n\nParameters:\n * None\n\nReturns:\n * The model name as a string."
    },
    "Returns the name of a `hs.midi` object.": {
        "prefix": "hs.midi:name() -> string",
        "body": "hs.midi:name()",
        "description": "Returns the name of a `hs.midi` object.\n\nParameters:\n * None\n\nReturns:\n * The name as a string."
    },
    "Creates a new `hs.midi` object.": {
        "prefix": "hs.midi.new(deviceName) -> `hs.midi` object",
        "body": "hs.midi.new(${1:deviceName})",
        "description": "Creates a new `hs.midi` object.\n\nParameters:\n * deviceName - A string containing the device name of the MIDI device. A valid device name can be found by checking `hs.midi.devices()` and/or `hs.midi.virtualSources()`.\n\nReturns:\n * An `hs.midi` object or `nil` if an error occured.\n\nNotes:\n * Example Usage:\n   `hs.midi.new(hs.midi.devices()[1])`"
    },
    "Creates a new `hs.midi` object._1": {
        "prefix": "hs.midi.newVirtualSource(virtualSource) -> `hs.midi` object",
        "body": "hs.midi.newVirtualSource(${1:virtualSource})",
        "description": "Creates a new `hs.midi` object.\n\nParameters:\n * virtualSource - A string containing the virtual source name of the MIDI device. A valid virtual source name can be found by checking `hs.midi.virtualSources()`.\n\nReturns:\n * An `hs.midi` object or `nil` if an error occured.\n\nNotes:\n * Example Usage:\n   `hs.midi.new(hs.midi.virtualSources()[1])`"
    },
    "Sends a command to the `hs.midi` object.": {
        "prefix": "hs.midi:sendCommand(commandType, metadata) -> boolean",
        "body": "hs.midi:sendCommand(${1:commandType}, ${2:metadata})",
        "description": "Sends a command to the `hs.midi` object.\n\nParameters:\n * `commandType`    - The type of command you want to send as a string. See `hs.midi.commandTypes[]`.\n * `metadata`       - A table of data for the MIDI command (see notes below).\n\nReturns:\n * `true` if successful, otherwise `false`\n\nNotes:\n * The `metadata` table can accept following, depending on the `commandType` supplied:\n\n   * `noteOff` - Note off command:\n     * note                - The note number for the command. Must be between 0 and 127. Defaults to 0.\n     * velocity            - The velocity for the command. Must be between 0 and 127. Defaults to 0.\n     * channel             - The channel for the command. Must be a number between 0 and 16. Defaults to 0, which sends the command to All Channels.\n\n   * `noteOn` - Note on command:\n     * note                - The note number for the command. Must be between 0 and 127. Defaults to 0.\n     * velocity            - The velocity for the command. Must be between 0 and 127. Defaults to 0.\n     * channel             - The channel for the command. Must be a number between 0 and 16. Defaults to 0, which sends the command to All Channels.\n\n   * `polyphonicKeyPressure` - Polyphonic key pressure command:\n     * note                - The note number for the command. Must be between 0 and 127. Defaults to 0.\n     * pressure            - Key pressure of the polyphonic key pressure message. In the range 0-127. Defaults to 0.\n     * channel             - The channel for the command. Must be a number between 0 and 16. Defaults to 0, which sends the command to All Channels.\n\n   * `controlChange` - Control change command. This is the most common command sent by MIDI controllers:\n     * controllerNumber    - The MIDI control number for the command. Defaults to 0.\n     * controllerValue     - The controllerValue of the command. Only the lower 7-bits of this are used. Defaults to 0.\n     * channel             - The channel for the command. Must be a number between 0 and 16. Defaults to 0, which sends the command to All Channels.\n     * fourteenBitValue    - The 14-bit value of the command. Must be between 0 and 16383. Defaults to 0. `fourteenBitCommand` must be `true`.\n     * fourteenBitCommand  - `true` if the command contains 14-bit value data otherwise, `false`. `controllerValue` will be ignored if this is set to `true`.\n\n   * `programChange` - Program change command:\n     * programNumber       - The program (aka patch) number. From 0-127. Defaults to 0.\n     * channel             - The channel for the command. Must be a number between 0 and 16. Defaults to 0, which sends the command to All Channels.\n\n   * `channelPressure` - Channel pressure command:\n     * pressure            - Key pressure of the channel pressure message. In the range 0-127. Defaults to 0.\n     * channel             - The channel for the command. Must be a number between 0 and 16. Defaults to 0, which sends the command to All Channels.\n\n   * `pitchWheelChange` - Pitch wheel change command:\n     * pitchChange         -  A 14-bit value indicating the pitch bend. Center is 0x2000 (8192). Valid range is from 0-16383. Defaults to 0.\n     * channel             - The channel for the command. Must be a number between 0 and 16. Defaults to 0, which sends the command to All Channels.\n\n * Example Usage:\n    ```\n    midiDevice = hs.midi.new(hs.midi.devices()[1])\n    midiDevice:sendCommand(\"noteOn\", {\n        [\"note\"] = 72,\n        [\"velocity\"] = 50,\n        [\"channel\"] = 0,\n    })\n    hs.timer.usleep(500000)\n    midiDevice:sendCommand(\"noteOn\", {\n        [\"note\"] = 74,\n        [\"velocity\"] = 50,\n        [\"channel\"] = 0,\n    })\n    hs.timer.usleep(500000)\n    midiDevice:sendCommand(\"noteOn\", {\n        [\"note\"] = 76,\n        [\"velocity\"] = 50,\n        [\"channel\"] = 0,\n    })\n    midiDevice:sendCommand(\"pitchWheelChange\", {\n        [\"pitchChange\"] = 1000,\n        [\"channel\"] = 0,\n    })\n    hs.timer.usleep(100000)\n    midiDevice:sendCommand(\"pitchWheelChange\", {\n        [\"pitchChange\"] = 2000,\n        [\"channel\"] = 0,\n    })\n    hs.timer.usleep(100000)\n    midiDevice:sendCommand(\"pitchWheelChange\", {\n        [\"pitchChange\"] = 3000,\n        [\"channel\"] = 0,\n    })\n    ```"
    },
    "Sends a System Exclusive Command to the `hs.midi` object.": {
        "prefix": "hs.midi:sendSysex(command) -> none",
        "body": "hs.midi:sendSysex(${1:command})",
        "description": "Sends a System Exclusive Command to the `hs.midi` object.\n\nParameters:\n * `command` - The system exclusive command you wish to send as a string. White spaces in the string will be ignored.\n\nReturns:\n * None\n\nNotes:\n * Example Usage:\n   ```midiDevice:sendSysex(\"f07e7f06 01f7\")```"
    },
    "Set or display whether or not the MIDI device should synthesize audio on your computer.": {
        "prefix": "hs.midi:synthesize([value]) -> boolean",
        "body": "hs.midi:synthesize(${1:[value]})",
        "description": "Set or display whether or not the MIDI device should synthesize audio on your computer.\n\nParameters:\n * [value] - `true` if you want to synthesize audio, otherwise `false`.\n\nReturns:\n * `true` if enabled otherwise `false`"
    },
    "Returns a table of currently available Virtual MIDI sources. This includes devices, such as Native Instruments controllers which present as virtual endpoints rather than physical devices.": {
        "prefix": "hs.midi.virtualSources() -> table",
        "body": "hs.midi.virtualSources()",
        "description": "Returns a table of currently available Virtual MIDI sources. This includes devices, such as Native Instruments controllers which present as virtual endpoints rather than physical devices.\n\nParameters:\n * None\n\nReturns:\n * A table containing the names of any virtual MIDI sources as strings."
    },
    "Deletes an `hs.milight` object": {
        "prefix": "hs.milight:delete()",
        "body": "hs.milight:delete()",
        "description": "Deletes an `hs.milight` object\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Cycles through the disco modes": {
        "prefix": "hs.milight:disco() -> bool",
        "body": "hs.milight:disco()",
        "description": "Cycles through the disco modes\n\nParameters:\n * None\n\nReturns:\n * True if the command was sent correctly, otherwise false"
    },
    "Specifies the maximum brightness value that can be used. Defaults to 25": {
        "prefix": "hs.milight.maxBrightness",
        "body": "hs.milight.maxBrightness",
        "description": "Specifies the maximum brightness value that can be used. Defaults to 25"
    },
    "Specifies the minimum brightness value that can be used. Defaults to 0": {
        "prefix": "hs.milight.minBrightness",
        "body": "hs.milight.minBrightness",
        "description": "Specifies the minimum brightness value that can be used. Defaults to 0"
    },
    "Creates a new bridge object, which will be connected to the supplied IP address and port": {
        "prefix": "hs.milight.new(ip[, port]) -> bridge",
        "body": "hs.milight.new(${1:ip[}, ${2:port]})",
        "description": "Creates a new bridge object, which will be connected to the supplied IP address and port\n\nParameters:\n * ip - A string containing the IP address of the MiLight WiFi bridge device. For convenience this can be the broadcast address of your network (e.g. 192.168.0.255)\n * port - An optional number containing the UDP port to talk to the bridge on. Defaults to 8899\n\nReturns:\n * An `hs.milight` object\n\nNotes:\n * You can not use 255.255.255.255 as the IP address, to do so requires elevated privileges for the Hammerspoon process"
    },
    "Sends a command to the bridge": {
        "prefix": "hs.milight:send(cmd[, value]) -> bool",
        "body": "hs.milight:send(${1:cmd[}, ${2:value]})",
        "description": "Sends a command to the bridge\n\nParameters:\n * cmd - A command from the `hs.milight.cmd` table\n * value - An optional value, if appropriate for the command (defaults to 0x00)\n\nReturns:\n * True if the command was sent, otherwise false\n\nNotes:\n * This is a low level command, you typically should use a specific method for the operation you want to perform"
    },
    "Sets brightness for the specified zone": {
        "prefix": "hs.milight:zoneBrightness(zone, value) -> integer",
        "body": "hs.milight:${1:zone}Brightness(zone, ${2:value})",
        "description": "Sets brightness for the specified zone\n\nParameters:\n * zone - A number specifying which zone to operate on. 0 for all zones, 1-4 for zones one through four\n * value - A number containing the brightness level to set, between `hs.milight.minBrightness` and `hs.milight.maxBrightness`\n\nReturns:\n * A number containing the value that was sent to the WiFi bridge, or -1 if an error occurred"
    },
    "Sets RGB color for the specified zone": {
        "prefix": "hs.milight:zoneColor(zone, value) -> bool",
        "body": "hs.milight:${1:zone}Color(zone, ${2:value})",
        "description": "Sets RGB color for the specified zone\n\nParameters:\n * zone - A number specifying which zone to operate on. 0 for all zones, 1-4 for zones one through four\n * value - A number between 0 and 255 that represents a color\n\nReturns:\n * True if the command was sent correctly, otherwise false\n\nNotes:\n * The color value is not a normal RGB colour, but rather a lookup in an internal table in the light hardware. While any number between 0 and 255 is valid, there are some useful values worth knowing:\n  * 00 - Violet\n  * 16 - Royal Blue\n  * 32 - Baby Blue\n  * 48 - Aqua\n  * 64 - Mint Green\n  * 80 - Seafoam Green\n  * 96 - Green\n  * 112 - Lime Green\n  * 128 - Yellow\n  * 144 - Yellowy Orange\n  * 160 - Orange\n  * 176 - Red\n  * 194 - Pink\n  * 210 - Fuscia\n  * 226 - Lilac\n  * 240 - Lavendar"
    },
    "Turns off the specified zone": {
        "prefix": "hs.milight:zoneOff(zone) -> bool",
        "body": "hs.milight:${1:zone}Off(zone)",
        "description": "Turns off the specified zone\n\nParameters:\n * zone - A number specifying which zone to operate on. 0 for all zones, 1-4 for zones one through four\n\nReturns:\n * True if the command was sent correctly, otherwise false"
    },
    "Turns on the specified zone": {
        "prefix": "hs.milight:zoneOn(zone) -> bool",
        "body": "hs.milight:${1:zone}On(zone)",
        "description": "Turns on the specified zone\n\nParameters:\n * zone - A number specifying which zone to operate on. 0 for all zones, 1-4 for zones one through four\n\nReturns:\n * True if the command was sent correctly, otherwise false"
    },
    "Sets the specified zone to white": {
        "prefix": "hs.milight:zoneWhite(zone) -> bool",
        "body": "hs.milight:${1:zone}White(zone)",
        "description": "Sets the specified zone to white\n\nParameters:\n * zone - A number specifying which zone to operate on. 0 for all zones, 1-4 for zones one through four\n\nReturns:\n * True if the command was sent correctly, otherwise false"
    },
    "Applies a configuration to the currently open windows": {
        "prefix": "hs.mjomatic.go(cfg)",
        "body": "hs.mjomatic.go(${1:cfg})",
        "description": "Applies a configuration to the currently open windows\n\nParameters:\n * cfg - A table containing a series of strings, representing the desired window layout\n\nReturns:\n * None\n\nNotes:\n * An example use:\n\n~~~lua\nmjomatic.go({\n\"CCCCCCCCCCCCCiiiiiiiiiii      # <-- The windowgram, it defines the shapes and positions of windows\",\n\"CCCCCCCCCCCCCiiiiiiiiiii\",\n\"SSSSSSSSSSSSSiiiiiiiiiii\",\n\"SSSSSSSSSSSSSYYYYYYYYYYY\",\n\"SSSSSSSSSSSSSYYYYYYYYYYY\",\n\"\",\n\"C Google Chrome            # <-- window C has application():title() 'Google Chrome'\",\n\"i iTerm\",\n\"Y YoruFukurou\",\n\"S Sublime Text 2\"})\n~~~"
    },
    "Get or set the absolute co-ordinates of the mouse pointer": {
        "prefix": "hs.mouse.absolutePosition([point]) -> point",
        "body": "hs.mouse.absolutePosition(${1:[point]})",
        "description": "Get or set the absolute co-ordinates of the mouse pointer\n\nParameters:\n * An optional point table containing the absolute x and y co-ordinates to move the mouse pointer to\n\nReturns:\n * A point table containing the absolute x and y co-ordinates of the mouse pointer\n\nNotes:\n * If no parameters are supplied, the current position will be returned. If a point table parameter is supplied, the mouse pointer poisition will be set and the new co-ordinates returned"
    },
    "Gets the total number of mice connected to your system.": {
        "prefix": "hs.mouse.count([includeInternal]) -> number",
        "body": "hs.mouse.count(${1:[includeInternal]})",
        "description": "Gets the total number of mice connected to your system.\n\nParameters:\n * includeInternal - A boolean which sets whether or not you want to include internal Trackpad's in the count. Defaults to false.\n\nReturns:\n * The number of mice connected to your system\n\nNotes:\n * This function leverages code from [ManyMouse](http://icculus.org/manymouse/).\n * This function considers any mouse labelled as \"Apple Internal Keyboard / Trackpad\" to be an internal mouse."
    },
    "Gets the screen the mouse pointer is on": {
        "prefix": "hs.mouse.getCurrentScreen() -> screen or nil",
        "body": "hs.mouse.getCurrentScreen()",
        "description": "Gets the screen the mouse pointer is on\n\nParameters:\n * None\n\nReturns:\n * An `hs.screen` object that the mouse pointer is on, or nil if an error occurred"
    },
    "Gets the co-ordinates of the mouse pointer, relative to the screen it is on": {
        "prefix": "hs.mouse.getRelativePosition() -> point or nil",
        "body": "hs.mouse.getRelativePosition()",
        "description": "Gets the co-ordinates of the mouse pointer, relative to the screen it is on\n\nParameters:\n * None\n\nReturns:\n * A point-table containing the relative x and y co-ordinates of the mouse pointer, or nil if an error occured\n\nNotes:\n * The co-ordinates returned by this function are relative to the top left pixel of the screen the mouse is on (see `hs.mouse.getAbsolutePosition` if you need the location in the full desktop space)"
    },
    "Gets the names of any mice connected to the system.": {
        "prefix": "hs.mouse.names() -> table",
        "body": "hs.mouse.names()",
        "description": "Gets the names of any mice connected to the system.\n\nParameters:\n * None\n\nReturns:\n * A table containing strings of all the mice connected to the system.\n\nNotes:\n * This function leverages code from [ManyMouse](http://icculus.org/manymouse/)."
    },
    "Gets the system-wide direction of scolling": {
        "prefix": "hs.mouse.scrollDirection() -> string",
        "body": "hs.mouse.scrollDirection()",
        "description": "Gets the system-wide direction of scolling\n\nParameters:\n * None\n\nReturns:\n * A string, either \"natural\" or \"normal\""
    },
    "Sets the co-ordinates of the mouse pointer, relative to a screen": {
        "prefix": "hs.mouse.setRelativePosition(point[, screen])",
        "body": "hs.mouse.setRelativePosition(${1:point[}, ${2:screen]})",
        "description": "Sets the co-ordinates of the mouse pointer, relative to a screen\n\nParameters:\n * point - A point-table containing the relative x and y co-ordinates to move the mouse pointer to\n * screen - An optional `hs.screen` object. Defaults to the screen the mouse pointer is currently on\n\nReturns:\n * None"
    },
    "Gets/Sets the current system mouse tracking speed setting": {
        "prefix": "hs.mouse.trackingSpeed([speed]) -> number",
        "body": "hs.mouse.trackingSpeed(${1:[speed]})",
        "description": "Gets/Sets the current system mouse tracking speed setting\n\nParameters:\n * speed - An optional number containing the new tracking speed to set. If this is ommitted, the current setting is returned\n\nReturns:\n * A number indicating the current tracking speed setting for mice\n\nNotes:\n * This is represented in the System Preferences as the \"Tracking speed\" setting for mice\n * Note that not all values will work, they should map to the steps defined in the System Preferences app, which are:\n   * 0.0, 0.125, 0.5, 0.6875, 0.875, 1.0, 1.5, 2.0, 2.5, 3.0\n * Note that changes to this value will not be noticed immedaitely by macOS"
    },
    "Returns a list of the IPv4 and IPv6 addresses for the specified interfaces, or all interfaces if no arguments are given.": {
        "prefix": "hs.network.addresses([interface, ...]) -> table",
        "body": "hs.network.addresses(${1:[interface}, ${2:...]})",
        "description": "Returns a list of the IPv4 and IPv6 addresses for the specified interfaces, or all interfaces if no arguments are given.\n\nParameters:\n * interface, ... - The interface names to return the IP addresses for. It should be specified as one of the following:\n   * one or more interface names, separated by a comma\n   * if the first argument is a table, it is assumes to be a table containing a list of interfaces and this list is used instead, ignoring any additional arguments that may be provided\n   * if no arguments are specified, then the results of [hs.network.interfaces](#interfaces) is used.\n\nReturns:\n * A table containing a list of the IP addresses for the interfaces as determined by the arguments provided.\n\nNotes:\n * The order of the IP addresses returned is undefined.\n * If no arguments are provided, then this function returns the same results as `hs.host.addresses`, but does not block."
    },
    "Returns details about the specified interface or the primary interface if no interface is specified.": {
        "prefix": "hs.network.interfaceDetails([interface | favorIPv6]) -> table",
        "body": "hs.network.interfaceDetails(${1:[interface | favorIPv6]})",
        "description": "Returns details about the specified interface or the primary interface if no interface is specified.\n\nParameters:\n * interface - an optional string specifying the interface to retrieve details about.  Defaults to the primary interface if not specified.\n * favorIPv6 - an optional boolean specifying whether or not to prefer the primary IPv6 or the primary IPv4 interface if `interface` is not specified.  Defaults to false.\n\nReturns:\n * A table containing key-value pairs describing interface details.  Returns an empty table if no primary interface can be determined. Logs an error and returns nil if there was a problem retrieving this information.\n\nNotes:\n * When determining the primary interface, the `favorIPv6` flag only determines interface search order.  If you specify true for this flag, but no primary IPv6 interface exists (i.e. your DHCP server only provides an IPv4 address an IPv6 is limited to local only traffic), then the primary IPv4 interface will be used instead."
    },
    "Returns the user defined name for the specified interface or the primary interface if no interface is specified.": {
        "prefix": "hs.network.interfaceName([interface | favorIPv6]) -> string",
        "body": "hs.network.interfaceName(${1:[interface | favorIPv6]})",
        "description": "Returns the user defined name for the specified interface or the primary interface if no interface is specified.\n * interface - an optional string specifying the interface to retrieve the name for.  Defaults to the primary interface if not specified.\n * favorIPv6 - an optional boolean specifying whether or not to prefer the primary IPv6 or the primary IPv4 interface if `interface` is not specified.  Defaults to false.\n\nReturns:\n * A string containing the user defined name for the interface, if one exists, or false if the interface does not have a user defined name. Logs an error and returns nil if there was a problem retrieving this information.\n\nNotes:\n * Only interfaces which show up in the System Preferences Network panel will have a user defined name.\n\n * When determining the primary interface, the `favorIPv6` flag only determines interface search order.  If you specify true for this flag, but no primary IPv6 interface exists (i.e. your DHCP server only provides an IPv4 address an IPv6 is limited to local only traffic), then the primary IPv4 interface will be used instead."
    },
    "Returns a list of interfaces currently active for the system.": {
        "prefix": "hs.network.interfaces() -> table",
        "body": "hs.network.interfaces()",
        "description": "Returns a list of interfaces currently active for the system.\n\nParameters:\n * None\n\nReturns:\n * A table containing a list of the interfaces active for the system.  Logs an error and returns nil if there was a problem retrieving this information.\n\nNotes:\n * The names of the interfaces returned by this function correspond to the interface's BSD name, not the user defined name that shows up in the System Preferences's Network panel.\n * This function returns *all* interfaces, even ones used by the system that are not directly manageable by the user."
    },
    "Returns the names of the primary IPv4 and IPv6 interfaces.": {
        "prefix": "hs.network.primaryInterfaces() -> ipv4Interface, ipv6Interface",
        "body": "hs.network.primaryInterfaces()",
        "description": "Returns the names of the primary IPv4 and IPv6 interfaces.\n\nParameters:\n * None\n\nReturns:\n * The name of the primary IPv4 interface or false if there isn't one, and the name of the IPv6 interface or false if there isn't one. Logs an error and returns a single nil if there was a problem retrieving this information.\n\nNotes:\n * The IPv4 and IPv6 interface names are often, but not always, the same."
    },
    "Returns the name of the computeras specified in the Sharing Preferences, and its string encoding": {
        "prefix": "hs.network.configuration:computerName() -> name, encoding",
        "body": "hs.network.configuration:computerName()",
        "description": "Returns the name of the computeras specified in the Sharing Preferences, and its string encoding\n\nParameters:\n * None\n\nReturns:\n * name     - the computer name\n * encoding - the encoding type\n\nNotes:\n * You can also retrieve this information as key-value pairs with `hs.network.configuration:contents(\"Setup:/System\")`"
    },
    "Returns the name of the user currently logged into the system, including the users id and primary group id": {
        "prefix": "hs.network.configuration:consoleUser() -> name, uid, gid",
        "body": "hs.network.configuration:consoleUser()",
        "description": "Returns the name of the user currently logged into the system, including the users id and primary group id\n\nParameters:\n * None\n\nReturns:\n * name - the user name\n * uid  - the user ID for the user\n * gid  - the user's primary group ID\n\nNotes:\n * You can also retrieve this information as key-value pairs with `hs.network.configuration:contents(\"State:/Users/ConsoleUser\")`"
    },
    "Return the contents of the store for the specified keys or keys matching the specified pattern(s)": {
        "prefix": "hs.network.configuration:contents([keys], [pattern]) -> table",
        "body": "hs.network.configuration:contents(${1:[keys]}, ${2:[pattern]})",
        "description": "Return the contents of the store for the specified keys or keys matching the specified pattern(s)\n\nParameters:\n * keys    - a string or table of strings containing the keys or patterns of keys, if `pattern` is true.  Defaults to all keys.\n * pattern - a boolean indicating wether or not the string(s) provided are to be considered regular expression patterns (true) or literal strings to match (false).  Defaults to false.\n\nReturns:\n * a table of key-value pairs from the dynamic store which match the specified keys or key patterns.\n\nNotes:\n * if no parameters are provided, then all key-value pairs in the dynamic store are returned."
    },
    "Return the DHCP information for the specified service or the primary service if no parameter is specified.": {
        "prefix": "hs.network.configuration:dhcpInfo([serviceID]) -> table",
        "body": "hs.network.configuration:dhcpInfo(${1:[serviceID]})",
        "description": "Return the DHCP information for the specified service or the primary service if no parameter is specified.\n\nParameters:\n * serviceID - an optional string contining the service ID of the interface for which to return DHCP info.  If this parameter is not provided, then the default (primary) service is queried.\n\nReturns:\n * a table containing DHCP information including lease time and DHCP options\n\nNotes:\n * a list of possible Service ID's can be retrieved with `hs.network.configuration:contents(\"Setup:/Network/Global/IPv4\")`\n * generates an error if the service ID is invalid or was not assigned an IP address via DHCP."
    },
    "Returns the current local host name for the computer": {
        "prefix": "hs.network.configuration:hostname() -> name",
        "body": "hs.network.configuration:hostname()",
        "description": "Returns the current local host name for the computer\n\nParameters:\n * None\n\nReturns:\n * name - the local host name\n\nNotes:\n * You can also retrieve this information as key-value pairs with `hs.network.configuration:contents(\"Setup:/System\")`"
    },
    "Return the keys in the dynamic store which match the specified pattern": {
        "prefix": "hs.network.configuration:keys([keypattern]) -> table",
        "body": "hs.network.configuration:keys(${1:[keypattern]})",
        "description": "Return the keys in the dynamic store which match the specified pattern\n\nParameters:\n * keypattern - a regular expression specifying which keys to return (defaults to \".*\", or all keys)\n\nReturns:\n * a table of keys from the dynamic store."
    },
    "Returns the current location identifier": {
        "prefix": "hs.network.configuration:location() -> location",
        "body": "hs.network.configuration:location()",
        "description": "Returns the current location identifier\n\nParameters:\n * None\n\nReturns:\n * location - the UUID for the currently active network location\n\nNotes:\n * You can also retrieve this information as key-value pairs with `hs.network.configuration:contents(\"Setup:\")`\n * If you have different locations defined in the Network preferences panel, this can be used to determine the currently active location."
    },
    "Returns all configured locations": {
        "prefix": "hs.network.configuration:locations() -> table",
        "body": "hs.network.configuration:locations()",
        "description": "Returns all configured locations\n\nParameters:\n * None\n\nReturns:\n * a table of key-value pairs mapping location UUIDs to their names\n"
    },
    "Specify the key(s) or key pattern(s) to monitor for changes.": {
        "prefix": "hs.network.configuration:monitorKeys([keys], [pattern]) -> storeObject",
        "body": "hs.network.configuration:monitorKeys(${1:[keys]}, ${2:[pattern]})",
        "description": "Specify the key(s) or key pattern(s) to monitor for changes.\n\nParameters:\n * keys    - a string or table of strings containing the keys or patterns of keys, if `pattern` is true.  Defaults to all keys.\n * pattern - a boolean indicating wether or not the string(s) provided are to be considered regular expression patterns (true) or literal strings to match (false).  Defaults to false.\n\nReturns:\n * the store Object\n\nNotes:\n * if no parameters are provided, then all key-value pairs in the dynamic store are monitored for changes."
    },
    "Opens a session to the dynamic store maintained by the System Configuration server.": {
        "prefix": "hs.network.configuration.open() -> storeObject",
        "body": "hs.network.configuration.open()",
        "description": "Opens a session to the dynamic store maintained by the System Configuration server.\n\nParameters:\n * None\n\nReturns:\n * the storeObject"
    },
    "Returns information about the currently active proxies, if any": {
        "prefix": "hs.network.configuration:proxies() -> table",
        "body": "hs.network.configuration:proxies()",
        "description": "Returns information about the currently active proxies, if any\n\nParameters:\n * None\n\nReturns:\n * a table of key-value pairs describing the current proxies in effect, both globally, and scoped to specific interfaces.\n\nNotes:\n * You can also retrieve this information as key-value pairs with `hs.network.configuration:contents(\"State:/Network/Global/Proxies\")`"
    },
    "Set or remove the callback function for a store object": {
        "prefix": "hs.network.configuration:setCallback(function | nil) -> storeObject",
        "body": "hs.network.configuration:setCallback(${1:function | nil})",
        "description": "Set or remove the callback function for a store object\n\nParameters:\n * a function or nil to set or remove the store object callback function\n\nReturns:\n * the store object\n\nNotes:\n * The callback function will be invoked each time a monitored key changes value and the callback function should accept two parameters: the storeObject itself, and an array of the keys which contain values that have changed.\n * This method just sets the callback function.  You specify which keys to watch with [hs.network.configuration:monitorKeys](#monitorKeys) and start or stop the watcher with [hs.network.configuration:start](#start) or [hs.network.configuartion:stop](#stop)"
    },
    "Switches to a new location": {
        "prefix": "hs.network.configuration:setLocation(location) -> boolean",
        "body": "hs.network.configuration:setLocation(${1:location})",
        "description": "Switches to a new location\n\nParameters:\n * location - string containing name or UUID of new location\n\nReturns:\n * bool - true if the location was successfully changed, false if there was an error"
    },
    "Starts watching the store object for changes to the monitored keys and invokes the callback function (if any) when a change occurs.": {
        "prefix": "hs.network.configuration:start() -> storeObject",
        "body": "hs.network.configuration:start()",
        "description": "Starts watching the store object for changes to the monitored keys and invokes the callback function (if any) when a change occurs.\n\nParameters:\n * None\n\nReturns:\n * the store object\n\nNotes:\n * The callback function should be specified with [hs.network.configuration:setCallback](#setCallback) and the keys to monitor should be specified with [hs.network.configuration:monitorKeys](#monitorKeys)."
    },
    "Stops watching the store object for changes.": {
        "prefix": "hs.network.configuration:stop() -> storeObject",
        "body": "hs.network.configuration:stop()",
        "description": "Stops watching the store object for changes.\n\nParameters:\n * None\n\nReturns:\n * the store object"
    },
    "Get IP addresses for the hostname specified.": {
        "prefix": "hs.network.host.addressesForHostname(name[, fn]) -> table | hostObject",
        "body": "hs.network.host.addressesForHostname(${1:name[}, ${2:fn]})",
        "description": "Get IP addresses for the hostname specified.\n\nParameters:\n * name - the hostname to lookup IP addresses for\n * fn   - an optional callback function which, when provided, will perform the address resolution in an asynchronous, non-blocking manner.\n\nReturns:\n * If this function is called without a callback function, returns a table containing the IP addresses for the specified name.  If a callback function is specified, then a host object is returned.\n\nNotes:\n * If no callback function is provided, the resolution occurs in a blocking manner which may be noticeable when network access is slow or erratic.\n * If a callback function is provided, this function acts as a constructor, returning a host object and the callback function will be invoked when resolution is complete.  The callback function should take two parameters: the string \"addresses\", indicating that an address resolution occurred, and a table containing the IP addresses identified.\n * Generates an error if network access is currently disabled or the hostname is invalid."
    },
    "Cancels an in-progress asynchronous host resolution.": {
        "prefix": "hs.network.host:cancel() -> hostObject",
        "body": "hs.network.host:cancel()",
        "description": "Cancels an in-progress asynchronous host resolution.\n\nParameters:\n * None\n\nReturns:\n * the hostObject\n\nNotes:\n * This method has no effect if the resolution has already completed."
    },
    "Get hostnames for the IP address specified.": {
        "prefix": "hs.network.host.hostnamesForAddress(address[, fn]) -> table | hostObject",
        "body": "hs.network.host.hostnamesForAddress(${1:address[}, ${2:fn]})",
        "description": "Get hostnames for the IP address specified.\n\nParameters:\n * address - a string or number representing an IPv4 or IPv6 network address to lookup hostnames for.  If the argument is a number, it is treated as the 32 bit numerical representation of an IPv4 address.\n * fn      - an optional callback function which, when provided, will perform the hostname resolution in an asynchronous, non-blocking manner.\n\nReturns:\n * If this function is called without a callback function, returns a table containing the hostnames for the specified address.  If a callback function is specified, then a host object is returned.\n\nNotes:\n * If no callback function is provided, the resolution occurs in a blocking manner which may be noticeable when network access is slow or erratic.\n * If a callback function is provided, this function acts as a constructor, returning a host object and the callback function will be invoked when resolution is complete.  The callback function should take two parameters: the string \"names\", indicating that hostname resolution occurred, and a table containing the hostnames identified.\n * Generates an error if network access is currently disabled or the IP address is invalid."
    },
    "Returns whether or not resolution is still in progress for an asynchronous query.": {
        "prefix": "hs.network.host:isRunning() -> boolean",
        "body": "hs.network.host:isRunning()",
        "description": "Returns whether or not resolution is still in progress for an asynchronous query.\n\nParameters:\n * None\n\nReturns:\n * true, if resolution is still in progress, or false if resolution has already completed."
    },
    "Get the reachability status for the IP address specified.": {
        "prefix": "hs.network.host.reachabilityForAddress(address[, fn]) -> integer | hostObject",
        "body": "hs.network.host.reachabilityForAddress(${1:address[}, ${2:fn]})",
        "description": "Get the reachability status for the IP address specified.\n\nParameters:\n * address - a string or number representing an IPv4 or IPv6 network address to check the reachability for.  If the argument is a number, it is treated as the 32 bit numerical representation of an IPv4 address.\n * fn      - an optional callback function which, when provided, will determine the address reachability in an asynchronous, non-blocking manner.\n\nReturns:\n * If this function is called without a callback function, returns the numeric representation of the address reachability status.  If a callback function is specified, then a host object is returned.\n\nNotes:\n * If no callback function is provided, the resolution occurs in a blocking manner which may be noticeable when network access is slow or erratic.\n * If a callback function is provided, this function acts as a constructor, returning a host object and the callback function will be invoked when resolution is complete.  The callback function should take two parameters: the string \"reachability\", indicating that reachability was determined, and the numeric representation of the address reachability status.\n * Generates an error if network access is currently disabled or the IP address is invalid.\n * The numeric representation is made up from a combination of the flags defined in `hs.network.reachability.flags`.\n * Performs the same reachability test as `hs.network.reachability.forAddress`."
    },
    "Get the reachability status for the IP address specified._1": {
        "prefix": "hs.network.host.reachabilityForHostname(name[, fn]) -> integer | hostObject",
        "body": "hs.network.host.reachabilityForHostname(${1:name[}, ${2:fn]})",
        "description": "Get the reachability status for the IP address specified.\n\nParameters:\n * name - the hostname to check the reachability for.  If the argument is a number, it is treated as the 32 bit numerical representation of an IPv4 address.\n * fn   - an optional callback function which, when provided, will determine the address reachability in an asynchronous, non-blocking manner.\n\nReturns:\n * If this function is called without a callback function, returns the numeric representation of the hostname reachability status.  If a callback function is specified, then a host object is returned.\n\nNotes:\n * If no callback function is provided, the resolution occurs in a blocking manner which may be noticeable when network access is slow or erratic.\n * If a callback function is provided, this function acts as a constructor, returning a host object and the callback function will be invoked when resolution is complete.  The callback function should take two parameters: the string \"reachability\", indicating that reachability was determined, and the numeric representation of the hostname reachability status.\n * Generates an error if network access is currently disabled or the IP address is invalid.\n * The numeric representation is made up from a combination of the flags defined in `hs.network.reachability.flags`.\n * Performs the same reachability test as `hs.network.reachability.forHostName`."
    },
    "Returns a string containing the resolved IPv4 or IPv6 address this pingObject is sending echo requests to.": {
        "prefix": "hs.network.ping:address() -> string",
        "body": "hs.network.ping:address()",
        "description": "Returns a string containing the resolved IPv4 or IPv6 address this pingObject is sending echo requests to.\n\nParameters:\n * None\n\nReturns:\n * A string containing the IPv4 or IPv6 address this pingObject is sending echo requests to or \"<unresolved address>\" if the address cannot be resolved."
    },
    "Cancels an in progress ping process, terminating it immediately": {
        "prefix": "hs.network.ping:cancel() -> none",
        "body": "hs.network.ping:cancel()",
        "description": "Cancels an in progress ping process, terminating it immediately\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * the `didFinish` message will be sent to the callback function as its final message."
    },
    "Get or set the number of ICMP Echo Requests that will be sent by the ping process": {
        "prefix": "hs.network.ping:count([count]) -> integer | pingObject | nil",
        "body": "hs.network.ping:count(${1:[count]})",
        "description": "Get or set the number of ICMP Echo Requests that will be sent by the ping process\n\nParameters:\n * `count` - an optional integer specifying the total number of echo requests that the ping process should send. If specified, this number must be greater than the number of requests already sent.\n\nReturns:\n * if no argument is specified, returns the current number of echo requests the ping process will send; if an argument is specified and the ping process has not completed, returns the pingObject; if the ping process has already completed, then this method returns nil."
    },
    "Returns whether or not the ping process is currently paused.": {
        "prefix": "hs.network.ping:isPaused() -> boolean",
        "body": "hs.network.ping:isPaused()",
        "description": "Returns whether or not the ping process is currently paused.\n\nParameters:\n * None\n\nReturns:\n * A boolean indicating if the ping process is paused (true) or not (false)"
    },
    "Returns whether or not the ping process is currently active.": {
        "prefix": "hs.network.ping:isRunning() -> boolean",
        "body": "hs.network.ping:isRunning()",
        "description": "Returns whether or not the ping process is currently active.\n\nParameters:\n * None\n\nReturns:\n * A boolean indicating if the ping process is active (true) or not (false)\n\nNotes:\n * This method will return false only if the ping process has finished sending all echo requests or if it has been cancelled with [hs.network.ping:cancel](#cancel).  To determine if the process is currently sending out echo requests, see [hs.network.ping:isPaused](#isPaused)."
    },
    "Returns a table containing information about the ICMP Echo packets sent by this pingObject.": {
        "prefix": "hs.network.ping:packets([sequenceNumber]) -> table",
        "body": "hs.network.ping:packets(${1:[sequenceNumber]})",
        "description": "Returns a table containing information about the ICMP Echo packets sent by this pingObject.\n\nParameters:\n * `sequenceNumber` - an optional integer specifying the sequence number of the ICMP Echo packet to return information about.\n\nReturns:\n * If `sequenceNumber` is specified, returns a table with key-value pairs containing information about the specific ICMP Echo packet with that sequence number, or an empty table if no packet with that sequence number has been sent yet. If no sequence number is specified, returns an array table of all ICMP Echo packets this object has sent.\n\nNotes:\n * Sequence numbers start at 0 while Lua array tables are indexed starting at 1. If you do not specify a `sequenceNumber` to this method, index 1 of the array table returned will contain a table describing the ICMP Echo packet with sequence number 0, index 2 will describe the ICMP Echo packet with sequence number 1, etc.\n\n * An ICMP Echo packet table will have the following key-value pairs:\n   * `sent`           - a number specifying the time at which the echo request for this packet was sent. This number is the number of seconds since January 1, 1970 at midnight, GMT, and is a floating point number, so you should use `math.floor` on this number before using it as an argument to Lua's `os.date` function.\n   * `recv`           - a number specifying the time at which the echo reply for this packet was received. This number is the number of seconds since January 1, 1970 at midnight, GMT, and is a floating point number, so you should use `math.floor` on this number before using it as an argument to Lua's `os.date` function.\n   * `icmp`           - a table provided by the `hs.network.ping.echoRequest` object which contains the details about the specific ICMP packet this entry corresponds to. It will contain the following keys:\n     * `checksum`       - The ICMP packet checksum used to ensure data integrity.\n     * `code`           - ICMP Control Message Code. Should always be 0.\n     * `identifier`     - The ICMP Identifier generated internally for matching request and reply packets.\n     * `payload`        - A string containing the ICMP payload for this packet. This has been constructed to cause the ICMP packet to be exactly 64 bytes to match the convention for ICMP Echo Requests.\n     * `sequenceNumber` - The ICMP Sequence Number for this packet.\n     * `type`           - ICMP Control Message Type. For ICMPv4, this will be 0 if a reply has been received or 8 no reply has been received yet. For ICMPv6, this will be 129 if a reply has been received or 128 if no reply has been received yet.\n     * `_raw`           - A string containing the ICMP packet as raw data."
    },
    "Pause an in progress ping process.": {
        "prefix": "hs.network.ping:pause() -> pingObject | nil",
        "body": "hs.network.ping:pause()",
        "description": "Pause an in progress ping process.\n\nParameters:\n * None\n\nReturns:\n * if the ping process is currently active, returns the pingObject; if the process has already completed, returns nil."
    },
    "Test server availability by pinging it with ICMP Echo Requests.": {
        "prefix": "hs.network.ping.ping(server, [count], [interval], [timeout], [class], [fn]) -> pingObject",
        "body": "hs.network.ping.ping(${1:server}, ${2:[count]}, ${3:[interval]}, ${4:[timeout]}, ${5:[class]}, ${6:[fn]})",
        "description": "Test server availability by pinging it with ICMP Echo Requests.\n\nParameters:\n * `server`   - a string containing the hostname or ip address of the server to test. Both IPv4 and IPv6 addresses are supported.\n * `count`    - an optional integer, default 5, specifying the number of ICMP Echo Requests to send to the server.\n * `interval` - an optional number, default 1.0, in seconds specifying the delay between the sending of each echo request. To set this parameter, you must supply `count` as well.\n * `timeout`  - an optional number, default 2.0, in seconds specifying how long before an echo reply is considered to have timed-out. To set this parameter, you must supply `count` and `interval` as well.\n * `class`    - an optional string, default \"any\", specifying whether IPv4 or IPv6 should be used to send the ICMP packets. The string must be one of the following:\n   * `any`  - uses the IP version which corresponds to the first address the `server` resolves to\n   * `IPv4` - use IPv4; if `server` cannot resolve to an IPv4 address, or if IPv4 traffic is not supported on the network, the ping will fail with an error.\n   * `IPv6` - use IPv6; if `server` cannot resolve to an IPv6 address, or if IPv6 traffic is not supported on the network, the ping will fail with an error.\n * `fn`       - the callback function which receives update messages for the ping process. See the Notes for details regarding the callback function.\n\nReturns:\n * a pingObject\n\nNotes:\n * For convenience, you can call this constructor as `hs.network.ping(server, ...)`\n * the full ping process will take at most `count` * `interval` + `timeout` seconds from `didStart` to `didFinish`.\n\n * the default callback function, if `fn` is not specified, prints the results of each echo reply as they are received to the Hammerspoon console and a summary once completed. The output should be familiar to anyone who has used `ping` from the command line.\n\n * If you provide your own callback function, it should expect between 2 and 4 arguments and return none. The possible arguments which are sent will be one of the following:\n\n   * \"didStart\" - indicates that address resolution has completed and the ping will begin sending ICMP Echo Requests.\n     * `object`  - the ping object the callback is for\n     * `message` - the message to the callback, in this case \"didStart\"\n\n   * \"didFail\" - indicates that the ping process has failed, most likely due to a failure in address resolution or because the network connection has dropped.\n     * `object`  - the ping object the callback is for\n     * `message` - the message to the callback, in this case \"didFail\"\n     * `error`   - a string containing the error message that has occurred\n\n   * \"sendPacketFailed\" - indicates that a specific ICMP Echo Request has failed for some reason.\n     * `object`         - the ping object the callback is for\n     * `message`        - the message to the callback, in this case \"sendPacketFailed\"\n     * `sequenceNumber` - the sequence number of the ICMP packet which has failed to send\n     * `error`          - a string containing the error message that has occurred\n\n   * \"receivedPacket\" - indicates that an ICMP Echo Request has received the expected ICMP Echo Reply\n     * `object`         - the ping object the callback is for\n     * `message`        - the message to the callback, in this case \"receivedPacket\"\n     * `sequenceNumber` - the sequence number of the ICMP packet received\n\n   * \"didFinish\" - indicates that the ping has finished sending all ICMP Echo Requests or has been cancelled\n     * `object`  - the ping object the callback is for\n     * `message` - the message to the callback, in this case \"didFinish\""
    },
    "Resume an in progress ping process, if it has been paused.": {
        "prefix": "hs.network.ping:resume() -> pingObject | nil",
        "body": "hs.network.ping:resume()",
        "description": "Resume an in progress ping process, if it has been paused.\n\nParameters:\n * None\n\nReturns:\n * if the ping process is currently active, returns the pingObject; if the process has already completed, returns nil."
    },
    "Returns the number of ICMP Echo Requests which have been sent.": {
        "prefix": "hs.network.ping:sent() -> integer",
        "body": "hs.network.ping:sent()",
        "description": "Returns the number of ICMP Echo Requests which have been sent.\n\nParameters:\n * None\n\nReturns:\n * The number of echo requests which have been sent so far."
    },
    "Returns the hostname or ip address string given to the [hs.network.ping.ping](#ping) constructor.": {
        "prefix": "hs.network.ping:server() -> string",
        "body": "hs.network.ping:server()",
        "description": "Returns the hostname or ip address string given to the [hs.network.ping.ping](#ping) constructor.\n\nParameters:\n * None\n\nReturns:\n * A string matching the hostname or ip address given to the [hs.network.ping.ping](#ping) constructor for this object."
    },
    "Set or remoce the callback function for the pingObject.": {
        "prefix": "hs.network.ping:setCallback(fn | nil) -> pingObject",
        "body": "hs.network.ping:setCallback(${1:fn | nil})",
        "description": "Set or remoce the callback function for the pingObject.\n\nParameters:\n * `fn` - the function to set as the callback, or nil if you wish use the default callback.\n\nReturns:\n * the pingObject\n\nNotes:\n * Because the ping process begins immediately upon creation with the [hs.network.ping.ping](#ping) constructor, it is preferable to assign the callback with the constructor itself.\n * This method is provided as a means of changing the callback based on other events (a change in the current network or location, perhaps.)\n * If you truly wish to create a pingObject with no callback, you will need to do something like `hs.network.ping.ping(...):setCallback(function() end)`."
    },
    "Returns a string containing summary information about the ping process.": {
        "prefix": "hs.network.ping:summary() -> string",
        "body": "hs.network.ping:summary()",
        "description": "Returns a string containing summary information about the ping process.\n\nParameters:\n * None\n\nReturns:\n * a summary string for the current state of the ping process\n\nNotes:\n * The summary string will look similar to the following:\n~~~\n--- hostname ping statistics \n5 packets transmitted, 5 packets received, 0.0 packet loss\nround-trip min/avg/max = 2.282/4.133/4.926 ms\n~~~\n * The numer of packets received will match the number that has currently been sent, not necessarily the value returned by [hs.network.ping:count](#count)."
    },
    "Get or set the address family the echoRequestObject should communicate with.": {
        "prefix": "hs.network.ping.echoRequest:acceptAddressFamily([family]) -> echoRequestObject | current value",
        "body": "hs.network.ping.echoRequest:acceptAddressFamily(${1:[family]})",
        "description": "Get or set the address family the echoRequestObject should communicate with.\n\nParameters:\n * `family` - an optional string, default \"any\", which specifies the address family used by this object.  Valid values are \"any\", \"IPv4\", and \"IPv6\".\n\nReturns:\n * if an argument is provided, returns the echoRequestObject, otherwise returns the current value.\n\nNotes:\n * Setting this value to \"IPv6\" or \"IPv4\" will cause the echoRequestObject to attempt to resolve the server's name into an IPv6 address or an IPv4 address and communicate via ICMPv6 or ICMP(v4) when the [hs.network.ping.echoRequest:start](#start) method is invoked.  A callback with the message \"didFail\" will occur if the server could not be resolved to an address in the specified family.\n * If this value is set to \"any\", then the first address which is discovered for the server's name will determine whether ICMPv6 or ICMP(v4) is used, based upon the family of the address.\n\n * Setting a value with this method will have no immediate effect on an echoRequestObject which has already been started with [hs.network.ping.echoRequest:start](#start). You must first stop and then restart the object for any change to have an effect."
    },
    "Creates a new ICMP Echo Request object for the server specified.": {
        "prefix": "hs.network.ping.echoRequest.echoRequest(server) -> echoRequestObject",
        "body": "hs.network.ping.echoRequest.echoRequest(${1:server})",
        "description": "Creates a new ICMP Echo Request object for the server specified.\n\nParameters:\n * `server` - a string containing the hostname or ip address of the server to communicate with. Both IPv4 and IPv6 style addresses are supported.\n\nReturns:\n * an echoRequest object\n\nNotes:\n * This constructor returns a lower-level object than the `hs.network.ping.ping` constructor and is more difficult to use. It is recommended that you use this constructor only if `hs.network.ping.ping` is not sufficient for your needs.\n\n * For convenience, you can call this constructor as `hs.network.ping.echoRequest(server)`"
    },
    "Returns a string representation for the server's IP address, or a boolean if address resolution has not completed yet.": {
        "prefix": "hs.network.ping.echoRequest:hostAddress() -> string | false | nil",
        "body": "hs.network.ping.echoRequest:hostAddress()",
        "description": "Returns a string representation for the server's IP address, or a boolean if address resolution has not completed yet.\n\nParameters:\n * None\n\nReturns:\n * If the object has been started and address resolution has completed, then the string representation of the server's IP address is returned.\n * If the object has been started, but resolution is still pending, returns a boolean value of false.\n * If the object has not been started, returns nil."
    },
    "Returns the host address family currently in use by this echoRequestObject.": {
        "prefix": "hs.network.ping.echoRequest:hostAddressFamily() -> string",
        "body": "hs.network.ping.echoRequest:hostAddressFamily()",
        "description": "Returns the host address family currently in use by this echoRequestObject.\n\nParameters:\n * None\n\nReturns:\n * a string indicating the IP address family currently used by this echoRequestObject.  It will be one of the following values:\n   * \"IPv4\"       - indicates that ICMP(v4) packets are being sent and listened for.\n   * \"IPv6\"       - indicates that ICMPv6 packets are being sent and listened for.\n   * \"unresolved\" - indicates that the echoRequestObject has not been started or that address resolution is still in progress."
    },
    "Returns the name of the target host as provided to the echoRequestObject's constructor": {
        "prefix": "hs.network.ping.echoRequest:hostName() -> string",
        "body": "hs.network.ping.echoRequest:hostName()",
        "description": "Returns the name of the target host as provided to the echoRequestObject's constructor\n\nParameters:\n * None\n\nReturns:\n * a string containing the hostname as specified when the object was created."
    },
    "Returns the identifier number for the echoRequestObject.": {
        "prefix": "hs.network.ping.echoRequest:identifier() -> integer",
        "body": "hs.network.ping.echoRequest:identifier()",
        "description": "Returns the identifier number for the echoRequestObject.\n\nParameters:\n * None\n\nReturns:\n * an integer specifying the identifier which is embedded in the ICMP packets this object sends.\n\nNotes:\n * ICMP Echo Replies which include this identifier will generate a \"receivedPacket\" message to the object callback, while replies which include a different identifier will generate a \"receivedUnexpectedPacket\" message."
    },
    "Returns a boolean indicating whether or not this echoRequestObject is currently listening for ICMP Echo Replies.": {
        "prefix": "hs.network.ping.echoRequest:isRunning() -> boolean",
        "body": "hs.network.ping.echoRequest:isRunning()",
        "description": "Returns a boolean indicating whether or not this echoRequestObject is currently listening for ICMP Echo Replies.\n\nParameters:\n * None\n\nReturns:\n * true if the object is currently listening for ICMP Echo Replies, or false if it is not."
    },
    "The sequence number that will be used for the next ICMP packet sent by this object.": {
        "prefix": "hs.network.ping.echoRequest:nextSequenceNumber() -> integer",
        "body": "hs.network.ping.echoRequest:nextSequenceNumber()",
        "description": "The sequence number that will be used for the next ICMP packet sent by this object.\n\nParameters:\n * None\n\nReturns:\n * an integer specifying the sequence number that will be embedded in the next ICMP message sent by this object when [hs.network.ping.echoRequest:sendPayload](#sendPayload) is invoked.\n\nNotes:\n * ICMP Echo Replies which are expected by this object should always be less than this number, with the caveat that this number is a 16-bit integer which will wrap around to 0 after sending a packet with the sequence number 65535.\n * Because of this wrap around effect, this module will generate a \"receivedPacket\" message to the object callback whenever the received packet has a sequence number that is within the last 120 sequence numbers we've sent and a \"receivedUnexpectedPacket\" otherwise.\n   * Per the comments in Apple's SimplePing.m file: Why 120?  Well, if we send one ping per second, 120 is 2 minutes, which is the standard \"max time a packet can bounce around the Internet\" value."
    },
    "Get or set whether or not the callback should receive all unexpected packets or only those which carry our identifier.": {
        "prefix": "hs.network.ping.echoRequest:seeAllUnexpectedPackets([state]) -> boolean | echoRequestObject",
        "body": "hs.network.ping.echoRequest:seeAllUnexpectedPackets(${1:[state]})",
        "description": "Get or set whether or not the callback should receive all unexpected packets or only those which carry our identifier.\n\nParameters:\n * `state` - an optional boolean, default false, specifying whether or not all unexpected packets or only those which carry our identifier should generate a \"receivedUnexpectedPacket\" callback message.\n\nReturns:\n * if an argument is provided, returns the echoRequestObject; otherwise returns the current value\n\nNotes:\n * The nature of ICMP packet reception is such that all listeners receive all ICMP packets, even those which belong to another process or echoRequestObject.\n   * By default, a valid packet (i.e. with a valid checksum) which does not contain our identifier is ignored since it was not intended for our receiver.  Only corrupt or packets with our identifier but that were otherwise unexpected will generate a \"receivedUnexpectedPacket\" callback message.\n   * This method optionally allows the echoRequestObject to receive *all* incoming packets, even ones which are expected by another process or echoRequestObject.\n * If you wish to examine ICMPv6 router advertisement and neighbor discovery packets, you should set this property to true. Note that this module does not provide the necessary tools to decode these packets at present, so you will have to decode them yourself if you wish to examine their contents."
    },
    "Sends a single ICMP Echo Request packet.": {
        "prefix": "hs.network.ping.echoRequest:sendPayload([payload]) -> echoRequestObject | false | nil",
        "body": "hs.network.ping.echoRequest:sendPayload(${1:[payload]})",
        "description": "Sends a single ICMP Echo Request packet.\n\nParameters:\n * `payload` - an optional string containing the data to include in the ICMP Echo Request as the packet payload.\n\nReturns:\n * If the object has been started and address resolution has completed, then the ICMP Echo Packet is sent and this method returns the echoRequestObject\n * If the object has been started, but resolution is still pending, the packet is not sent and this method returns a boolean value of false.\n * If the object has not been started, the packet is not sent and this method returns nil.\n\nNotes:\n * By convention, unless you are trying to test for specific network fragmentation or congestion problems, ICMP Echo Requests are generally 64 bytes in length (this includes the 8 byte header, giving 56 bytes of payload data).  If you do not specify a payload, a default payload which will result in a packet size of 64 bytes is constructed."
    },
    "Set or remove the object callback function": {
        "prefix": "hs.network.ping.echoRequest:setCallback(fn | nil) -> echoRequestObject",
        "body": "hs.network.ping.echoRequest:setCallback(${1:fn | nil})",
        "description": "Set or remove the object callback function\n\nParameters:\n * `fn` - a function to set as the callback function for this object, or nil if you wish to remove any existing callback function.\n\nReturns:\n * the echoRequestObject\n\nNotes:\n * The callback function should expect between 3 and 5 arguments and return none. The possible arguments which are sent will be one of the following:\n\n   * \"didStart\" - indicates that the object has resolved the address of the server and is ready to begin sending and receiving ICMP Echo packets.\n     * `object`  - the echoRequestObject itself\n     * `message` - the message to the callback, in this case \"didStart\"\n     * `address` - a string representation of the IPv4 or IPv6 address of the server specified to the constructor.\n\n   * \"didFail\" - indicates that the object has failed, either because the address could not be resolved or a network error has occurred.\n     * `object`  - the echoRequestObject itself\n     * `message` - the message to the callback, in this case \"didFail\"\n     * `error`   - a string describing the error that occurred.\n   * Notes:\n     * When this message is received, you do not need to call [hs.network.ping.echoRequest:stop](#stop) -- the object will already have been stopped.\n\n   * \"sendPacket\" - indicates that the object has sent an ICMP Echo Request packet.\n     * `object`  - the echoRequestObject itself\n     * `message` - the message to the callback, in this case \"sendPacket\"\n     * `icmp`    - an ICMP packet table representing the packet which has been sent as described in the header of this module's documentation.\n     * `seq`     - the sequence number for this packet. Sequence numbers always start at 0 and increase by 1 every time the [hs.network.ping.echoRequest:sendPayload](#sendPayload) method is called.\n\n   * \"sendPacketFailed\" - indicates that the object failed to send the ICMP Echo Request packet.\n     * `object`  - the echoRequestObject itself\n     * `message` - the message to the callback, in this case \"sendPacketFailed\"\n     * `icmp`    - an ICMP packet table representing the packet which was to be sent.\n     * `seq`     - the sequence number for this packet.\n     * `error`   - a string describing the error that occurred.\n   * Notes:\n     * Unlike \"didFail\", the echoRequestObject is not stopped when this message occurs; you can try to send another payload if you wish without restarting the object first.\n\n   * \"receivedPacket\" - indicates that an expected ICMP Echo Reply packet has been received by the object.\n     * `object`  - the echoRequestObject itself\n     * `message` - the message to the callback, in this case \"receivedPacket\"\n     * `icmp`    - an ICMP packet table representing the packet received.\n     * `seq`     - the sequence number for this packet.\n\n   * \"receivedUnexpectedPacket\" - indicates that an unexpected ICMP packet was received\n     * `object`  - the echoRequestObject itself\n     * `message` - the message to the callback, in this case \"receivedUnexpectedPacket\"\n     * `icmp`    - an ICMP packet table representing the packet received.\n   * Notes:\n     * This message can occur for a variety of reasons, the most common being:\n       * the ICMP packet is corrupt or truncated and cannot be parsed\n       * the ICMP Identifier does not match ours and the sequence number is not one we have sent\n       * the ICMP type does not match an ICMP Echo Reply\n       * When using IPv6, this is especially common because IPv6 uses ICMP for network management functions like Router Advertisement and Neighbor Discovery.\n     * In general, it is reasonably safe to ignore these messages, unless you are having problems receiving anything else, in which case it could indicate problems on your network that need addressing."
    },
    "Start the echoRequestObject by resolving the server's address and start listening for ICMP Echo Reply packets.": {
        "prefix": "hs.network.ping.echoRequest:start() -> echoRequestObject",
        "body": "hs.network.ping.echoRequest:start()",
        "description": "Start the echoRequestObject by resolving the server's address and start listening for ICMP Echo Reply packets.\n\nParameters:\n * None\n\nReturns:\n * the echoRequestObject"
    },
    "Stop listening for ICMP Echo Reply packets with this object.": {
        "prefix": "hs.network.ping.echoRequest:stop() -> echoRequestObject",
        "body": "hs.network.ping.echoRequest:stop()",
        "description": "Stop listening for ICMP Echo Reply packets with this object.\n\nParameters:\n * None\n\nReturns:\n * the echoRequestObject"
    },
    "A table containing the numeric value for the possible flags returned by the [hs.network.reachability:status](#status) method or in the `flags` parameter of the callback function.": {
        "prefix": "hs.network.reachability.flags[]",
        "body": "hs.network.reachability.flags",
        "description": "A table containing the numeric value for the possible flags returned by the [hs.network.reachability:status](#status) method or in the `flags` parameter of the callback function.\n\n* transientConnection  - indicates if the destination is reachable through a transient connection\n* reachable            - indicates if the destination is reachable\n* connectionRequired   - indicates that a connection of some sort is required for the destination to be reachable\n* connectionOnTraffic  - indicates if the destination requires a connection which will be initiated when traffic to the destination is present\n* interventionRequired - indicates if the destination requires a connection which will require user activity to initiate\n* connectionOnDemand   - indicates if the destination requires a connection which will be initiated on demand through the CFSocketStream interface\n* isLocalAddress       - indicates if the destination is actually a local address\n* isDirect             - indicates if the destination is directly connected"
    },
    "Returns a reachability object for the specified network address.": {
        "prefix": "hs.network.reachability.forAddress(address) -> reachabilityObject",
        "body": "hs.network.reachability.forAddress(${1:address})",
        "description": "Returns a reachability object for the specified network address.\n\nParameters:\n * address - a string or number representing an IPv4 or IPv6 network address to get or track reachability status for.  If the argument is a number, it is treated as the 32 bit numerical representation of an IPv4 address.\n\nReturns:\n * a reachability object for the specified network address.\n\nNotes:\n * this object will reflect reachability status for any interface available on the computer.  To check for reachability from a specific interface, use [hs.network.reachability.forAddressPair](#addressPair)."
    },
    "Returns a reachability object for the specified network address from the specified localAddress.": {
        "prefix": "hs.network.reachability.forAddressPair(localAddress, remoteAddress) -> reachabilityObject",
        "body": "hs.network.reachability.forAddressPair(${1:localAddress}, ${2:remoteAddress})",
        "description": "Returns a reachability object for the specified network address from the specified localAddress.\n\nParameters:\n * localAddress - a string or number representing a local IPv4 or IPv6 network address. If the address specified is not present on the computer, the remote address will be unreachable.\n * remoteAddress - a string or number representing an IPv4 or IPv6 network address to get or track reachability status for.  If the argument is a number, it is treated as the 32 bit numerical representation of an IPv4 address.\n\nReturns:\n * a reachability object for the specified network address.\n\nNotes:\n * this object will reflect reachability status for a specific interface on the computer.  To check for reachability from any interface, use [hs.network.reachability.forAddress](#address).\n * this constructor can be used to test for a specific local network."
    },
    "Returns a reachability object for the specified host.": {
        "prefix": "hs.network.reachability.forHostName(hostName) -> reachabilityObject",
        "body": "hs.network.reachability.forHostName(${1:hostName})",
        "description": "Returns a reachability object for the specified host.\n\nParameters:\n * hostName - a string containing the hostname of a machine to check or track the reachability status for.\n\nReturns:\n * a reachability object for the specified host.\n\nNotes:\n * this object will reflect reachability status for any interface available on the computer.\n * this constructor relies on the hostname being resolvable, possibly through DNS, Bonjour, locally defined, etc."
    },
    "Creates a reachability object for testing internet access": {
        "prefix": "hs.network.reachability.internet() -> reachabilityObject",
        "body": "hs.network.reachability.internet()",
        "description": "Creates a reachability object for testing internet access\n\nParameters:\n * None\n\nReturns:\n * a reachability object\n\nNotes:\n * This is equivalent to `hs.network.reachability.forAddress(\"0.0.0.0\")`\n * This constructor assumes that a default route for IPv4 traffic is sufficient to determine internet access.  If you are on an IPv6 only network which does not also provide IPv4 route mapping, you should probably use something along the lines of `hs.network.reachability.forAddress(\"::\")` instead."
    },
    "Creates a reachability object for testing IPv4 link local networking": {
        "prefix": "hs.network.reachability.linkLocal() -> reachabilityObject",
        "body": "hs.network.reachability.linkLocal()",
        "description": "Creates a reachability object for testing IPv4 link local networking\n\nParameters:\n * None\n\nReturns:\n * a reachability object\n\nNotes:\n * This is equivalent to `hs.network.reachability.forAddress(\"169.254.0.0\")`\n * You can use this to determine if any interface has an IPv4 link local address (i.e. zero conf or local only networking) by checking the \"isDirect\" flag:\n   * `hs.network.reachability.linklocal():status() & hs.network.reachability.flags.isDirect`\n * If the internet is reachable, then this network will also be reachable by default -- use the isDirect flag to ensure that the route is local."
    },
    "Set or remove the callback function for a reachability object": {
        "prefix": "hs.network.reachability:setCallback(function | nil) -> reachabilityObject",
        "body": "hs.network.reachability:setCallback(${1:function | nil})",
        "description": "Set or remove the callback function for a reachability object\n\nParameters:\n * a function or nil to set or remove the reachability object callback function\n\nReturns:\n * the reachability object\n\nNotes:\n * The callback function will be invoked each time the status for the given reachability object changes.  The callback function should expect 2 arguments, the reachability object itself and a numeric representation of the reachability flags, and should not return anything.\n * This method just sets the callback function.  You can start or stop the watcher with [hs.network.reachability:start](#start) or [hs.network.reachability:stop](#stop)"
    },
    "Starts watching the reachability object for changes and invokes the callback function (if any) when a change occurs.": {
        "prefix": "hs.network.reachability:start() -> reachabilityObject",
        "body": "hs.network.reachability:start()",
        "description": "Starts watching the reachability object for changes and invokes the callback function (if any) when a change occurs.\n\nParameters:\n * None\n\nReturns:\n * the reachability object\n\nNotes:\n * The callback function should be specified with [hs.network.reachability:setCallback](#setCallback)."
    },
    "Returns the reachability status for the object": {
        "prefix": "hs.network.reachability:status() -> number",
        "body": "hs.network.reachability:status()",
        "description": "Returns the reachability status for the object\n\nParameters:\n * None\n\nReturns:\n * a numeric representation of the reachability status\n\nNotes:\n * The numeric representation is made up from a combination of the flags defined in [hs.network.reachability.flags](#flags)."
    },
    "Returns a string representation of the reachability status for the object": {
        "prefix": "hs.network.reachability:statusString() -> string",
        "body": "hs.network.reachability:statusString()",
        "description": "Returns a string representation of the reachability status for the object\n\nParameters:\n * None\n\nReturns:\n * a string representation of the reachability status for the object\n\nNotes:\n * This is included primarily for debugging, but may be more useful when you just want a quick look at the reachability status for display or testing.\n * The string will be made up of the following flags:\n   * 't'|'-' indicates if the destination is reachable through a transient connection\n   * 'R'|'-' indicates if the destination is reachable\n   * 'c'|'-' indicates that a connection of some sort is required for the destination to be reachable\n   * 'C'|'-' indicates if the destination requires a connection which will be initiated when traffic to the destination is present\n   * 'i'|'-' indicates if the destination requires a connection which will require user activity to initiate\n   * 'D'|'-' indicates if the destination requires a connection which will be initiated on demand through the CFSocketStream interface\n   * 'l'|'-' indicates if the destination is actually a local address\n   * 'd'|'-' indicates if the destination is directly connected"
    },
    "Stops watching the reachability object for changes.": {
        "prefix": "hs.network.reachability:stop() -> reachabilityObject",
        "body": "hs.network.reachability:stop()",
        "description": "Stops watching the reachability object for changes.\n\nParameters:\n * None\n\nReturns:\n * the reachability object"
    },
    "Creates a new listener for mouth noise recognition": {
        "prefix": "hs.noises.new(fn) -> listener",
        "body": "hs.noises.new(${1:fn})",
        "description": "Creates a new listener for mouth noise recognition\n\nParameters:\n * A function that is called when a mouth noise is recognized. It should accept a single parameter which will be a number representing the event type (see module docs).\n\nReturns:\n * An `hs.noises` object"
    },
    "Starts listening to the microphone and passing the audio to the recognizer.": {
        "prefix": "hs.noises:start() -> self",
        "body": "hs.noises:start()",
        "description": "Starts listening to the microphone and passing the audio to the recognizer.\n\nParameters:\n * None\n\nReturns:\n * The `hs.noises` object"
    },
    "Stops the listener from recording and analyzing microphone input.": {
        "prefix": "hs.noises:stop() -> self",
        "body": "hs.noises:stop()",
        "description": "Stops the listener from recording and analyzing microphone input.\n\nParameters:\n * None\n\nReturns:\n * The `hs.noises` object"
    },
    "Get or set the label of a notification's action button": {
        "prefix": "hs.notify:actionButtonTitle([buttonTitle]) -> notificationObject | current-setting",
        "body": "hs.notify:actionButtonTitle(${1:[buttonTitle]})",
        "description": "Get or set the label of a notification's action button\n\nParameters:\n * buttonTitle - An optional string containing the title for the notification's action button.  If no parameter is provided, then the current setting is returned.\n\nReturns:\n * The notification object, if buttonTitle is present; otherwise the current setting.\n\nNotes:\n * The affects of this method only apply if the user has set Hammerspoon notifications to `Alert` in the Notification Center pane of System Preferences\n * This value is ignored if [hs.notify:hasReplyButton](#hasReplyButton) is true."
    },
    "Returns how the notification was activated by the user.": {
        "prefix": "hs.notify:activationType() -> number",
        "body": "hs.notify:activationType()",
        "description": "Returns how the notification was activated by the user.\n\nParameters:\n * None\n\nReturns:\n * the integer value corresponding to how the notification was activated by the user.  See the table `hs.notify.activationTypes[]` for more information."
    },
    "Convenience array of the possible activation types for a notification, and their reverse for reference.": {
        "prefix": "hs.notify.activationTypes[]",
        "body": "hs.notify.activationTypes",
        "description": "Convenience array of the possible activation types for a notification, and their reverse for reference.\n* None                    - The user has not interacted with the notification.\n* ContentsClicked         - User clicked on notification\n* ActionButtonClicked     - User clicked on Action button\n* Replied                 - User used Reply button\n* AdditionalActionClicked - Additional Action selected\n\nNotes:\n * Count starts at zero. (implemented in Objective-C)"
    },
    "Returns the date and time when a notification was delivered": {
        "prefix": "hs.notify:actualDeliveryDate() -> number",
        "body": "hs.notify:actualDeliveryDate()",
        "description": "Returns the date and time when a notification was delivered\n\nParameters:\n * None\n\nReturns:\n * A number containing the delivery date/time of the notification, in seconds since the epoch (i.e. 1970-01-01 00:00:00 +0000)\n\nNotes:\n * You can turn epoch times into a human readable string or a table of date elements with the `os.date()` function."
    },
    "Get or set additional actions which will be displayed for an alert type notification when the user clicks and holds down the action button of the alert.": {
        "prefix": "hs.notify:additionalActions([actionsTable]) -> notificationObject | table",
        "body": "hs.notify:additionalActions(${1:[actionsTable]})",
        "description": "Get or set additional actions which will be displayed for an alert type notification when the user clicks and holds down the action button of the alert.\n\nParameters:\n * an optional table containing an array of strings specifying the additional options to list for the user to select from the notification.\n\nReturns:\n * The notification object, if an argument is present; otherwise the current value\n\nNotes:\n * The additional items will be listed in a pop-up menu when the user clicks and holds down the mouse button in the action button of the alert.\n * If the user selects one of the additional actions, [hs.notify:activationType](#activationType) will equal `hs.notify.activationTypes.additionalActionClicked`\n * See also [hs.notify:additionalActivationAction](#additionalActivationAction)"
    },
    "Return the additional action that the user selected from an alert type notification that has additional actions available.": {
        "prefix": "hs.notify:additionalActivationAction() -> string | nil",
        "body": "hs.notify:additionalActivationAction()",
        "description": "Return the additional action that the user selected from an alert type notification that has additional actions available.\n\nParameters:\n * None\n\nReturns:\n * If the notification has additional actions assigned with [hs.notify:additionalActions](#additionalActions) and the user selects one, returns a string containing the selected action; otherwise returns nil.\n\nNotes:\n * If the user selects one of the additional actions, [hs.notify:activationType](#activationType) will equal `hs.notify.activationTypes.additionalActionClicked`\n * See also [hs.notify:additionalActions](#additionalActions)"
    },
    "Get or set whether a notification should be presented even if this overrides Notification Center's decision process.": {
        "prefix": "hs.notify:alwaysPresent([alwaysPresent]) -> notificationObject | current-setting",
        "body": "hs.notify:alwaysPresent(${1:[alwaysPresent]})",
        "description": "Get or set whether a notification should be presented even if this overrides Notification Center's decision process.\n\nParameters:\n * alwaysPresent - An optional boolean parameter indicating whether the notification should override Notification Center's decision about whether to present the notification or not. Defaults to true.  If no parameter is provided, then the current setting is returned.\n\nReturns:\n * The notification object, if alwaysPresent is provided; otherwise the current setting.\n\nNotes:\n * This does not affect the return value of `hs.notify:presented()` -- that will still reflect the decision of the Notification Center\n * Examples of why the users Notification Center would choose not to display a notification would be if Hammerspoon is the currently focussed application, being attached to a projector, or the user having set Do Not Disturb.\n\n * if the notification was not created by this module, this method will return nil"
    },
    "Get or set whether an alert notification should always show an alternate action menu.": {
        "prefix": "hs.notify:alwaysShowAdditionalActions([state]) -> notificationObject | boolean",
        "body": "hs.notify:alwaysShowAdditionalActions(${1:[state]})",
        "description": "Get or set whether an alert notification should always show an alternate action menu.\n\nParameters:\n * state - An optional boolean, default false, indicating whether the notification should always show an alternate action menu.\n\nReturns:\n * The notification object, if an argument is present; otherwise the current value.\n\nNote:\n * This method has no effect unless the user has set Hammerspoon notifications to `Alert` in the Notification Center pane of System Preferences.\n * [hs.notify:additionalActions](#additionalActions) must also be used for this method to have any effect.\n * **WARNING:** This method uses a private API. It could break at any time. Please file an issue if it does."
    },
    "Get or set whether a notification should automatically withdraw once activated": {
        "prefix": "hs.notify:autoWithdraw([shouldWithdraw]) -> notificationObject | current-setting",
        "body": "hs.notify:autoWithdraw(${1:[shouldWithdraw]})",
        "description": "Get or set whether a notification should automatically withdraw once activated\n\nParameters:\n * shouldWithdraw - An optional boolean indicating whether the notification should automatically withdraw. Defaults to true.  If no parameter is provided, then the current setting is returned.\n\nReturns:\n * The notification object, if shouldWithdraw is present; otherwise the current setting.\n\nNote:\n * This method has no effect if the user has set Hammerspoon notifications to `Alert` in the Notification Center pane of System Preferences: clicking on either the action or other button will clear the notification automatically.\n * If a notification which was created before your last reload (or restart) of Hammerspoon and is clicked upon before hs.notify has been loaded into memory, this setting will not be honored because the initial application delegate is not aware of this option and is set to automatically withdraw all notifications which are acted upon.\n\n * if the notification was not created by this module, this method will return nil"
    },
    "Get or set a notification's content image.": {
        "prefix": "hs.notify:contentImage([image]) -> notificationObject | current-setting",
        "body": "hs.notify:contentImage(${1:[image]})",
        "description": "Get or set a notification's content image.\n\nParameters:\n * image - An optional hs.image parameter containing the image to display. Defaults to nil. If no parameter is provided, then the current setting is returned.\n\nReturns:\n * The notification object, if image is provided; otherwise the current setting.\n\nNotes:\n * See hs.image for details on how to specify or define an image\n * This method is only supported in OS X 10.9 or greater. A warning will be displayed in the console and the method will be treated as a no-op if used on an unsupported system."
    },
    "The string representation of the default notification sound. Use `hs.notify:soundName()` or set the `soundName` attribute in `hs:notify.new()`, to this constant, if you want to use the default sound": {
        "prefix": "hs.notify.defaultNotificationSound",
        "body": "hs.notify.defaultNotificationSound",
        "description": "The string representation of the default notification sound. Use `hs.notify:soundName()` or set the `soundName` attribute in `hs:notify.new()`, to this constant, if you want to use the default sound"
    },
    "Returns whether the notification has been delivered to the Notification Center": {
        "prefix": "hs.notify:delivered() -> bool",
        "body": "hs.notify:delivered()",
        "description": "Returns whether the notification has been delivered to the Notification Center\n\nParameters:\n * None\n\nReturns:\n * A boolean indicating whether the notification has been delivered to the users Notification Center"
    },
    "Returns a table containing notifications which have been delivered.": {
        "prefix": "hs.notify.deliveredNotifications() -> table",
        "body": "hs.notify.deliveredNotifications()",
        "description": "Returns a table containing notifications which have been delivered.\n\nParameters:\n * None\n\nReturns:\n * a table containing the notification userdata objects for all Hammerspoon notifications currently in the notification center\n\nNotes:\n * Only notifications which have been presented but not cleared, either by the user clicking on the [hs.notify:otherButtonTitle](#otherButtonTitle) or through auto-withdrawal (see [hs.notify:autoWithdraw](#autoWithdraw) for more details), will be in the array returned.\n\n * You can use this function along with [hs.notify:getFunctionTag](#getFunctionTag) to re=register necessary callback functions with [hs.notify.register](#register) when Hammerspoon is restarted.\n\n * Since notifications which the user has closed (or cancelled) do not trigger a callback, you can check this table with a timer to see if the user has cleared a notification, e.g.\n~~~lua\nmyNotification = hs.notify.new():send()\nclearCheck = hs.timer.doEvery(10, function()\n    if not hs.fnutils.contains(hs.notify.deliveredNotifications(), myNotification) then\n        if myNotification:activationType() == hs.notify.activationTypes.none then\n            print(\"You dismissed me!\")\n        else\n            print(\"A regular action occurred, so callback (if any) was invoked\")\n        end\n        clearCheck:stop() -- either way, no need to keep polling\n        clearCheck = nil\n    end\nend)\n~~~"
    },
    "Return the name of the function tag the notification will call when activated.": {
        "prefix": "hs.notify:getFunctionTag() -> functiontag",
        "body": "hs.notify:getFunctionTag()",
        "description": "Return the name of the function tag the notification will call when activated.\n\nParameters:\n * None\n\nReturns:\n * The function tag for this notification as a string.\n\nNotes:\n * This tag should correspond to a function in [hs.notify.registry](#registry) and can be used to either add a replacement with `hs.notify.register(...)` or remove it with `hs.notify.unregister(...)`\n\n * if the notification was not created by this module, this method will return nil"
    },
    "Get or set the presence of an action button in a notification": {
        "prefix": "hs.notify:hasActionButton([hasButton]) -> notificationObject | current-setting",
        "body": "hs.notify:hasActionButton(${1:[hasButton]})",
        "description": "Get or set the presence of an action button in a notification\n\nParameters:\n * hasButton - An optional boolean indicating whether an action button should be present.  If no parameter is provided, then the current setting is returned.\n\nReturns:\n * The notification object, if hasButton is present; otherwise the current setting.\n\nNotes:\n * The affects of this method only apply if the user has set Hammerspoon notifications to `Alert` in the Notification Center pane of System Preferences"
    },
    "Get or set whether an alert notification has a \"Reply\" button for additional user input.": {
        "prefix": "hs.notify:hasReplyButton([state]) -> notificationObject | boolean",
        "body": "hs.notify:hasReplyButton(${1:[state]})",
        "description": "Get or set whether an alert notification has a \"Reply\" button for additional user input.\n\nParameters:\n * state - An optional boolean, default false, indicating whether the notification should include a reply button for additional user input.\n\nReturns:\n * The notification object, if an argument is present; otherwise the current value\n\nNote:\n * This method has no effect unless the user has set Hammerspoon notifications to `Alert` in the Notification Center pane of System Preferences.\n * [hs.notify:hasActionButton](#hasActionButton) must also be true or the \"Reply\" button will not be displayed.\n * If this is set to true, the action button will be \"Reply\" even if you have set another one with [hs.notify:actionButtonTitle](#actionButtonTitle)."
    },
    "Get or set the informative text of a notification": {
        "prefix": "hs.notify:informativeText([informativeText]) -> notificationObject | current-setting",
        "body": "hs.notify:informativeText(${1:[informativeText]})",
        "description": "Get or set the informative text of a notification\n\nParameters:\n * informativeText - An optional string containing the informative text to be set on the notification object. This can be an empty string. If `nil` is passed, any existing informative text will be removed.  If no parameter is provided, then the current setting is returned.\n\nReturns:\n * The notification object, if informativeText is present; otherwise the current setting."
    },
    "Creates a new notification object": {
        "prefix": "hs.notify.new([fn,][attributes]) -> notification",
        "body": "hs.notify.new(${1:[fn},${2:][attributes]})",
        "description": "Creates a new notification object\n\nParameters:\n * fn - An optional function or function-tag, which will be called when the user interacts with notifications. The notification object will be passed as an argument to the function. If you leave this parameter out or specify nil, then no callback will be attached to the notification.\n * attributes - An optional table for applying attributes to the notification. Possible keys are:\n\n  * alwaysPresent   - see [hs.notify:alwaysPresent](#alwaysPresent)\n  * autoWithdraw    - see [hs.notify:autoWithdraw](#autoWithdraw)\n  * contentImage    - see [hs.notify:contentImage](#contentImage)\n  * informativeText - see [hs.notify:informativeText](#informativeText)\n  * soundName       - see [hs.notify:soundName](#soundName)\n  * subTitle        - see [hs.notify:subTitle](#subTitle)\n  * title           - see [hs.notify:title](#title)\n  * setIdImage      - see [hs.notify:setIdImage](#setIdImage) -- note the border will automatically be set to false if assigned as an attribute in this table.\n\n The following can also be set, but will only have an apparent effect on the notification when the user has set Hammerspoon's notification style to \"Alert\" in the Notification Center panel of System Preferences:\n\n  * actionButtonTitle           - see [hs.notify:actionButtonTitle](#actionButtonTitle)\n  * hasActionButton             - see [hs.notify:hasActionButton](#hasActionButton)\n  * otherButtonTitle            - see [hs.notify:otherButtonTitle](#otherButtonTitle)\n  * additionalActions           - see [hs.notify:additionalActions](#additionalActions)\n  * hasReplyButton              - see [hs.notify:hasReplyButton](#hasReplyButton)\n  * responsePlaceholder         - see [hs.notify:responsePlaceholder](#responsePlaceholder)\n  * alwaysShowAdditionalActions - see [hs.notify:alwaysShowAdditionalActions](#alwaysShowAdditionalActions)\n  * withdrawAfter               - see [hs.notify:withdrawAfter](#withdrawAfter)\n\nReturns:\n * A notification object\n\nNotes:\n * A function-tag is a string key which corresponds to a function stored in the [hs.notify.registry](#registry) table with the `hs.notify.register()` function.\n * If a notification does not have a `title` attribute set, OS X will not display it, so by default it will be set to \"Notification\". You can use the `title` key in the attributes table, or call `hs.notify:title()` before displaying the notification to change this."
    },
    "Get or set the label of a notification's other button": {
        "prefix": "hs.notify:otherButtonTitle([buttonTitle]) -> notificationObject | current-setting",
        "body": "hs.notify:otherButtonTitle(${1:[buttonTitle]})",
        "description": "Get or set the label of a notification's other button\n\nParameters:\n * buttonTitle - An optional string containing the title for the notification's other button.  If no parameter is provided, then the current setting is returned.\n\nReturns:\n * The notification object, if buttonTitle is present; otherwise the current setting.\n\nNotes:\n * The affects of this method only apply if the user has set Hammerspoon notifications to `Alert` in the Notification Center pane of System Preferences\n * Due to OSX limitations, it is NOT possible to get a callback for this button."
    },
    "Returns whether the users Notification Center decided to display the notification": {
        "prefix": "hs.notify:presented() -> bool",
        "body": "hs.notify:presented()",
        "description": "Returns whether the users Notification Center decided to display the notification\n\nParameters:\n * None\n\nReturns:\n * A boolean indicating whether the users Notification Center decided to display the notification\n\nNotes:\n * Examples of why the users Notification Center would choose not to display a notification would be if Hammerspoon is the currently focussed application, being attached to a projector, or the user having set Do Not Disturb."
    },
    "Registers a function callback with the specified tag for a notification. The callback function will be invoked when the user clicks on or interacts with a notification.": {
        "prefix": "hs.notify.register(tag, fn) -> id",
        "body": "hs.notify.register(${1:tag}, ${2:fn})",
        "description": "Registers a function callback with the specified tag for a notification. The callback function will be invoked when the user clicks on or interacts with a notification.\n\nParameters:\n * tag - a string tag to identify the registered callback function. Use this as the function tag in [hs.notify.new](#new) and [hs.notify.show](#show)\n * fn  - the function which should be invoked when a notification with this tag is interacted with.\n\nReturns:\n * a numerical id representing the entry in [hs.notify.registry](#registry) for this function. This number can be used with [hs.notify.unregister](#unregister) to unregister a function later if you wish.\n\nNotes:\n * If a function is already registered with the specified tag, it is replaced by with the new one."
    },
    "A table containing the registered callback functions and their tags.": {
        "prefix": "hs.notify.registry[]",
        "body": "hs.notify.registry",
        "description": "A table containing the registered callback functions and their tags.\n\nNotes:\n * This table should not be modified directly. Use the `hs.notify.register(tag, fn)` and `hs.notify.unregister(id)` functions.\n * This table has a __tostring metamethod so you can see the list of registered function tags in the console by typing `hs.notify.registry`\n * See [hs.notify.warnAboutMissingFunctionTag](#warnAboutMissingFunctionTag) for determining the behavior when a notification attempts to perform a callback to a function tag which is not present in this table. This occurrence is most common with notifications which are acted upon by the user after Hammerspoon has been reloaded."
    },
    "Get the users input from an alert type notification with a reply button.": {
        "prefix": "hs.notify:response() -> string | nil",
        "body": "hs.notify:response()",
        "description": "Get the users input from an alert type notification with a reply button.\n\nParameters:\n * None\n\nReturns:\n * If the notification has a reply button and the user clicks on it, returns a string containing the user input (may be an empty string); otherwise returns nil.\n\nNotes:\n * [hs.notify:activationType](#activationType) will equal `hs.notify.activationTypes.replied` if the user clicked on the Reply button and then clicks on Send.\n * See also [hs.notify:hasReplyButton](#hasReplyButton)"
    },
    "Set a placeholder string for alert type notifications with a reply button.": {
        "prefix": "hs.notify:responsePlaceholder([string]) -> notificationObject | string",
        "body": "hs.notify:responsePlaceholder(${1:[string]})",
        "description": "Set a placeholder string for alert type notifications with a reply button.\n\nParameters:\n * `string` - an optional string specifying placeholder text to display in the reply box before the user has types anything in an alert type notification with a reply button.\n\nReturns:\n * The notification object, if an argument is present; otherwise the current value\n\nNotes:\n * In macOS 10.13, this text appears so light that it is almost unreadable; so far no workaround has been found.\n * See also [hs.notify:hasReplyButton](#hasReplyButton)"
    },
    "Schedules a notification for delivery in the future.": {
        "prefix": "hs.notify:schedule(date) -> notificationObject",
        "body": "hs.notify:schedule(${1:date})",
        "description": "Schedules a notification for delivery in the future.\n\nParameters:\n * date - the date the notification should be delivered to the users Notification Center specified as the number of seconds since 1970-01-01 00:00:00Z or as a string in rfc3339 format: \"YYYY-MM-DD[T]HH:MM:SS[Z]\".\n\nReturns:\n * The notification object\n\nNotes:\n * See also hs.notify:send()\n * hs.settings.dateFormat specifies a lua format string which can be used with `os.date()` to properly present the date and time as a string for use with this method."
    },
    "Returns a table containing notifications which are scheduled but have not yet been delivered.": {
        "prefix": "hs.notify.scheduledNotifications() -> table",
        "body": "hs.notify.scheduledNotifications()",
        "description": "Returns a table containing notifications which are scheduled but have not yet been delivered.\n\nParameters:\n * None\n\nReturns:\n * a table containing the notification userdata objects for all Hammerspoon notifications currently scheduled to be delivered.\n\nNotes:\n * Once a notification has been delivered, it is moved to [hs.notify.deliveredNotifications](#deliveredNotifications) or removed, depending upon the users action.\n\n * You can use this function along with [hs.notify:getFunctionTag](#getFunctionTag) to re=register necessary callback functions with [hs.notify.register](#register) when Hammerspoon is restarted."
    },
    "Delivers the notification immediately to the users Notification Center.": {
        "prefix": "hs.notify:send() -> notificationObject",
        "body": "hs.notify:send()",
        "description": "Delivers the notification immediately to the users Notification Center.\n\nParameters:\n * None\n\nReturns:\n * The notification object\n\nNotes:\n * See also hs.notify:schedule()\n * If a notification has been modified, then this will resend it.\n * You can invoke this multiple times if you wish to repeat the same notification."
    },
    "Set a notification's identification image (replace the Hammerspoon icon with a custom image)": {
        "prefix": "hs.notify:setIdImage(image[, withBorder]) -> notificationObject",
        "body": "hs.notify:setIdImage(${1:image[}, ${2:withBorder]})",
        "description": "Set a notification's identification image (replace the Hammerspoon icon with a custom image)\n\nParameters:\n * image - An `hs.image` object, a string containing an image path, or a string defining an ASCIImage\n * withBorder - An optional boolean to give the notification image a border. Defaults to `false`\n\nReturns:\n * The notification object\n\nNotes:\n * See hs.image for details on how to specify or define an image\n * **WARNING**: This method uses a private API. It could break at any time. Please file an issue if it does"
    },
    "Shorthand constructor to create and show simple notifications": {
        "prefix": "hs.notify.show(title, subTitle, information[, tag]) -> notfication",
        "body": "hs.notify.show(${1:title}, ${2:subTitle}, ${3:information[}, ${4:tag]})",
        "description": "Shorthand constructor to create and show simple notifications\n\nParameters:\n * title       - the title for the notification\n * subTitle    - the subtitle, or second line, of the notification\n * information - the main textual body of the notification\n * tag         - a function tag corresponding to a function registered with [hs.notify.register](#register)\n\nReturns:\n * a notification object\n\nNotes:\n * All three textual parameters are required, though they can be empty strings\n * This function is really a shorthand for `hs.notify.new(...):send()`\n * Notifications created using this function will inherit the default `withdrawAfter` value, which is 5 seconds. To produce persistent notifications you should use `hs.notify.new()` with a `withdrawAfter` attribute of 0."
    },
    "Get or set the sound for a notification": {
        "prefix": "hs.notify:soundName([soundName]) -> notificationObject | current-setting",
        "body": "hs.notify:soundName(${1:[soundName]})",
        "description": "Get or set the sound for a notification\n\nParameters:\n * soundName - An optional string containing the name of a sound to play with the notification. If `nil`, no sound will be played. Defaults to `nil`.  If no parameter is provided, then the current setting is returned.\n\nReturns:\n * The notification object, if soundName is present; otherwise the current setting.\n\nNotes:\n * Sounds will first be matched against the names of system sounds. If no matches can be found, they will then be searched for in the following paths, in order:\n  * `~/Library/Sounds`\n  * `/Library/Sounds`\n  * `/Network/Sounds`\n  * `/System/Library/Sounds`"
    },
    "Get or set the subtitle of a notification": {
        "prefix": "hs.notify:subTitle([subtitleText]) -> notificationObject | current-setting",
        "body": "hs.notify:subTitle(${1:[subtitleText]})",
        "description": "Get or set the subtitle of a notification\n\nParameters:\n * subtitleText - An optional string containing the subtitle to be set on the notification object. This can be an empty string. If `nil` is passed, any existing subtitle will be removed.  If no parameter is provided, then the current setting is returned.\n\nReturns:\n * The notification object, if subtitleText is present; otherwise the current setting."
    },
    "Get or set the title of a notification": {
        "prefix": "hs.notify:title([titleText]) -> notificationObject | current-setting",
        "body": "hs.notify:title(${1:[titleText]})",
        "description": "Get or set the title of a notification\n\nParameters:\n * titleText - An optional string containing the title to be set on the notification object.  The default value is \"Notification\".  If `nil` is passed, then the title is set to the empty string.  If no parameter is provided, then the current setting is returned.\n\nReturns:\n * The notification object, if titleText is present; otherwise the current setting."
    },
    "Unregisters a function callback so that it is no longer available as a callback when notifications corresponding to the specified entry are interacted with.": {
        "prefix": "hs.notify.unregister(id|tag)",
        "body": "hs.notify.unregister(${1:id|tag})",
        "description": "Unregisters a function callback so that it is no longer available as a callback when notifications corresponding to the specified entry are interacted with.\n\nParameters:\n * id or tag - the numerical id provided by [hs.notify.register](#register) or string tag representing the callback function to be removed\n\nReturns:\n * None"
    },
    "Unregisters all functions registered as callbacks.": {
        "prefix": "hs.notify.unregisterall()",
        "body": "hs.notify.unregisterall()",
        "description": "Unregisters all functions registered as callbacks.\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This does not remove the notifications from the User Notification Center, it just removes their callback function for when the user interacts with them. To remove all notifications, see [hs.notify.withdrawAll](#withdrawAll) and [hs.notify.withdrawAllScheduled](#withdrawAllScheduled)"
    },
    "A value indicating whether or not a missing notification function tag should cause a warning.  Defaults to `true`.": {
        "prefix": "hs.notify.warnAboutMissingFunctionTag",
        "body": "hs.notify.warnAboutMissingFunctionTag",
        "description": "A value indicating whether or not a missing notification function tag should cause a warning.  Defaults to `true`.\n\nIf this variable is set to a function, the function will be called with two parameters `tag`, which will match the tag specified if you used [hs.notify.show](#show) or a UUID if you used [hs.notify.new](#new) to define the notification, and `notification` which will be the notificationObject representing the notification.  No return value is expected.\n\nIf this variable is not set to a function, it will be evaluated as a lua boolean (i.e. any value except `false` and `nil` is considered true).  If it evaluates to true, a warning will be displayed to the console indicating that the callback function is missing; if it is false, the notification will be silently discarded."
    },
    "Withdraws a delivered notification from the Notification Center.": {
        "prefix": "hs.notify:withdraw() -> notificationObject",
        "body": "hs.notify:withdraw()",
        "description": "Withdraws a delivered notification from the Notification Center.\n\nParameters:\n * None\n\nReturns:\n * The notification object\n * This method allows you to unlock a dispatched notification so that it can be modified and resent.\n\n * if the notification was not created by this module, it will still be withdrawn if possible"
    },
    "Get or set the number of seconds after which to automatically withdraw a notification": {
        "prefix": "hs.notify:withdrawAfter([seconds]) -> notificationObject | number",
        "body": "hs.notify:withdrawAfter(${1:[seconds]})",
        "description": "Get or set the number of seconds after which to automatically withdraw a notification\n\nParamters:\n * seconds - An optional number, default 5, of seconds after which to withdraw a notification. A value of 0 will not withdraw a notification automatically\n\nReturns:\n * The notification object, if an argument is present; otherwise the current value.\n\nNote:\n * While this setting applies to both Banner and Alert styles of notifications, it is functionally meaningless for Banner styles\n * A value of 0 will disable auto-withdrawal\n\n * if the notification was not created by this module, this method will return nil"
    },
    "Withdraw all delivered notifications from Hammerspoon": {
        "prefix": "hs.notify.withdrawAll()",
        "body": "hs.notify.withdrawAll()",
        "description": "Withdraw all delivered notifications from Hammerspoon\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This will withdraw all notifications for Hammerspoon, including those not sent by this module or that linger from a previous load of Hammerspoon."
    },
    "Withdraw all scheduled notifications from Hammerspoon": {
        "prefix": "hs.notify.withdrawAllScheduled()",
        "body": "hs.notify.withdrawAllScheduled()",
        "description": "Withdraw all scheduled notifications from Hammerspoon\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Runs osascript code": {
        "prefix": "hs.osascript._osascript(source, language) -> bool, object, descriptor",
        "body": "hs.osascript._osascript(${1:source}, ${2:language})",
        "description": "Runs osascript code\n\nParameters:\n * source - Some osascript code to execute\n * language - A string containing the OSA language, either 'AppleScript' or 'JavaScript'. Defaults to AppleScript if invalid language\n\nReturns:\n * A boolean value indicating whether the code succeeded or not\n * An object containing the parsed output that can be any type, or nil if unsuccessful\n * A string containing the raw output of the code and/or its errors"
    },
    "Runs AppleScript code": {
        "prefix": "hs.osascript.applescript(source) -> bool, object, descriptor",
        "body": "hs.osascript.applescript(${1:source})",
        "description": "Runs AppleScript code\n\nParameters:\n * source - A string containing some AppleScript code to execute\n\nReturns:\n * A boolean value indicating whether the code succeeded or not\n * An object containing the parsed output that can be any type, or nil if unsuccessful\n * If the code succeeded, the raw output of the code string. If the code failed, a table containing an error dictionary\n\nNotes:\n * Use hs.osascript._osascript(source, \"AppleScript\") if you always want the result as a string, even when a failure occurs"
    },
    "Runs AppleScript code from a source file.": {
        "prefix": "hs.osascript.applescriptFromFile(fileName) -> bool, object, descriptor",
        "body": "hs.osascript.applescriptFromFile(${1:fileName})",
        "description": "Runs AppleScript code from a source file.\n\nParameters:\n * fileName - A string containing the file name of an AppleScript file to execute.\n\nReturns:\n * A boolean value indicating whether the code succeeded or not\n * An object containing the parsed output that can be any type, or nil if unsuccessful\n * If the code succeeded, the raw output of the code string. If the code failed, a table containing an error dictionary\n\nNotes:\n * This function uses hs.osascript.applescript for execution.\n * Use hs.osascript._osascript(source, \"AppleScript\") if you always want the result as a string, even when a failure occurs. However, this function can only take a string, and not a file name."
    },
    "Runs JavaScript code": {
        "prefix": "hs.osascript.javascript(source) -> bool, object, descriptor",
        "body": "hs.osascript.javascript(${1:source})",
        "description": "Runs JavaScript code\n\nParameters:\n * source - A string containing some JavaScript code to execute\n\nReturns:\n * A boolean value indicating whether the code succeeded or not\n * An object containing the parsed output that can be any type, or nil if unsuccessful\n * If the code succeeded, the raw output of the code string. If the code failed, a table containing an error dictionary\n\nNotes:\n * Use hs.osascript._osascript(source, \"JavaScript\") if you always want the result as a string, even when a failure occurs"
    },
    "Runs JavaScript code from a source file.": {
        "prefix": "hs.osascript.javascriptFromFile(fileName) -> bool, object, descriptor",
        "body": "hs.osascript.javascriptFromFile(${1:fileName})",
        "description": "Runs JavaScript code from a source file.\n\nParameters:\n * fileName - A string containing the file name of an JavaScript file to execute.\n\nReturns:\n * A boolean value indicating whether the code succeeded or not\n * An object containing the parsed output that can be any type, or nil if unsuccessful\n * If the code succeeded, the raw output of the code string. If the code failed, a table containing an error dictionary\n\nNotes:\n * This function uses hs.osascript.javascript for execution.\n * Use hs.osascript._osascript(source, \"JavaScript\") if you always want the result as a string, even when a failure occurs. However, this function can only take a string, and not a file name."
    },
    "An array whose elements are a table containing the content types for each element on the clipboard.": {
        "prefix": "hs.pasteboard.allContentTypes([name]) -> table",
        "body": "hs.pasteboard.allContentTypes(${1:[name]})",
        "description": "An array whose elements are a table containing the content types for each element on the clipboard.\n\nParameters:\n * name - an optional string indicating the pasteboard name.  If nil or not present, defaults to the system pasteboard.\n\nReturns:\n * an array with each index representing an object on the pasteboard.  If the pasteboard contains only one element, this is equivalent to `{ hs.pasteboard.contentTypes(name) }`."
    },
    "Invokes callback when the specified pasteoard has changed or the timeout is reached.": {
        "prefix": "hs.pasteboard.callbackWhenChanged([name], [timeout], callback) -> None",
        "body": "hs.pasteboard.${3:callback}WhenChanged(${1:[name]}, ${2:[timeout]}, callback)",
        "description": "Invokes callback when the specified pasteoard has changed or the timeout is reached.\n\nParameters:\n * `name`     - an optional string indicating the pasteboard name.  If nil or not present, defaults to the system pasteboard.\n * `timeout`  - an optional number, default 2.0, specifying the time in seconds that this function should wait for a change to the specified pasteboard before timing out.\n * `callback` - a required callback function that will be invoked when either the specified pasteboard contents have changed or the timeout has been reached. The function should expect one boolean argument, true if the pasteboard contents have changed or false if timeout has been reached.\n\nReturns:\n * None\n\nNotes:\n * This function can be used to capture the results of a copy operation issued programatically with `hs.application:selectMenuItem` or `hs.eventtap.keyStroke` without resorting to creating your own timers:\n\n ~~~\n     hs.eventtap.keyStroke({\"cmd\"}, \"c\", 0) -- or whatever method you want to trigger the copy\n     hs.pasteboard.callbackWhenChanged(5, function(state)\n         if state then\n             local contents = hs.pasteboard.getContents()\n             -- do what you want with contents\n         else\n             error(\"copy timeout\") -- or whatever fallback you want when it timesout\n         end\n     end)\n~~~"
    },
    "Gets the number of times the pasteboard owner has changed": {
        "prefix": "hs.pasteboard.changeCount([name]) -> number",
        "body": "hs.pasteboard.changeCount(${1:[name]})",
        "description": "Gets the number of times the pasteboard owner has changed\n\nParameters:\n * name - An optional string containing the name of the pasteboard. Defaults to the system pasteboard\n\nReturns:\n * A number containing a count of the times the pasteboard owner has changed\n\nNotes:\n * This is useful for seeing if the pasteboard has been updated by another process"
    },
    "Clear the contents of the pasteboard": {
        "prefix": "hs.pasteboard.clearContents([name])",
        "body": "hs.pasteboard.clearContents(${1:[name]})",
        "description": "Clear the contents of the pasteboard\n\nParameters:\n * name - An optional string containing the name of the pasteboard. Defaults to the system pasteboard\n\nReturns:\n * None"
    },
    "Return the UTI strings of the data types for the first pasteboard item on the specified pasteboard.": {
        "prefix": "hs.pasteboard.contentTypes([name]) -> table",
        "body": "hs.pasteboard.contentTypes(${1:[name]})",
        "description": "Return the UTI strings of the data types for the first pasteboard item on the specified pasteboard.\n\nParameters:\n * name - An optional string containing the name of the pasteboard. Defaults to the system pasteboard\n\nReturns:\n * a table containing the UTI strings of the data types for the first pasteboard item."
    },
    "Deletes a custom pasteboard": {
        "prefix": "hs.pasteboard.deletePasteboard(name)",
        "body": "hs.pasteboard.deletePasteboard(${1:name})",
        "description": "Deletes a custom pasteboard\n\nParameters:\n * name - A string containing the name of the pasteboard\n\nReturns:\n * None\n\nNotes:\n * You can not delete the system pasteboard, this function should only be called on custom pasteboards you have created"
    },
    "Gets the contents of the pasteboard": {
        "prefix": "hs.pasteboard.getContents([name]) -> string or nil",
        "body": "hs.pasteboard.getContents(${1:[name]})",
        "description": "Gets the contents of the pasteboard\n\nParameters:\n * name - An optional string containing the name of the pasteboard. Defaults to the system pasteboard\n\nReturns:\n * A string containing the contents of the pasteboard, or nil if an error occurred"
    },
    "Return the pasteboard type identifier strings for the specified pasteboard.": {
        "prefix": "hs.pasteboard.pasteboardTypes([name]) -> table",
        "body": "hs.pasteboard.pasteboardTypes(${1:[name]})",
        "description": "Return the pasteboard type identifier strings for the specified pasteboard.\n\nParameters:\n * name - An optional string containing the name of the pasteboard. Defaults to the system pasteboard\n\nReturns:\n * a table containing the pasteboard type identifier strings"
    },
    "Returns all values in the first item on the pasteboard in a table that maps a UTI value to the raw data of the item": {
        "prefix": "hs.pasteboard.readAllData([name]) -> table",
        "body": "hs.pasteboard.readAllData(${1:[name]})",
        "description": "Returns all values in the first item on the pasteboard in a table that maps a UTI value to the raw data of the item\n\nParameters:\n * name - an optional string indicating the pasteboard name.  If nil or not present, defaults to the system pasteboard.\n\nReturns:\n  a mapping from a UTI value to the raw data"
    },
    "Returns the first item on the pasteboard with the specified UTI. The data on the pasteboard must be encoded as a keyed archive object conforming to NSKeyedArchiver.": {
        "prefix": "hs.pasteboard.readArchiverDataForUTI([name], uti) -> any",
        "body": "hs.pasteboard.readArchiverDataForUTI(${1:[name]}, ${2:uti})",
        "description": "Returns the first item on the pasteboard with the specified UTI. The data on the pasteboard must be encoded as a keyed archive object conforming to NSKeyedArchiver.\n\nParameters:\n * name - an optional string indicating the pasteboard name.  If nil or not present, defaults to the system pasteboard.\n * uti  - a string specifying the UTI of the pasteboard item to retrieve.\n\nReturns:\n * a lua item representing the archived data if it can be decoded. Generates an error if the data is in the wrong format.\n\nNotes:\n * NSKeyedArchiver specifies an architecture-independent format that is often used in OS X applications to store and transmit objects between applications and when storing data to a file. It works by recording information about the object types and key-value pairs which make up the objects being stored.\n * Only objects which have conversion functions built in to Hammerspoon can be converted. A string representation describing unrecognized types wil be returned. If you find a common data type that you believe may be of interest to Hammerspoon users, feel free to contribute a conversion function or make a request in the Hammerspoon Google group or Github site.\n * Some applications may define their own classes which can be archived.  Hammerspoon will be unable to recognize these types if the application does not make the object type available in one of its frameworks.  You *may* be able to load the necessary framework with `package.loadlib(\"/Applications/appname.app/Contents/Frameworks/frameworkname.framework/frameworkname\", \"*\")` before retrieving the data, but a full representation of the data in Hammerspoon is probably not possible without support from the Application's developers."
    },
    "Returns one or more `hs.drawing.color` tables from the clipboard, or nil if no compatible objects are present.": {
        "prefix": "hs.pasteboard.readColor([name], [all]) -> hs.drawing.color table or array of hs.drawing.color tables",
        "body": "hs.pasteboard.readColor(${1:[name]}, ${2:[all]})",
        "description": "Returns one or more `hs.drawing.color` tables from the clipboard, or nil if no compatible objects are present.\n\nParameters:\n * name - an optional string indicating the pasteboard name.  If nil or not present, defaults to the system pasteboard.\n * all  - an optional boolean indicating whether or not all (true) of the colors on the clipboard should be returned, or just the first (false).  Defaults to false.\n\nReturns:\n * By default the first color on the clipboard, or a table of all colors on the clipboard if the `all` parameter is provided and set to true.  Returns nil if no colors are present."
    },
    "Returns the first item on the pasteboard with the specified UTI as raw data": {
        "prefix": "hs.pasteboard.readDataForUTI([name], uti) -> string",
        "body": "hs.pasteboard.readDataForUTI(${1:[name]}, ${2:uti})",
        "description": "Returns the first item on the pasteboard with the specified UTI as raw data\n\nParameters:\n * name - an optional string indicating the pasteboard name.  If nil or not present, defaults to the system pasteboard.\n * uti  - a string specifying the UTI of the pasteboard item to retrieve.\n\nReturns:\n * a lua string containing the raw data of the specified pasteboard item\n\nNotes:\n * The UTI's of the items on the pasteboard can be determined with the [hs.pasteboard.allContentTypes](#allContentTypes) and [hs.pasteboard.contentTypes](#contentTypes) functions."
    },
    "Returns one or more `hs.image` objects from the clipboard, or nil if no compatible objects are present.": {
        "prefix": "hs.pasteboard.readImage([name], [all]) -> hs.image object or array of hs.image objects",
        "body": "hs.pasteboard.readImage(${1:[name]}, ${2:[all]})",
        "description": "Returns one or more `hs.image` objects from the clipboard, or nil if no compatible objects are present.\n\nParameters:\n * name - an optional string indicating the pasteboard name.  If nil or not present, defaults to the system pasteboard.\n * all  - an optional boolean indicating whether or not all (true) of the urls on the clipboard should be returned, or just the first (false).  Defaults to false.\n\nReturns:\n * By default the first image on the clipboard, or a table of all images on the clipboard if the `all` parameter is provided and set to true.  Returns nil if no images are present."
    },
    "Returns the first item on the pasteboard with the specified UTI as a property list item": {
        "prefix": "hs.pasteboard.readPListForUTI([name], uti) -> any",
        "body": "hs.pasteboard.readPListForUTI(${1:[name]}, ${2:uti})",
        "description": "Returns the first item on the pasteboard with the specified UTI as a property list item\n\nParameters:\n * name - an optional string indicating the pasteboard name.  If nil or not present, defaults to the system pasteboard.\n * uti  - a string specifying the UTI of the pasteboard item to retrieve.\n\nReturns:\n * a lua item representing the property list value of the pasteboard item specified\n\nNotes:\n * The UTI's of the items on the pasteboard can be determined with the [hs.pasteboard.allContentTypes](#allContentTypes) and [hs.pasteboard.contentTypes](#contentTypes) functions.\n * Property lists consist only of certain types of data: tables, strings, numbers, dates, binary data, and Boolean values."
    },
    "Returns one or more `hs.sound` objects from the clipboard, or nil if no compatible objects are present.": {
        "prefix": "hs.pasteboard.readSound([name], [all]) -> hs.sound object or array of hs.sound objects",
        "body": "hs.pasteboard.readSound(${1:[name]}, ${2:[all]})",
        "description": "Returns one or more `hs.sound` objects from the clipboard, or nil if no compatible objects are present.\n\nParameters:\n * name - an optional string indicating the pasteboard name.  If nil or not present, defaults to the system pasteboard.\n * all  - an optional boolean indicating whether or not all (true) of the urls on the clipboard should be returned, or just the first (false).  Defaults to false.\n\nReturns:\n * By default the first sound on the clipboard, or a table of all sounds on the clipboard if the `all` parameter is provided and set to true.  Returns nil if no sounds are present."
    },
    "Returns one or more strings from the clipboard, or nil if no compatible objects are present.": {
        "prefix": "hs.pasteboard.readString([name], [all]) -> string or array of strings",
        "body": "hs.pasteboard.readString(${1:[name]}, ${2:[all]})",
        "description": "Returns one or more strings from the clipboard, or nil if no compatible objects are present.\n\nParameters:\n * name - an optional string indicating the pasteboard name.  If nil or not present, defaults to the system pasteboard.\n * all  - an optional boolean indicating whether or not all (true) of the urls on the clipboard should be returned, or just the first (false).  Defaults to false.\n\nReturns:\n * By default the first string on the clipboard, or a table of all strings on the clipboard if the `all` parameter is provided and set to true.  Returns nil if no strings are present.\n\nNotes:\n * almost all string and styledText objects are internally convertible and will be available with this method as well as [hs.pasteboard.readStyledText](#readStyledText). If the item is actually an `hs.styledtext` object, the string will be just the text of the object."
    },
    "Returns one or more `hs.styledtext` objects from the clipboard, or nil if no compatible objects are present.": {
        "prefix": "hs.pasteboard.readStyledText([name], [all]) -> hs.styledtext object or array of hs.styledtext objects",
        "body": "hs.pasteboard.readStyledText(${1:[name]}, ${2:[all]})",
        "description": "Returns one or more `hs.styledtext` objects from the clipboard, or nil if no compatible objects are present.\n\nParameters:\n * name - an optional string indicating the pasteboard name.  If nil or not present, defaults to the system pasteboard.\n * all  - an optional boolean indicating whether or not all (true) of the urls on the clipboard should be returned, or just the first (false).  Defaults to false.\n\nReturns:\n * By default the first styledtext object on the clipboard, or a table of all styledtext objects on the clipboard if the `all` parameter is provided and set to true.  Returns nil if no styledtext objects are present.\n\nNotes:\n * almost all string and styledText objects are internally convertible and will be available with this method as well as [hs.pasteboard.readString](#readString). If the item on the clipboard is actually just a string, the `hs.styledtext` object representation will have no attributes set"
    },
    "Returns one or more strings representing file or resource urls from the clipboard, or nil if no compatible objects are present.": {
        "prefix": "hs.pasteboard.readURL([name], [all]) -> string or array of strings representing file or resource urls",
        "body": "hs.pasteboard.readURL(${1:[name]}, ${2:[all]})",
        "description": "Returns one or more strings representing file or resource urls from the clipboard, or nil if no compatible objects are present.\n\nParameters:\n * name - an optional string indicating the pasteboard name.  If nil or not present, defaults to the system pasteboard.\n * all  - an optional boolean indicating whether or not all (true) of the urls on the clipboard should be returned, or just the first (false).  Defaults to false.\n\nReturns:\n * By default the first url on the clipboard, or a table of all urls on the clipboard if the `all` parameter is provided and set to true.  Returns nil if no urls are present."
    },
    "Sets the contents of the pasteboard": {
        "prefix": "hs.pasteboard.setContents(contents[, name]) -> boolean",
        "body": "hs.pasteboard.setContents(${1:contents[}, ${2:name]})",
        "description": "Sets the contents of the pasteboard\n\nParameters:\n * contents - A string to be placed in the pasteboard\n * name - An optional string containing the name of the pasteboard. Defaults to the system pasteboard\n\nReturns:\n * True if the operation succeeded, otherwise false"
    },
    "Returns a table indicating what content types are available on the pasteboard.": {
        "prefix": "hs.pasteboard.typesAvailable([name]) -> table",
        "body": "hs.pasteboard.typesAvailable(${1:[name]})",
        "description": "Returns a table indicating what content types are available on the pasteboard.\n\nParameters:\n * name - an optional string indicating the pasteboard name.  If nil or not present, defaults to the system pasteboard.\n\nReturns:\n * a table which may contain any of the following keys set to the value true:\n   * string     - at least one element which can be represented as a string is on the pasteboard\n   * styledText - at least one element which can be represented as an `hs.styledtext` object is on the pasteboard\n   * sound      - at least one element which can be represented as an `hs.sound` object is on the pasteboard\n   * image      - at least one element which can be represented as an `hs.image` object is on the pasteboard\n   * URL        - at least one element on the pasteboard represents a URL, either to a local file or a remote resource\n   * color      - at least one element on the pasteboard represents a color, representable as a table as described in `hs.drawing.color`\n\nNotes:\n * almost all string and styledText objects are internally convertible and will return true for both keys\n   * if the item on the clipboard is actually just a string, the `hs.styledtext` object representation will have no attributes set\n   * if the item is actually an `hs.styledtext` object, the string representation will be the text without any attributes."
    },
    "Returns the name of a new pasteboard with a name that is guaranteed to be unique with respect to other pasteboards on the computer.": {
        "prefix": "hs.pasteboard.uniquePasteboard() -> string",
        "body": "hs.pasteboard.uniquePasteboard()",
        "description": "Returns the name of a new pasteboard with a name that is guaranteed to be unique with respect to other pasteboards on the computer.\n\nParameters:\n * None\n\nReturns:\n * a unique pasteboard name\n\nNotes:\n * to properly manage system resources, you should release the created pasteboard with [hs.pasteboard.deletePasteboard](#deletePasteboard) when you are certain that it is no longer necessary."
    },
    "Stores in the pasteboard a given table of UTI to data mapping all at once": {
        "prefix": "hs.pasteboard.writeAllData([name], table) -> boolean",
        "body": "hs.pasteboard.writeAllData(${1:[name]}, ${2:table})",
        "description": "Stores in the pasteboard a given table of UTI to data mapping all at once\n\nParameters:\n * name - an optional string indicating the pasteboard name.  If nil or not present, defaults to the system pasteboard.\n * a mapping from a UTI value to the raw data\n\nReturns:\n  * True if the operation succeeded, otherwise false (which most likely means ownership of the pasteboard has changed)"
    },
    "Sets the pasteboard to the contents of the data and assigns its type to the specified UTI. The data will be encoded as an archive conforming to NSKeyedArchiver.": {
        "prefix": "hs.pasteboard.writeArchiverDataForUTI([name], uti, data, [add]) -> boolean",
        "body": "hs.pasteboard.writeArchiverDataForUTI(${1:[name]}, ${2:uti}, ${3:data}, ${4:[add]})",
        "description": "Sets the pasteboard to the contents of the data and assigns its type to the specified UTI. The data will be encoded as an archive conforming to NSKeyedArchiver.\n\nParameters:\n * name - an optional string indicating the pasteboard name.  If nil or not present, defaults to the system pasteboard.\n * uti  - a string specifying the UTI of the pasteboard item to set.\n * data - any type representable in Lua which will be converted into the appropriate NSObject types and archived with NSKeyedArchiver.  All Lua basic types are supported as well as those NSObject types handled by Hammerspoon modules (NSColor, NSStyledText, NSImage, etc.)\n * add  - an optional boolean value specifying if data with other UTI values should retain.  This value must be strictly either true or false if given, to avoid ambiguity with preceding parameters.\n\nReturns:\n * True if the operation succeeded, otherwise false (which most likely means ownership of the pasteboard has changed)\n\nNotes:\n * NSKeyedArchiver specifies an architecture-independent format that is often used in OS X applications to store and transmit objects between applications and when storing data to a file. It works by recording information about the object types and key-value pairs which make up the objects being stored.\n * Only objects which have conversion functions built in to Hammerspoon can be converted.\n\n * A full list of NSObjects supported directly by Hammerspoon is planned in a future Wiki article."
    },
    "Sets the pasteboard to the contents of the data and assigns its type to the specified UTI.": {
        "prefix": "hs.pasteboard.writePListForUTI([name], uti, data, [add]) -> boolean",
        "body": "hs.pasteboard.writePListForUTI(${1:[name]}, ${2:uti}, ${3:data}, ${4:[add]})",
        "description": "Sets the pasteboard to the contents of the data and assigns its type to the specified UTI.\n\nParameters:\n * name - an optional string indicating the pasteboard name.  If nil or not present, defaults to the system pasteboard.\n * uti  - a string specifying the UTI of the pasteboard item to set.\n * data - a lua type which can be represented as a property list value.\n * add  - an optional boolean value specifying if data with other UTI values should retain.  This value must be strictly either true or false if given, to avoid ambiguity with preceding parameters.\n\nReturns:\n * True if the operation succeeded, otherwise false (which most likely means ownership of the pasteboard has changed)\n\nNotes:\n * The UTI's of the items on the pasteboard can be determined with the [hs.pasteboard.allContentTypes](#allContentTypes) and [hs.pasteboard.contentTypes](#contentTypes) functions.\n * Property lists consist only of certain types of data: tables, strings, numbers, dates, binary data, and Boolean values."
    },
    "Sets the pasteboard contents to the object or objects specified.": {
        "prefix": "hs.pasteboard.writeObjects(object, [name]) -> boolean",
        "body": "hs.pasteboard.writeObjects(${1:object}, ${2:[name]})",
        "description": "Sets the pasteboard contents to the object or objects specified.\n\nParameters:\n * object - an object or table of objects to set the pasteboard to.  The following objects are recognized:\n   * a lua string, which can be received by most applications that can accept text from the clipboard\n   * `hs.styledtext` object, which can be received by most applications that can accept a raw NSAttributedString (often converted internally to RTF, RTFD, HTML, etc.)\n   * `hs.sound` object, which can be received by most applications that can accept a raw NSSound object\n   * `hs.image` object, which can be received by most applications that can accept a raw NSImage object\n   * a table with the `url` key and value representing a file or resource url, which can be received by most applications that can accept an NSURL object to represent a file or a remote resource\n   * a table with keys as described in `hs.drawing.color` to represent a color, which can be received by most applications that can accept a raw NSColor object\n   * an array of one or more of the above objects, allowing you to place more than one object onto the clipboard.\n * name - an optional string indicating the pasteboard name.  If nil or not present, defaults to the system pasteboard.\n\nReturns:\n * true or false indicating whether or not the clipboard contents were updated.\n\nNotes:\n * Most applications can only receive the first item on the clipboard.  Multiple items on a clipboard are most often used for intra-application communication where the sender and receiver are specifically written with multiple objects in mind."
    },
    "Gets or sets the polling interval (i.e. the frequency the pasteboard watcher checks the pasteboard).": {
        "prefix": "hs.pasteboard.watcher.interval([value]) -> number",
        "body": "hs.pasteboard.watcher.interval(${1:[value]})",
        "description": "Gets or sets the polling interval (i.e. the frequency the pasteboard watcher checks the pasteboard).\n\nParameters:\n * value - an optional number to set the polling interval to.\n\nReturns:\n * The polling interval as a number.\n\nNotes:\n * This only affects new watchers, not existing/running ones.\n * The default value is 0.25."
    },
    "Creates and starts a new `hs.pasteboard.watcher` object for watching for Pasteboard changes.": {
        "prefix": "hs.pasteboard.watcher.new(callbackFn[, name]) -> pasteboardWatcher",
        "body": "hs.pasteboard.watcher.new(${1:callbackFn[}, ${2:name]})",
        "description": "Creates and starts a new `hs.pasteboard.watcher` object for watching for Pasteboard changes.\n\nParameters:\n * callbackFn - A function that will be called when the Pasteboard contents has changed. It should accept one parameter:\n  * A string containing the pasteboard contents or `nil` if the contents is not a valid string.\n * name - An optional string containing the name of the pasteboard. Defaults to the system pasteboard.\n\nReturns:\n * An `hs.pasteboard.watcher` object\n\nNotes:\n * Internally this extension uses a single `NSTimer` to check for changes to the pasteboard count every half a second.\n * Example usage:\n ```lua\n generalPBWatcher = hs.pasteboard.watcher.new(function(v) print(string.format(\"General Pasteboard Contents: %s\", v)) end)\n specialPBWatcher = hs.pasteboard.watcher.new(function(v) print(string.format(\"Special Pasteboard Contents: %s\", v)) end, \"special\")\n hs.pasteboard.writeObjects(\"This is on the general pasteboard.\")\n hs.pasteboard.writeObjects(\"This is on the special pasteboard.\", \"special\")\n ```"
    },
    "Returns a boolean indicating whether or not the Pasteboard Watcher is currently running.": {
        "prefix": "hs.pasteboard.watcher:running() -> boolean",
        "body": "hs.pasteboard.watcher:running()",
        "description": "Returns a boolean indicating whether or not the Pasteboard Watcher is currently running.\n\nParameters:\n * None\n\nReturns:\n * A boolean value indicating whether or not the timer is currently running."
    },
    "Starts an `hs.pasteboard.watcher` object": {
        "prefix": "hs.pasteboard.watcher:start() -> timer",
        "body": "hs.pasteboard.watcher:start()",
        "description": "Starts an `hs.pasteboard.watcher` object\n\nParameters:\n * None\n\nReturns:\n * The `hs.pasteboard.watcher` object"
    },
    "Stops an `hs.pasteboard.watcher` object": {
        "prefix": "hs.pasteboard.watcher:stop() -> timer",
        "body": "hs.pasteboard.watcher:stop()",
        "description": "Stops an `hs.pasteboard.watcher` object\n\nParameters:\n * None\n\nReturns:\n * The `hs.pasteboard.watcher` object"
    },
    "Creates a new path watcher object": {
        "prefix": "hs.pathwatcher.new(path, fn) -> watcher",
        "body": "hs.${1:path}watcher.new(path, ${2:fn})",
        "description": "Creates a new path watcher object\n\nParameters:\n * path - A string containing the path to be watched\n * fn - A function to be called when changes are detected. It should accept two arguments:\n   * `paths`: a table containing a list of file paths that have changed\n   * `flagTables`: a table containing a list of tables denoting how each corresponding file in `paths` has changed, each containing boolean values indicating which types of events occurred; The possible keys are:\n     * mustScanSubDirs\n     * userDropped\n     * kernelDropped\n     * eventIdsWrapped\n     * historyDone\n     * rootChanged\n     * mount\n     * unmount\n     * itemCreated\n     * itemRemoved\n     * itemInodeMetaMod\n     * itemRenamed\n     * itemModified\n     * itemFinderInfoMod\n     * itemChangeOwner\n     * itemXattrMod\n     * itemIsFile\n     * itemIsDir\n     * itemIsSymlink\n     * ownEvent (OS X 10.9+)\n     * itemIsHardlink (OS X 10.10+)\n     * itemIsLastHardlink (OS X 10.10+)\n\nReturns:\n * An `hs.pathwatcher` object\n\nNotes:\n * For more information about the event flags, see [the official documentation](https://developer.apple.com/reference/coreservices/1455361-fseventstreameventflags/)"
    },
    "Starts a path watcher": {
        "prefix": "hs.pathwatcher:start()",
        "body": "hs.pathwatcher:start()",
        "description": "Starts a path watcher\n\nParameters:\n * None\n\nReturns:\n * The `hs.pathwatcher` object"
    },
    "Stops a path watcher": {
        "prefix": "hs.pathwatcher:stop()",
        "body": "hs.pathwatcher:stop()",
        "description": "Stops a path watcher\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Loads a Property List file": {
        "prefix": "hs.plist.read(filepath) -> table",
        "body": "hs.plist.read(${1:filepath})",
        "description": "Loads a Property List file\n\nParameters:\n * filepath - The path and filename of a plist file to read\n\nReturns:\n * The contents of the plist as a Lua table"
    },
    "Interpretes a property list file within a string into a table.": {
        "prefix": "hs.plist.writeString(data, [binary]) -> string | nil",
        "body": "hs.plist.writeString(${1:data}, ${2:[binary]})",
        "description": "Interpretes a property list file within a string into a table.\n\nParameters:\n * data - A Lua table containing the data to write into a plist string\n * binary - an optional boolean, default false, specifying that the resulting string should be encoded as a binary plist.\n\nReturns:\n * A string representing the data as a plist or nil if there was a problem with the date or serialization."
    },
    "Writes a Property List file": {
        "prefix": "hs.plist.write(filepath, data[, binary]) -> boolean",
        "body": "hs.plist.write(${1:filepath}, ${2:data[}, ${3:binary]})",
        "description": "Writes a Property List file\n\nParameters:\n * filepath - The path and filename of the plist file to write\n * data - A Lua table containing the data to write into the plist\n * binary - An optional boolean, if true, the plist will be written as a binary file. Defaults to false\n\nReturns:\n * A boolean, true if the plist was written successfully, otherwise false\n\nNotes:\n * Only simple types can be converted to plist items:\n  * Strings\n  * Numbers\n  * Booleans\n  * Tables\n * You should be careful when reading a plist, modifying and writing it - Hammerspoon may not be able to preserve all of the datatypes via Lua"
    },
    "A table holding the gamma values for given color temperatures; each key must be a color temperature number in K (useful values are between": {
        "prefix": "hs.redshift.COLORRAMP",
        "body": "hs.redshift.COLORRAMP",
        "description": "A table holding the gamma values for given color temperatures; each key must be a color temperature number in K (useful values are between\n1400 and 6500), and each value must be a list of 3 gamma numbers between 0 and 1 for red, green and blue respectively.\nThe table must have at least two entries (a lower and upper bound); the actual gamma values used for a given color temperature\nare linearly interpolated between the two closest entries; linear interpolation isn't particularly precise for this use case,\nso you should provide as many values as possible.\n\nNotes:\n * `hs.inspect(hs.redshift.COLORRAMP)` from the console will show you how the table is built\n * the default ramp has entries from 1000K to 10000K every 100K"
    },
    "Subscribes a callback to be notified when the color inversion status changes": {
        "prefix": "hs.redshift.invertSubscribe([id,]fn)",
        "body": "hs.redshift.invertSubscribe(${1:[id},${2:]fn})",
        "description": "Subscribes a callback to be notified when the color inversion status changes\n\nYou can use this to dynamically adjust the UI colors in your modules or configuration, if appropriate.\n\nParameters:\n * id - (optional) a string identifying the requester (usually the module name); if omitted, `fn`\n   itself will be the identifier; this identifier must be passed to `hs.redshift.invertUnsubscribe()`\n * fn - a function that will be called whenever color inversion status changes; it must accept a\n   single parameter, a string or false as per the return value of `hs.redshift.isInverted()`\n\nReturns:\n * None"
    },
    "Unsubscribes a previously subscribed color inversion change callback": {
        "prefix": "hs.redshift.invertUnsubscribe(id)",
        "body": "hs.redshift.invertUnsubscribe(${1:id})",
        "description": "Unsubscribes a previously subscribed color inversion change callback\n\nParameters:\n * id - a string identifying the requester or the callback function itself, depending on how you\n   called `hs.redshift.invertSubscribe()`\n\nReturns:\n * None"
    },
    "Checks if the colors are currently inverted": {
        "prefix": "hs.redshift.isInverted() -> string or false",
        "body": "hs.redshift.isInverted()",
        "description": "Checks if the colors are currently inverted\n\nParameters:\n * None\n\nReturns:\n * false if the colors are not currently inverted; otherwise, a string indicating the reason, one of:\n   * \"user\" for the user override (see `hs.redshift.toggleInvert()`)\n   * \"redshift-night\" if `hs.redshift.start()` was called with `invertAtNight` set to true,\n     and it's currently night time\n   * the ID string (usually the module name) provided to `hs.redshift.requestInvert()`, if another module requested color inversion"
    },
    "Sets or clears a request for color inversion": {
        "prefix": "hs.redshift.requestInvert(id,v)",
        "body": "hs.redshift.requestIn${2:v}ert(${1:id},v)",
        "description": "Sets or clears a request for color inversion\n\nParameters:\n * id - a string identifying the requester (usually the module name)\n * v - a boolean indicating whether to invert the colors (if true) or clear any previous requests (if false or nil)\n\nReturns:\n * None\n\nNotes:\n * you can use this function e.g. to automatically invert colors if the ambient light sensor reading drops below\n   a certain threshold (`hs.brightness.DDCauto()` can optionally do exactly that)\n * if the user's configuration doesn't explicitly start the redshift module, calling this will have no effect"
    },
    "Sets the schedule and (re)starts the module": {
        "prefix": "hs.redshift.start(colorTemp,nightStart,nightEnd[,transition[,invertAtNight[,windowfilterDisable[,dayColorTemp]]]])",
        "body": "hs.redshift.start(${1:colorTemp},${2:nightStart},${3:nightEnd[},${4:transition[},${5:invertAtNight[},${6:windowfilterDisable[},${7:dayColorTemp]]]]})",
        "description": "Sets the schedule and (re)starts the module\n\nParameters:\n * colorTemp - a number indicating the desired color temperature (Kelvin) during the night cycle;\n   the recommended range is between 3600K and 1400K; lower values (minimum 1000K) result in a more pronounced adjustment\n * nightStart - a string in the format \"HH:MM\" (24-hour clock) or number of seconds after midnight\n   (see `hs.timer.seconds()`) indicating when the night cycle should start\n * nightEnd - a string in the format \"HH:MM\" (24-hour clock) or number of seconds after midnight\n   (see `hs.timer.seconds()`) indicating when the night cycle should end\n * transition - (optional) a string or number of seconds (see `hs.timer.seconds()`) indicating the duration of\n   the transition to the night color temperature and back; if omitted, defaults to 1 hour\n * invertAtNight - (optional) a boolean indicating whether the colors should be inverted (in addition to\n   the color temperature shift) during the night; if omitted, defaults to false\n * windowfilterDisable - (optional) an `hs.window.filter` instance that will disable color adjustment\n   (and color inversion) whenever any window is allowed; alternatively, you can just provide a list of application\n   names (typically media apps and/or apps for color-sensitive work) and a windowfilter will be created\n   for you that disables color adjustment whenever one of these apps is focused\n * dayColorTemp - (optional) a number indicating the desired color temperature (in Kelvin) during the day cycle;\n   you can use this to maintain some degree of \"redshift\" during the day as well, or, if desired, you can\n   specify a value higher than 6500K (up to 10000K) for more bluish colors, although that's not recommended;\n   if omitted, defaults to 6500K, which disables color adjustment and restores your screens' original color profiles\n\nReturns:\n * None"
    },
    "Stops the module and disables color adjustment and color inversion": {
        "prefix": "hs.redshift.stop()",
        "body": "hs.redshift.stop()",
        "description": "Stops the module and disables color adjustment and color inversion\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Sets or clears the user override for color temperature adjustment.": {
        "prefix": "hs.redshift.toggle([v])",
        "body": "hs.redshift.toggle(${1:[v]})",
        "description": "Sets or clears the user override for color temperature adjustment.\n\nThis function should be bound to a hotkey, e.g.:\n`hs.hotkey.bind('ctrl-cmd','-','Redshift',hs.redshift.toggle)`\n\nParameters:\n * v - (optional) a boolean; if true, the override will enable color temperature adjustment on\n   the given schedule; if false, the override will disable color temperature adjustment;\n   if omitted or nil, it will toggle the override, i.e. clear it if it's currently enforced, or\n   set it to the opposite of the current color temperature adjustment status otherwise.\n\nReturns:\n * None"
    },
    "Sets or clears the user override for color inversion.": {
        "prefix": "hs.redshift.toggleInvert([v])",
        "body": "hs.redshift.toggleInvert(${1:[v]})",
        "description": "Sets or clears the user override for color inversion.\n\nThis function should be bound to a hotkey, e.g.:\n`hs.hotkey.bind('ctrl-cmd','=','Invert',hs.redshift.toggleInvert)`\n\nParameters:\n * v - (optional) a boolean; if true, the override will invert the colors no matter what; if false,\n   the override will disable color inversion no matter what; if omitted or nil, it will toggle the\n   override, i.e. clear it if it's currently enforced, or set it to the opposite of the current\n   color inversion status otherwise.\n\nReturns:\n * None"
    },
    "Transforms from the absolute coordinate space used by OSX/Hammerspoon to the screen's local": {
        "prefix": "hs.screen:absoluteToLocal(geom) -> hs.geometry object",
        "body": "hs.screen:absoluteToLocal(${1:geom})",
        "description": "Transforms from the absolute coordinate space used by OSX/Hammerspoon to the screen's local\ncoordinate space, where `0,0` is at the screen's top left corner\n\nParameters:\n * geom - an hs.geometry point or rect, or arguments to construct one\n\nReturns:\n * an hs.geometry point or rect, transformed to the screen's local coordinate space"
    },
    "Gets the current state of the screen-related accessibility settings": {
        "prefix": "hs.screen.accessibilitySettings() -> table",
        "body": "hs.screen.accessibilitySettings()",
        "description": "Gets the current state of the screen-related accessibility settings\n\nParameters:\n * None\n\nReturns:\n * A table containing the following keys, and corresponding boolean values for whether the user has enabled these options:\n   * ReduceMotion (only available on macOS 10.12 or later)\n   * ReduceTransparency\n   * IncreaseContrast\n   * InvertColors (only available on macOS 10.12 or later)\n   * DifferentiateWithoutColor"
    },
    "Returns all the screens": {
        "prefix": "hs.screen.allScreens() -> hs.screen[]",
        "body": "hs.screen.allScreens()",
        "description": "Returns all the screens\n\nParameters:\n * None\n\nReturns:\n * A table containing one or more `hs.screen` objects"
    },
    "Returns a table containing the screen modes supported by the screen. A screen mode is a combination of resolution, scaling factor and colour depth": {
        "prefix": "hs.screen:availableModes() -> table",
        "body": "hs.screen:availableModes()",
        "description": "Returns a table containing the screen modes supported by the screen. A screen mode is a combination of resolution, scaling factor and colour depth\n\nParameters:\n * None\n\nReturns:\n * A table containing the supported screen modes. The keys of the table take the form of \"1440x900@2x\" (for a HiDPI mode) or \"1680x1050@1x\" (for a native DPI mode). The values are tables which contain the keys:\n  * w - A number containing the width of the screen mode in points\n  * h - A number containing the height of the screen mode in points\n  * scale - A number containing the scaling factor of the screen mode (typically `1` for a native mode, `2` for a HiDPI mode)\n  * freq - A number containing the vertical refresh rate in Hz\n  * depth - A number containing the bit depth of the display mode\n\nNotes:\n * Prior to 0.9.83, only 32-bit colour modes would be returned, but now all colour depths are returned. This has necessitated changing the naming of the modes in the returned table.\n * \"points\" are not necessarily the same as pixels, because they take the scale factor into account (e.g. \"1440x900@2x\" is a 2880x1800 screen resolution, with a scaling factor of 2, i.e. with HiDPI pixel-doubled rendering enabled), however, they are far more useful to work with than native pixel modes, when a Retina screen is involved. For non-retina screens, points and pixels are equivalent."
    },
    "Returns a table describing the current screen mode": {
        "prefix": "hs.screen:currentMode() -> table",
        "body": "hs.screen:currentMode()",
        "description": "Returns a table describing the current screen mode\n\nParameters:\n * None\n\nReturns:\n * A table containing the current screen mode. The keys of the table are:\n  * w - A number containing the width of the screen mode in points\n  * h - A number containing the height of the screen mode in points\n  * scale - A number containing the scaling factor of the screen mode (typically `1` for a native mode, `2` for a HiDPI mode)\n  * freq - A number containing the vertical refresh rate in Hz\n  * depth - A number containing the bit depth\n  * desc - A string containing a representation of the mode as used in `hs.screen:availableModes()` - e.g. \"1920x1080@2x 60Hz 4bpp\""
    },
    "Gets/Sets the desktop background image for a screen": {
        "prefix": "hs.screen:desktopImageURL([imageURL])",
        "body": "hs.screen:desktopImageURL(${1:[imageURL]})",
        "description": "Gets/Sets the desktop background image for a screen\n\nParameters:\n * imageURL - An optional file:// URL to an image file to set as the background. If omitted, the current file URL is returned\n\nReturns:\n * the `hs.screen` object if a new URL was set, otherwise a string containing the current URL\n\nNotes:\n * If the user has set a folder of pictures to be alternated as the desktop background, the path to that folder will be returned."
    },
    "Finds screens": {
        "prefix": "hs.screen.find(hint) -> hs.screen object(s)",
        "body": "hs.screen.find(${1:hint})",
        "description": "Finds screens\n\nParameters:\n * hint - search criterion for the desired screen(s); it can be:\n  * a number as per `hs.screen:id()`\n  * a string containing the UUID of the desired screen\n  * a string pattern that matches (via `string.match`) the screen name as per `hs.screen:name()` (for convenience, the matching will be done on lowercased strings)\n  * an hs.geometry *point* object, or constructor argument, with the *x and y position* of the screen in the current layout as per `hs.screen:position()`\n  * an hs.geometry *size* object, or constructor argument, with the *resolution* of the screen as per `hs.screen:fullFrame()`\n  * an hs.geometry *rect* object, or constructor argument, with an arbitrary rect in absolute coordinates; the screen\n     containing the largest part of the rect will be returned\n\nReturns:\n * one or more hs.screen objects that match the supplied search criterion, or `nil` if none found\n\nNotes:\n * for convenience you call call this as `hs.screen(hint)`\n\nExample:\n```lua\nhs.screen(724562417) --> Color LCD - by id\nhs.screen'Dell'      --> DELL U2414M - by name\nhs.screen'0,0'       --> PHL BDM4065 - by position, same as hs.screen.primaryScreen()\nhs.screen{x=-1,y=0}  --> DELL U2414M - by position, screen to the immediate left of the primary screen\nhs.screen'3840x2160' --> PHL BDM4065 - by screen resolution\nhs.screen'-500,240 700x1300' --> DELL U2414M, by arbitrary rect\n```"
    },
    "Returns the screen frame, without the dock or menu.": {
        "prefix": "hs.screen:frame() -> hs.geometry rect",
        "body": "hs.screen:frame()",
        "description": "Returns the screen frame, without the dock or menu.\n\nParameters:\n * None\n\nReturns:\n * an hs.geometry rect describing this screen's \"usable\" frame (i.e. without the dock and menu bar) in absolute coordinates"
    },
    "Returns the absolute rect of a given unit rect within this screen": {
        "prefix": "hs.screen:fromUnitRect(unitrect) -> hs.geometry rect",
        "body": "hs.screen:fromUnitRect(${1:unitrect})",
        "description": "Returns the absolute rect of a given unit rect within this screen\n\nParameters:\n * unitrect - an hs.geometry unit rect, or arguments to construct one\n\nReturns:\n * an hs.geometry rect describing the given unit rect in absolute coordinates\n\nNotes:\n * this method is just a convenience wrapper for `hs.geometry.fromUnitRect(unitrect,this_screen:frame())`"
    },
    "Returns the screen frame, including the dock and menu.": {
        "prefix": "hs.screen:fullFrame() -> hs.geometry rect",
        "body": "hs.screen:fullFrame()",
        "description": "Returns the screen frame, including the dock and menu.\n\nParameters:\n * None\n\nReturns:\n * an hs.geometry rect describing this screen's frame in absolute coordinates"
    },
    "Gets the screen's brightness": {
        "prefix": "hs.screen:getBrightness() -> number or nil",
        "body": "hs.screen:getBrightness()",
        "description": "Gets the screen's brightness\n\nParameters:\n * None\n\nReturns:\n * A floating point number between 0 and 1, containing the current brightness level, or nil if the display does not support brightness queries"
    },
    "Gets the screen's ForceToGray setting": {
        "prefix": "hs.screen.getForceToGray() -> boolean",
        "body": "hs.screen.getForceToGray()",
        "description": "Gets the screen's ForceToGray setting\n\nParameters:\n * None\n\nReturns:\n * A boolean, true if the ForceToGray mode is set, otherwise false"
    },
    "Gets the current whitepoint and blackpoint of the screen": {
        "prefix": "hs.screen:getGamma() -> [whitepoint, blackpoint] or nil",
        "body": "hs.screen:getGamma()",
        "description": "Gets the current whitepoint and blackpoint of the screen\n\nParameters:\n * None\n\nReturns:\n * A table containing the white point and black point of the screen, or nil if an error occurred. The keys `whitepoint` and `blackpoint` each have values of a table containing the following keys, with corresponding values between 0.0 and 1.0:\n  * red\n  * green\n  * blue"
    },
    "Gets the screen's InvertedPolarity setting": {
        "prefix": "hs.screen.getInvertedPolarity() -> boolean",
        "body": "hs.screen.getInvertedPolarity()",
        "description": "Gets the screen's InvertedPolarity setting\n\nParameters:\n * None\n\nReturns:\n * A boolean, true if the InvertedPolarity mode is set, otherwise false"
    },
    "Gets the UUID of an `hs.screen` object": {
        "prefix": "hs.screen:getUUID() -> string",
        "body": "hs.screen:getUUID()",
        "description": "Gets the UUID of an `hs.screen` object\n\nParameters:\n * None\n\nReturns:\n * A string containing the UUID, or nil if an error occurred."
    },
    "Returns a screen's unique ID": {
        "prefix": "hs.screen:id() -> number",
        "body": "hs.screen:id()",
        "description": "Returns a screen's unique ID\n\nParameters:\n * None\n\nReturns:\n * A number containing the ID of the screen"
    },
    "Transforms from the screen's local coordinate space, where `0,0` is at the screen's top left corner,": {
        "prefix": "hs.screen:localToAbsolute(geom) -> hs.geometry object",
        "body": "hs.screen:localToAbsolute(${1:geom})",
        "description": "Transforms from the screen's local coordinate space, where `0,0` is at the screen's top left corner,\nto the absolute coordinate space used by OSX/Hammerspoon\n\nParameters:\n * geom - an hs.geometry point or rect, or arguments to construct one\n\nReturns:\n * an hs.geometry point or rect, transformed to the absolute coordinate space"
    },
    "Returns the 'main' screen, i.e. the one containing the currently focused window": {
        "prefix": "hs.screen.mainScreen() -> screen",
        "body": "hs.screen.mainScreen()",
        "description": "Returns the 'main' screen, i.e. the one containing the currently focused window\n\nParameters:\n * None\n\nReturns:\n * An `hs.screen` object"
    },
    "Make this screen mirror another": {
        "prefix": "hs.screen:mirrorOf(aScreen[, permanent]) -> bool",
        "body": "hs.screen:mirrorOf(${1:aScreen[}, ${2:permanent]})",
        "description": "Make this screen mirror another\n\nParameters:\n * aScreen - an hs.screen object you wish to mirror\n * permament - an optional bool, true if this should be configured permanently, false if it should apply just for this login session. Defaults to false.\n\nReturns:\n * true if the operation succeeded, otherwise false"
    },
    "Stops this screen mirroring another": {
        "prefix": "hs.screen:mirrorStop([permanent]) -> bool",
        "body": "hs.screen:mirrorStop(${1:[permanent]})",
        "description": "Stops this screen mirroring another\n\nParameters:\n * permanent - an optional bool, true if this should be configured permanently, false if it should apply just for this login session. Defaults to false.\n\nReturns:\n * true if the operation succeeded, otherwise false"
    },
    "Returns the preferred name for the screen set by the manufacturer": {
        "prefix": "hs.screen:name() -> string or nil",
        "body": "hs.screen:name()",
        "description": "Returns the preferred name for the screen set by the manufacturer\n\nParameters:\n * None\n\nReturns:\n * A string containing the name of the screen, or nil if an error occurred"
    },
    "Gets the screen 'after' this one (in arbitrary order); this method wraps around to the first screen.": {
        "prefix": "hs.screen:next() -> screen",
        "body": "hs.screen:next()",
        "description": "Gets the screen 'after' this one (in arbitrary order); this method wraps around to the first screen.\n\nParameters:\n * None\n\nReturns:\n * An `hs.screen` object"
    },
    "Return a given screen's position relative to the primary screen - see 'hs.screen.screenPositions()'": {
        "prefix": "hs.screen:position() -> x, y",
        "body": "hs.screen:position()",
        "description": "Return a given screen's position relative to the primary screen - see 'hs.screen.screenPositions()'\n\nParameters:\n * None\n\nReturns:\n * two integers indicating the screen position in the current screen arrangement, in the x and y axis respectively."
    },
    "Gets the screen 'before' this one (in arbitrary order); this method wraps around to the last screen.": {
        "prefix": "hs.screen:previous() -> screen",
        "body": "hs.screen:previous()",
        "description": "Gets the screen 'before' this one (in arbitrary order); this method wraps around to the last screen.\n\nParameters:\n * None\n\nReturns:\n * An `hs.screen` object"
    },
    "Gets the primary screen": {
        "prefix": "hs.screen.primaryScreen() -> screen",
        "body": "hs.screen.primaryScreen()",
        "description": "Gets the primary screen\n\nParameters:\n * None\n\nReturns:\n * An `hs.screen` object"
    },
    "Restore the gamma settings to defaults": {
        "prefix": "hs.screen.restoreGamma()",
        "body": "hs.screen.restoreGamma()",
        "description": "Restore the gamma settings to defaults\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This returns all displays to the gamma tables specified by the user's selected ColorSync display profiles"
    },
    "Gets/Sets the rotation of a screen": {
        "prefix": "hs.screen:rotate([degrees]) -> bool or rotation angle",
        "body": "hs.screen:rotate(${1:[degrees]})",
        "description": "Gets/Sets the rotation of a screen\n\nParameters:\n * degrees - An optional number indicating how many degrees clockwise, to rotate. If no number is provided, the current rotation will be returned. This number must be one of:\n  * 0\n  * 90\n  * 180\n  * 270\n\nReturns:\n * If the rotation is being set, a boolean, true if the operation succeeded, otherwise false. If the rotation is being queried, a number will be returned"
    },
    "Returns a list of all connected and enabled screens, along with their \"position\" relative to the primary screen": {
        "prefix": "hs.screen.screenPositions() -> table",
        "body": "hs.screen.screenPositions()",
        "description": "Returns a list of all connected and enabled screens, along with their \"position\" relative to the primary screen\n\nParameters:\n * None\n\nReturns:\n * a table where each *key* is an `hs.screen` object, and the corresponding value is a table {x=X,y=Y}, where X and Y attempt to indicate each screen's position relative to the primary screen (which is at {x=0,y=0}); so e.g. a value of {x=-1,y=0} indicates a screen immediately to the left of the primary screen, and a value of {x=0,y=2} indicates a screen positioned below the primary screen, with another screen inbetween.\n\nNotes:\n * grid-like arrangements of same-sized screens should behave consistently; but there's no guarantee of a consistent result for more \"exotic\" screen arrangements"
    },
    "Sets the screen's brightness": {
        "prefix": "hs.screen:setBrightness(brightness) -> `hs.screen` object",
        "body": "hs.screen:setBrightness(${1:brightness})",
        "description": "Sets the screen's brightness\n\nParameters:\n * brightness - A floating point number between 0 and 1\n\nReturns:\n * The `hs.screen` object"
    },
    "Sets the screen's ForceToGray mode": {
        "prefix": "hs.screen.setForceToGray(ForceToGray) -> None",
        "body": "hs.screen.set${1:ForceToGray}(ForceToGray)",
        "description": "Sets the screen's ForceToGray mode\n\nParameters:\n * ForceToGray - A boolean if ForceToGray mode should be enabled\n\nReturns:\n * None"
    },
    "Sets the current white point and black point of the screen": {
        "prefix": "hs.screen:setGamma(whitepoint, blackpoint) -> boolean",
        "body": "hs.screen:setGamma(${1:whitepoint}, ${2:blackpoint})",
        "description": "Sets the current white point and black point of the screen\n\nParameters:\n * whitepoint - A table containing color component values between 0.0 and 1.0 for each of the keys:\n  * red\n  * green\n  * blue\n * blackpoint - A table containing color component values between 0.0 and 1.0 for each of the keys:\n  * red\n  * green\n  * blue\n\nReturns:\n * A boolean, true if the gamma settings were applied, false if an error occurred\n\nNotes:\n * If the whitepoint and blackpoint specified, are very similar, it will be impossible to read the screen. You should exercise caution, and may wish to bind a hotkey to `hs.screen.restoreGamma()` when experimenting"
    },
    "Sets the screen's InvertedPolarity mode": {
        "prefix": "hs.screen.setInvertedPolarity(InvertedPolarity) -> None",
        "body": "hs.screen.set${1:InvertedPolarity}(InvertedPolarity)",
        "description": "Sets the screen's InvertedPolarity mode\n\nParameters:\n * InvertedPolarity - A boolean if InvertedPolarity mode should be enabled\n\nReturns:\n * None"
    },
    "Sets the screen to a new mode": {
        "prefix": "hs.screen:setMode(width, height, scale) -> boolean",
        "body": "hs.screen:setMode(${1:width}, ${2:height}, ${3:scale})",
        "description": "Sets the screen to a new mode\n\nParameters:\n * width - A number containing the width in points of the new mode\n * height - A number containing the height in points of the new mode\n * scale - A number containing the scaling factor of the new mode (typically 1 for native pixel resolutions, 2 for HiDPI/Retina resolutions)\n * frequency - A number containing the vertical refresh rate, in Hertz of the new mode\n * depth - A number containing the bit depth of the new mode\n\nReturns:\n * A boolean, true if the requested mode was set, otherwise false\n\nNotes:\n * The available widths/heights/scales can be seen in the output of `hs.screen:availableModes()`, however, it should be noted that the CoreGraphics subsystem seems to list more modes for a given screen than it is actually prepared to set, so you may find that seemingly valid modes still return false. It is not currently understood why this is so!"
    },
    "Sets the origin of a screen in the global display coordinate space. The origin of the main or primary display is (0,0). The new origin is placed as close as possible to the requested location, without overlapping or leaving a gap between displays. If you use this function to change the origin of a mirrored display, the display may be removed from the mirroring set.": {
        "prefix": "hs.screen:setOrigin(x, y) -> bool",
        "body": "hs.screen:setOrigin(${1:x}, ${2:y})",
        "description": "Sets the origin of a screen in the global display coordinate space. The origin of the main or primary display is (0,0). The new origin is placed as close as possible to the requested location, without overlapping or leaving a gap between displays. If you use this function to change the origin of a mirrored display, the display may be removed from the mirroring set.\n\nParameters:\n * x - The desired x-coordinate for the upper-left corner of the display.\n * y - The desired y-coordinate for the upper-left corner of the display.\n\nReturns:\n * true if the operation succeeded, otherwise false"
    },
    "Sets the screen to be the primary display (i.e. contain the menubar and dock)": {
        "prefix": "hs.screen:setPrimary() -> boolean",
        "body": "hs.screen:setPrimary()",
        "description": "Sets the screen to be the primary display (i.e. contain the menubar and dock)\n\nParameters:\n * None\n\nReturns:\n * A boolean, true if the operation succeeded, otherwise false"
    },
    "Saves an image of the screen to a JPG file": {
        "prefix": "hs.screen:shotAsJPG(filePath[, screenRect])",
        "body": "hs.screen:shotAsJPG(${1:filePath[}, ${2:screenRect]})",
        "description": "Saves an image of the screen to a JPG file\n\nParameters:\n * filePath - A string containing a file path to save the screenshot as\n * screenRect - An optional `hs.geometry` rect (or arguments for its constructor) containing a portion of the screen to capture. Defaults to the whole screen\n\nReturns:\n * None"
    },
    "Saves an image of the screen to a PNG file": {
        "prefix": "hs.screen:shotAsPNG(filePath[, screenRect])",
        "body": "hs.screen:shotAsPNG(${1:filePath[}, ${2:screenRect]})",
        "description": "Saves an image of the screen to a PNG file\n\nParameters:\n * filePath - A string containing a file path to save the screenshot as\n * screenRect - An optional `hs.geometry` rect (or arguments for its constructor) containing a portion of the screen to capture. Defaults to the whole screen\n\nReturns:\n * None"
    },
    "Captures an image of the screen": {
        "prefix": "hs.screen:snapshot([rect]) -> object",
        "body": "hs.screen:snapshot(${1:[rect]})",
        "description": "Captures an image of the screen\n\nParameters:\n * rect - An optional `rect-table` containing a portion of the screen to capture. Defaults to the whole screen\n\nReturns:\n * An `hs.image` object, or nil if an error occurred"
    },
    "If set to `true`, the methods `hs.screen:toEast()`, `:toNorth()` etc. will disregard screens that lie perpendicularly to the desired axis": {
        "prefix": "hs.screen.strictScreenInDirection",
        "body": "hs.screen.strictScreenInDirection",
        "description": "If set to `true`, the methods `hs.screen:toEast()`, `:toNorth()` etc. will disregard screens that lie perpendicularly to the desired axis"
    },
    "Gets the first screen to the east of this one, ordered by proximity to its center or a specified point.": {
        "prefix": "hs.screen:toEast() -> hs.screen object",
        "body": "hs.screen:toEast()",
        "description": "Gets the first screen to the east of this one, ordered by proximity to its center or a specified point.\n\nParameters:\n  * from - An `hs.geometry.rect` or `hs.geometry.point` object; if omitted, the geometric center of this screen will be used\n  * strict - If `true`, disregard screens that lie completely above or below this one (alternatively, set `hs.screen.strictScreenInDirection`)\n\nReturns:\n  * An `hs.screen` object, or `nil` if not found"
    },
    "Gets the first screen to the north of this one, ordered by proximity to its center or a specified point.": {
        "prefix": "hs.screen:toNorth() -> hs.screen object",
        "body": "hs.screen:toNorth()",
        "description": "Gets the first screen to the north of this one, ordered by proximity to its center or a specified point.\n\nParameters:\n  * from - An `hs.geometry.rect` or `hs.geometry.point` object; if omitted, the geometric center of this screen will be used\n  * strict - If `true`, disregard screens that lie completely to the left or to the right of this one (alternatively, set `hs.screen.strictScreenInDirection`)\n\nReturns:\n  * An `hs.screen` object, or `nil` if not found"
    },
    "Gets the first screen to the south of this one, ordered by proximity to its center or a specified point.": {
        "prefix": "hs.screen:toSouth() -> hs.screen object",
        "body": "hs.screen:toSouth()",
        "description": "Gets the first screen to the south of this one, ordered by proximity to its center or a specified point.\n\nParameters:\n  * from - An `hs.geometry.rect` or `hs.geometry.point` object; if omitted, the geometric center of this screen will be used\n  * strict - If `true`, disregard screens that lie completely to the left or to the right of this one (alternatively, set `hs.screen.strictScreenInDirection`)\n\nReturns:\n  * An `hs.screen` object, or `nil` if not found"
    },
    "Returns the unit rect of a given rect, relative to this screen": {
        "prefix": "hs.screen:toUnitRect(rect) -> hs.geometry unitrect",
        "body": "hs.screen:toUnitRect(${1:rect})",
        "description": "Returns the unit rect of a given rect, relative to this screen\n\nParameters:\n * rect - an hs.geometry rect, or arguments to construct one\n\nReturns:\n * an hs.geometry unit rect describing the given rect relative to this screen's frame\n\nNotes:\n * this method is just a convenience wrapper for `hs.geometry.toUnitRect(rect,this_screen:frame())`"
    },
    "Gets the first screen to the west of this one, ordered by proximity to its center or a specified point.": {
        "prefix": "hs.screen:toWest() -> hs.screen object",
        "body": "hs.screen:toWest()",
        "description": "Gets the first screen to the west of this one, ordered by proximity to its center or a specified point.\n\nParameters:\n  * from - An `hs.geometry.rect` or `hs.geometry.point` object; if omitted, the geometric center of this screen will be used\n  * strict - If `true`, disregard screens that lie completely above or below this one (alternatively, set `hs.screen.strictScreenInDirection`)\n\nReturns:\n  * An `hs.screen` object, or `nil` if not found"
    },
    "Creates a new screen-watcher.": {
        "prefix": "hs.screen.watcher.new(fn) -> watcher",
        "body": "hs.screen.watcher.new(${1:fn})",
        "description": "Creates a new screen-watcher.\n\nParameters:\n * The function to be called when a change in the screen layout occurs.  This function should take no arguments.\n\nReturns:\n * An `hs.screen.watcher` object\n\nNotes:\n * A screen layout change usually involves a change that is made from the Displays Preferences Panel or when a monitor is attached or removed. It can also be caused by a change in the Dock size or presence."
    },
    "Creates a new screen-watcher that is also called when the active screen changes.": {
        "prefix": "hs.screen.watcher.newWithActiveScreen(fn) -> watcher",
        "body": "hs.screen.watcher.newWithActiveScreen(${1:fn})",
        "description": "Creates a new screen-watcher that is also called when the active screen changes.\n\nParameters:\n * The function to be called when a change in the screen layout or active screen occurs.  This function can optionally take one argument, a boolean which will indicate if the change was due to a screen layout change (nil) or because the active screen changed (true).\n\nReturns:\n * An `hs.screen.watcher` object\n\nNotes:\n * A screen layout change usually involves a change that is made from the Displays Preferences Panel or when a monitor is attached or removed. It can also be caused by a change in the Dock size or presence.\n   * `nil` was chosen instead of `false` for the argument type when this type of change occurs to more closely match the previous behavior of having no argument passed to the callback function.\n * An active screen change indicates that the focused or main screen has changed when the user has \"Displays have separate spaces\" checked in the Mission Control Preferences Panel (the focused display is the display which has the active window and active menubar).\n   * Detecting a change in the active display relies on watching for the `NSWorkspaceActiveDisplayDidChangeNotification` message which is not documented by Apple.  While this message has been around at least since OS X 10.9, because it is undocumented, we cannot be positive that Apple won't remove it in a future OS X update.  Because this watcher works by listening for posted messages, should Apple remove this notification, your callback function will no longer receive messages about this change -- it won't crash or change behavior in any other way.  This documentation will be updated if this status changes.\n * Plugging in or unplugging a monitor can cause both a screen layout callback and an active screen change callback."
    },
    "Starts the screen watcher, making it so fn is called each time the screen arrangement changes": {
        "prefix": "hs.screen.watcher:start() -> watcher",
        "body": "hs.screen.watcher:start()",
        "description": "Starts the screen watcher, making it so fn is called each time the screen arrangement changes\n\nParameters:\n * None\n\nReturns:\n * The `hs.screen.watcher` object"
    },
    "Stops the screen watcher's fn from getting called until started again": {
        "prefix": "hs.screen.watcher:stop() -> watcher",
        "body": "hs.screen.watcher:stop()",
        "description": "Stops the screen watcher's fn from getting called until started again\n\nParameters:\n * None\n\nReturns:\n * The `hs.screen.watcher` object"
    },
    "Returns a table of currently connected serial ports names.": {
        "prefix": "hs.serial.availablePortNames() -> table",
        "body": "hs.serial.availablePortNames()",
        "description": "Returns a table of currently connected serial ports names.\n\nParameters:\n * None\n\nReturns:\n * A table containing the names of any connected serial port names as strings."
    },
    "Returns a table of currently connected serial ports paths.": {
        "prefix": "hs.serial.availablePortPaths() -> table",
        "body": "hs.serial.availablePortPaths()",
        "description": "Returns a table of currently connected serial ports paths.\n\nParameters:\n * None\n\nReturns:\n * A table containing the names of any connected serial port paths as strings."
    },
    "Gets or sets the baud rate for the serial port.": {
        "prefix": "hs.serial:baudRate([value], [allowNonStandardBaudRates]) -> number | serialPortObject",
        "body": "hs.serial:baudRate(${1:[value]}, ${2:[allowNonStandardBaudRates]})",
        "description": "Gets or sets the baud rate for the serial port.\n\nParameters:\n * value - An optional number to set the baud rate.\n * [allowNonStandardBaudRates] - An optional boolean to enable non-standard baud rates. Defaults to `false`.\n\nReturns:\n * If a value is specified, then this method returns the serial port object. Otherwise this method returns the baud rate as a number\n\nNotes:\n * This function supports the following standard baud rates as numbers: 300, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200, 230400.\n * If no baud rate is supplied, it defaults to 115200."
    },
    "Sets or removes a callback function for the `hs.serial` object.": {
        "prefix": "hs.serial:callback(callbackFn | nil) -> serialPortObject",
        "body": "hs.serial:callback(${1:callbackFn | nil})",
        "description": "Sets or removes a callback function for the `hs.serial` object.\n\nParameters:\n * `callbackFn` - a function to set as the callback for this `hs.serial` object.  If the value provided is `nil`, any currently existing callback function is removed.\n\nReturns:\n * The `hs.serial` object\n\nNotes:\n * The callback function should expect 4 arguments and should not return anything:\n   * `serialPortObject` - The serial port object that triggered the callback.\n   * `callbackType` - A string containing \"opened\", \"closed\", \"received\", \"removed\" or \"error\".\n   * `message` - If the `callbackType` is \"received\", then this will be the data received as a string. If the `callbackType` is \"error\", this will be the error message as a string.\n   * `hexadecimalString` - If the `callbackType` is \"received\", then this will be the data received as a hexadecimal string."
    },
    "Closes the serial port.": {
        "prefix": "hs.serial:close() -> serialPortObject",
        "body": "hs.serial:close()",
        "description": "Closes the serial port.\n\nParameters:\n * None\n\nReturns:\n * The `hs.serial` object."
    },
    "Gets or sets the number of data bits for the serial port.": {
        "prefix": "hs.serial:dataBits([value]) -> number | serialPortObject",
        "body": "hs.serial:dataBits(${1:[value]})",
        "description": "Gets or sets the number of data bits for the serial port.\n\nParameters:\n * value - An optional number to set the number of data bits. It can be 5 to 8.\n\nReturns:\n * If a value is specified, then this method returns the serial port object. Otherwise this method returns the data bits as a number.\n * The default value is 8."
    },
    "A callback that's triggered when a serial port is added or removed from the system.": {
        "prefix": "hs.serial.deviceCallback(callbackFn) -> none",
        "body": "hs.serial.deviceCallback(${1:callbackFn})",
        "description": "A callback that's triggered when a serial port is added or removed from the system.\n\nParameters:\n * callbackFn - the callback function to trigger.\n\nReturns:\n * None\n\nNotes:\n * The callback function should expect 1 argument and should not return anything:\n   * `devices` - A table containing the names of any serial ports connected as strings."
    },
    "Gets whether or not a serial port is open.": {
        "prefix": "hs.serial:isOpen() -> boolean",
        "body": "hs.serial:isOpen()",
        "description": "Gets whether or not a serial port is open.\n\nParameters:\n * None\n\nReturns:\n * `true` if open, otherwise `false`."
    },
    "Returns the name of a `hs.serial` object.": {
        "prefix": "hs.serial:name() -> string",
        "body": "hs.serial:name()",
        "description": "Returns the name of a `hs.serial` object.\n\nParameters:\n * None\n\nReturns:\n * The name as a string."
    },
    "Creates a new `hs.serial` object using the port name.": {
        "prefix": "hs.serial.newFromName(portName) -> serialPortObject",
        "body": "hs.serial.newFromName(${1:portName})",
        "description": "Creates a new `hs.serial` object using the port name.\n\nParameters:\n * portName - A string containing the port name.\n\nReturns:\n * An `hs.serial` object or `nil` if an error occured.\n\nNotes:\n * A valid port name can be found by checking `hs.serial.availablePortNames()`."
    },
    "Creates a new `hs.serial` object using a path.": {
        "prefix": "hs.serial.newFromPath(path) -> serialPortObject",
        "body": "hs.serial.newFromPath(${1:path})",
        "description": "Creates a new `hs.serial` object using a path.\n\nParameters:\n * path - A string containing the path (i.e. \"/dev/cu.usbserial\").\n\nReturns:\n * An `hs.serial` object or `nil` if an error occured.\n\nNotes:\n * A valid port name can be found by checking `hs.serial.availablePortPaths()`."
    },
    "Opens the serial port.": {
        "prefix": "hs.serial:open() -> serialPortObject | nil",
        "body": "hs.serial:open()",
        "description": "Opens the serial port.\n\nParameters:\n * None\n\nReturns:\n * The `hs.serial` object or `nil` if the port could not be opened."
    },
    "Gets or sets the parity for the serial port.": {
        "prefix": "hs.serial:parity([value]) -> string | serialPortObject",
        "body": "hs.serial:parity(${1:[value]})",
        "description": "Gets or sets the parity for the serial port.\n\nParameters:\n * value - An optional string to set the parity. It can be \"none\", \"odd\" or \"even\".\n\nReturns:\n * If a value is specified, then this method returns the serial port object. Otherwise this method returns a string value of \"none\", \"odd\" or \"even\"."
    },
    "Returns the path of a `hs.serial` object.": {
        "prefix": "hs.serial:path() -> string",
        "body": "hs.serial:path()",
        "description": "Returns the path of a `hs.serial` object.\n\nParameters:\n * None\n\nReturns:\n * The path as a string."
    },
    "Sends data via a serial port.": {
        "prefix": "hs.serial:sendData(value) -> none",
        "body": "hs.serial:sendData(${1:value})",
        "description": "Sends data via a serial port.\n\nParameters:\n * value - A string of data to send.\n\nReturns:\n * None"
    },
    "Gets or sets whether the port should echo received data.": {
        "prefix": "hs.serial:shouldEchoReceivedData([value]) -> boolean | serialPortObject",
        "body": "hs.serial:shouldEchoReceivedData(${1:[value]})",
        "description": "Gets or sets whether the port should echo received data.\n\nParameters:\n * value - An optional boolean.\n\nReturns:\n * If a value is specified, then this method returns the serial port object. Otherwise this method returns a boolean.\n * The default value is `false`."
    },
    "Gets or sets the number of stop bits for the serial port.": {
        "prefix": "hs.serial:stopBits([value]) -> number | serialPortObject",
        "body": "hs.serial:stopBits(${1:[value]})",
        "description": "Gets or sets the number of stop bits for the serial port.\n\nParameters:\n * value - An optional number to set the number of stop bits. It can be 1 or 2.\n\nReturns:\n * If a value is specified, then this method returns the serial port object. Otherwise this method returns the number of stop bits as a number.\n * The default value is 1."
    },
    "Gets or sets whether the port should use DTR/DSR Flow Control.": {
        "prefix": "hs.serial:usesDTRDSRFlowControl([value]) -> boolean | serialPortObject",
        "body": "hs.serial:usesDTRDSRFlowControl(${1:[value]})",
        "description": "Gets or sets whether the port should use DTR/DSR Flow Control.\n\nParameters:\n * value - An optional boolean.\n\nReturns:\n * If a value is specified, then this method returns the serial port object. Otherwise this method returns a boolean.\n * The default value is `false`."
    },
    "Gets or sets whether the port should use RTS/CTS Flow Control.": {
        "prefix": "hs.serial:usesRTSCTSFlowControl([value]) -> boolean | serialPortObject",
        "body": "hs.serial:usesRTSCTSFlowControl(${1:[value]})",
        "description": "Gets or sets whether the port should use RTS/CTS Flow Control.\n\nParameters:\n * value - An optional boolean.\n\nReturns:\n * If a value is specified, then this method returns the serial port object. Otherwise this method returns a boolean.\n * The default value is `false`."
    },
    "A string representing the ID of the bundle Hammerspoon's settings are stored in . You can use this with the command line tool `defaults` or other tools which allow access to the `User Defaults` of applications, to access these outside of Hammerspoon": {
        "prefix": "hs.settings.bundleID",
        "body": "hs.settings.bundleID",
        "description": "A string representing the ID of the bundle Hammerspoon's settings are stored in . You can use this with the command line tool `defaults` or other tools which allow access to the `User Defaults` of applications, to access these outside of Hammerspoon"
    },
    "Deletes a setting": {
        "prefix": "hs.settings.clear(key) -> bool",
        "body": "hs.settings.clear(${1:key})",
        "description": "Deletes a setting\n\nParameters:\n * key - A string containing the name of a setting\n\nReturns:\n * A boolean, true if the setting was deleted, otherwise false"
    },
    "A string representing the expected format of date and time when presenting the date and time as a string to `hs.setDate()`.  e.g. `os.date(hs.settings.dateFormat)`": {
        "prefix": "hs.settings.dateFormat",
        "body": "hs.settings.dateFormat",
        "description": "A string representing the expected format of date and time when presenting the date and time as a string to `hs.setDate()`.  e.g. `os.date(hs.settings.dateFormat)`"
    },
    "Loads a setting": {
        "prefix": "hs.settings.get(key) -> string or boolean or number or nil or table or binary data",
        "body": "hs.settings.get(${1:key})",
        "description": "Loads a setting\n\nParameters:\n * key - A string containing the name of the setting\n\nReturns:\n * The value of the setting\n\nNotes:\n * This function can load all of the datatypes supported by `hs.settings.set()`, `hs.settings.setData()` and `hs.settings.setDate()`"
    },
    "Gets all of the previously stored setting names": {
        "prefix": "hs.settings.getKeys() -> table",
        "body": "hs.settings.getKeys()",
        "description": "Gets all of the previously stored setting names\n\nParameters:\n * None\n\nReturns:\n * A table containing all of the settings keys in Hammerspoon's settings\n\nNotes:\n * Use `ipairs(hs.settings.getKeys())` to iterate over all available settings\n * Use `hs.settings.getKeys()[\"someKey\"]` to test for the existance of a particular key"
    },
    "Saves a setting with common datatypes": {
        "prefix": "hs.settings.set(key[, val])",
        "body": "hs.settings.set(${1:key[}, ${2:val]})",
        "description": "Saves a setting with common datatypes\n\nParameters:\n * key - A string containing the name of the setting\n * val - An optional value for the setting. Valid datatypes are:\n   * string\n   * number\n   * boolean\n   * nil\n   * table (which may contain any of the same valid datatypes)\n * if no value is provided, it is assumed to be nil\n\nReturns:\n * None\n\nNotes:\n * This function cannot set dates or raw data types, see `hs.settings.setDate()` and `hs.settings.setData()`\n * Assigning a nil value is equivalent to clearing the value with `hs.settings.clear`"
    },
    "Saves a setting with raw binary data": {
        "prefix": "hs.settings.setData(key, val)",
        "body": "hs.settings.setData(${1:key}, ${2:val})",
        "description": "Saves a setting with raw binary data\n\nParameters:\n * key - A string containing the name of the setting\n * val - Some raw binary data\n\nReturns:\n * None"
    },
    "Saves a setting with a date": {
        "prefix": "hs.settings.setDate(key, val)",
        "body": "hs.settings.setDate(${1:key}, ${2:val})",
        "description": "Saves a setting with a date\n\nParameters:\n * key - A string containing the name of the setting\n * val - A number representing seconds since `1970-01-01 00:00:00 +0000` (e.g. `os.time()`), or a string containing a date in RFC3339 format (`YYYY-MM-DD[T]HH:MM:SS[Z]`)\n\nReturns:\n * None\n\nNotes:\n * See `hs.settings.dateFormat` for a convenient representation of the RFC3339 format, to use with other time/date related functions"
    },
    "Get or set a watcher to invoke a callback when the specified settings key changes": {
        "prefix": "hs.settings.watchKey(identifier, key, [fn | nil]) -> identifier | current value",
        "body": "hs.settings.watchKey(${1:identifier}, ${2:key}, ${3:[fn | nil]})",
        "description": "Get or set a watcher to invoke a callback when the specified settings key changes\n\nParameters:\n * identifier - a required string used as an identifier for this callback\n * key        - the settings key to watch for changes to\n * fn         - the callback function to be invoked when the specified key changes.  If this is an explicit nil, removes the existing callback.\n\nReturns:\n * if a callback is set or removed, returns the identifier; otherwise returns the current callback function or nil if no callback function is currently defined.\n\nNotes:\n * the identifier is required so that multiple callbacks for the same key can be registered by separate modules; it's value doesn't affect what is being watched but does need to be unique between multiple watchers of the same key.\n\n * Does not work with keys that include a period (.) in the key name because KVO uses dot notation to specify a sequence of properties.  If you know of a way to escape periods so that they are watchable as NSUSerDefault key names, please file an issue and share!"
    },
    "The account name used by the sharing service when posting on Twitter or Sina Weibo.": {
        "prefix": "hs.sharing:accountName() -> string | nil",
        "body": "hs.sharing:accountName()",
        "description": "The account name used by the sharing service when posting on Twitter or Sina Weibo.\n\nParameters:\n * None\n\nReturns:\n * a string containing the account name used by the sharing service, or nil if the sharing service does not provide this.\n\nNotes:\n * According to the Apple API documentation, only the Twitter and Sina Weibo sharing services will set this property, but this has not been fully tested."
    },
    "Returns an alternate image, if one exists, representing the sharing service provided by this sharing object.": {
        "prefix": "hs.sharing:alternateImage() -> hs.image object | nil",
        "body": "hs.sharing:alternateImage()",
        "description": "Returns an alternate image, if one exists, representing the sharing service provided by this sharing object.\n\nParameters:\n * None\n\nReturns:\n * an hs.image object or nil, if no alternate image representation for the sharing service is defined."
    },
    "If the sharing service provides an array of the attachments included when the data was posted, this method will return an array of file URL tables of the attachments.": {
        "prefix": "hs.sharing:attachments() -> table | nil",
        "body": "hs.sharing:attachments()",
        "description": "If the sharing service provides an array of the attachments included when the data was posted, this method will return an array of file URL tables of the attachments.\n\nParameters:\n * None\n\nReturns:\n * an array (table) containing the attachment file URLs, or nil if the sharing service selected does not provide this.\n\nNotes:\n * not all sharing services will set a value for this property."
    },
    "A table containing the predefined sharing service labels defined by Apple.": {
        "prefix": "hs.sharing.builtinSharingServices[]",
        "body": "hs.sharing.builtinSharingServices",
        "description": "A table containing the predefined sharing service labels defined by Apple.\n\nThis table contains the default sharing service identifiers as identified by Apple.  Depending upon the software you have installed on your system, not all of the identifiers included here may be available on your computer and other Applications may provide sharing services with identifiers not included here.  You can determine valid identifiers for specific data types by using the [hs.sharing.shareTypesFor](#shareTypesFor) function which will list all identifiers that will work for all of the specified items, even those which do not appear in this table."
    },
    "Set or clear the callback for the sharingObject.": {
        "prefix": "hs.sharing:callback(function | nil) -> sharingObject",
        "body": "hs.sharing:callback(${1:function | nil})",
        "description": "Set or clear the callback for the sharingObject.\n\nParameters:\n * a function, or nil, to set or remove the callback for the sharingObject\n\nReturns:\n * the sharingObject\n\nNotes:\n * the callback should expect 3 or 4 arguments and return no results.  The arguments will be as follows:\n   * the sharingObject itself\n   * the callback message, which will be a string equal to one of the following:\n     * \"didFail\"   - an error occurred while attempting to share the items\n     * \"didShare\"  - the sharing service has finished sharing the items\n     * \"willShare\" - the sharing service is about to start sharing the items; occurs before sharing actually begins\n   * an array (table) containing the items being shared; if the message is \"didFail\" or \"didShare\", the items may be in a different order or converted to a different internal type to facilitate sharing.\n   * if the message is \"didFail\", the fourth argument will be a localized description of the error that occurred."
    },
    "Returns a boolean specifying whether or not all of the items specified can be shared with the sharing service represented by the sharingObject.": {
        "prefix": "hs.sharing:canShareItems(items) -> boolean",
        "body": "hs.sharing:canShareItems(${1:items})",
        "description": "Returns a boolean specifying whether or not all of the items specified can be shared with the sharing service represented by the sharingObject.\n\nParameters:\n * items - an array (table) or list of items separated by commas which are to be shared by the sharing service\n\nReturns:\n * a boolean value indicating whether or not all of the specified items can be shared with the sharing service represented by the sharingObject."
    },
    "Returns a table representing a file URL for the path specified.": {
        "prefix": "hs.sharing.fileURL(path) -> table",
        "body": "hs.sharing.fileURL(${1:path})",
        "description": "Returns a table representing a file URL for the path specified.\n\nParameters:\n * path - a string specifying a path to represent as a file URL.\n\nReturns:\n * a table containing the necessary labels for converting the specified path into a URL as required by the macOS APIs.\n\nNotes:\n * this function is a wrapper to [hs.sharing.URL](#URL) which sets the second argument to `true` for you.\n * see [hs.sharing.URL](#URL) for more information about the table format returned by this function."
    },
    "Returns an image, if one exists, representing the sharing service provided by this sharing object.": {
        "prefix": "hs.sharing:image() -> hs.image object | nil",
        "body": "hs.sharing:image()",
        "description": "Returns an image, if one exists, representing the sharing service provided by this sharing object.\n\nParameters:\n * None\n\nReturns:\n * an hs.image object or nil, if no image representation for the sharing service is defined."
    },
    "If the sharing service provides the message body that was posted when sharing has completed, this method will return the message body as a string.": {
        "prefix": "hs.sharing:messageBody() -> string | nil",
        "body": "hs.sharing:messageBody()",
        "description": "If the sharing service provides the message body that was posted when sharing has completed, this method will return the message body as a string.\n\nParameters:\n * None\n\nReturns:\n * a string containing the message body, or nil if the sharing service selected does not provide this.\n\nNotes:\n * not all sharing services will set a value for this property."
    },
    "Creates a new sharing object of the type specified by the identifier provided.": {
        "prefix": "hs.sharing.newShare(type) -> sharingObject",
        "body": "hs.sharing.newShare(${1:type})",
        "description": "Creates a new sharing object of the type specified by the identifier provided.\n\nParameters:\n * type - a string specifying a sharing type identifier as listed in the [hs.sharing.builtinSharingServices](#builtinSharingServices) table or returned by the [hs.sharing.shareTypesFor](#shareTypesFor).\n\nReturns:\n * a sharingObject or nil if the type identifier cannot be created on this system"
    },
    "If the sharing service provides a permanent link to the post when sharing has completed, this method will return the corresponding URL.": {
        "prefix": "hs.sharing:permanentLink() -> URL table | nil",
        "body": "hs.sharing:permanentLink()",
        "description": "If the sharing service provides a permanent link to the post when sharing has completed, this method will return the corresponding URL.\n\nParameters:\n * None\n\nReturns:\n * the URL for the permanent link, or nil if the sharing service selected does not provide this.\n\nNotes:\n * not all sharing services will set a value for this property."
    },
    "Get or set the subject to be used when the sharing service performs its sharing method.": {
        "prefix": "hs.sharing:subject([subject]) -> current value | sharingObject",
        "body": "hs.sharing:subject(${1:[subject]})",
        "description": "Get or set the subject to be used when the sharing service performs its sharing method.\n\nParameters:\n * subject - an optional string specifying the subject for the posting of the shared content\n\nReturns:\n * if an argument is provided, returns the sharingObject; otherwise returns the current value.\n\nNotes:\n * not all sharing services will make use of the value set by this method."
    },
    "The service identifier for the sharing service represented by the sharingObject.": {
        "prefix": "hs.sharing:serviceName() -> string",
        "body": "hs.sharing:serviceName()",
        "description": "The service identifier for the sharing service represented by the sharingObject.\n\nParameters:\n * None\n\nReturns:\n * a string containing the identifier for the sharing service.\n\nNotes:\n * this string will match the identifier used to create the sharing service object with [hs.sharing.newShare](#newShare)"
    },
    "Shares the items specified with the sharing service represented by the sharingObject.": {
        "prefix": "hs.sharing:shareItems(items) -> sharingObject",
        "body": "hs.sharing:shareItems(${1:items})",
        "description": "Shares the items specified with the sharing service represented by the sharingObject.\n\nParameters:\n * items - an array (table) or list of items separated by commas which are to be shared by the sharing service\n\nReturns:\n * the sharingObject, or nil if one or more of the items cannot be shared with the sharing service represented by the sharingObject.\n\nNotes:\n * You can check to see if all of your items can be shared with the [hs.sharing:canShareItems](#canShareItems) method."
    },
    "Returns a table containing the sharing service identifiers which can share the items specified.": {
        "prefix": "hs.sharing.shareTypesFor(items) -> identifiersTable",
        "body": "hs.sharing.shareTypesFor(${1:items})",
        "description": "Returns a table containing the sharing service identifiers which can share the items specified.\n\nParameters:\n * items - an array (table) or list of items separated by commas which you wish to share with this module.\n\nReturns:\n * an array (table) containing strings which identify sharing service identifiers which may be used by the [hs.sharing.newShare](#newShare) constructor to share the specified data.\n\nNotes:\n * this function is intended to be used to determine the identifiers for sharing services available on your computer and that may not be included in the [hs.sharing.builtinSharingServices](#builtinSharingServices) table."
    },
    "The title for the sharing service represented by the sharingObject.": {
        "prefix": "hs.sharing:title() -> string",
        "body": "hs.sharing:title()",
        "description": "The title for the sharing service represented by the sharingObject.\n\nParameters:\n * None\n\nReturns:\n * a string containing the title of the sharing service.\n\nNotes:\n * this string differs from the identifier used to create the sharing service object with [hs.sharing.newShare](#newShare) and is intended to provide a more friendly label for the service if you need to list or refer to it elsewhere."
    },
    "Returns a table representing the URL specified.": {
        "prefix": "hs.sharing.URL(URL, [fileURL]) -> table",
        "body": "hs.sharing.${1:URL}(URL, ${2:[fileURL]})",
        "description": "Returns a table representing the URL specified.\n\nParameters:\n * URL     - a string or table specifying the URL.\n * fileURL - an optional boolean, default `false`, specifying whether or not the URL is supposed to represent a file on the local computer.\n\nReturns:\n * a table containing the necessary labels for representing the specified URL as required by the macOS APIs.\n\nNotes:\n * If the URL is specified as a table, it is expected to contain a `url` key with a string value specifying a proper schema and resource locator.\n\n * Because macOS requires URLs to be represented as a specific object type which has no exact equivalent in Lua, Hammerspoon uses a table with specific keys to allow proper identification of a URL when included as an argument or result type.  Use this function or the [hs.sharing.fileURL](#fileURL) wrapper function when specifying a URL to ensure that the proper keys are defined.\n * At present, the following keys are defined for a URL table (additional keys may be added in the future if future Hammerspoon modules require them to more completely utilize the macOS NSURL class, but these will not change):\n   * url           - a string containing the URL with a proper schema and resource locator\n   * filePath      = a string specifying the actual path to the file in case the url is a file reference URL.  Note that setting this field with this method will be silently ignored; the field is automatically inserted if appropriate when returning an NSURL object to lua.\n   * __luaSkinType - a string specifying the macOS type this table represents when converted into an Objective-C type"
    },
    "Connects an unconnected [`hs.socket`](#new) instance": {
        "prefix": "hs.socket:connect({host, port}|path[, fn]) -> self or nil",
        "body": "hs.socket:connect(${1:{host}, ${2:port}|path[}, ${3:fn]})",
        "description": "Connects an unconnected [`hs.socket`](#new) instance\n\nParameters:\n * host - A string containing the hostname or IP address\n * port - A port number [1-65535]\n * path - A string containing the path to the Unix domain socket\n * fn - An optional single-use callback function to execute after establishing the connection. Receives no parameters\n\nReturns:\n * The [`hs.socket`](#new) object or `nil` if an error occurred\n\nNotes:\n * Either a host/port pair OR a Unix domain socket path must be supplied. If no port is passed, the first param is assumed to be a path to the socket file\n"
    },
    "Returns the connection status of the [`hs.socket`](#new) instance": {
        "prefix": "hs.socket:connected() -> bool",
        "body": "hs.socket:connected()",
        "description": "Returns the connection status of the [`hs.socket`](#new) instance\n\nParameters:\n * None\n\nReturns:\n * `true` if connected, otherwise `false`\n"
    },
    "Returns the number of connections to the socket, which is at most 1 for default (non-listening) sockets": {
        "prefix": "hs.socket:connections() -> number",
        "body": "hs.socket:connections()",
        "description": "Returns the number of connections to the socket, which is at most 1 for default (non-listening) sockets\n\nParameters:\n * None\n\nReturns:\n * The number of connections to the socket\n"
    },
    "Disconnects the [`hs.socket`](#new) instance, freeing it for reuse": {
        "prefix": "hs.socket:disconnect() -> self",
        "body": "hs.socket:disconnect()",
        "description": "Disconnects the [`hs.socket`](#new) instance, freeing it for reuse\n\nParameters:\n * None\n\nReturns:\n * The [`hs.socket`](#new) object\n\nNotes:\n * If called on a listening socket with multiple connections, each client is disconnected\n"
    },
    "Returns information on the [`hs.socket`](#new) instance": {
        "prefix": "hs.socket:info() -> table",
        "body": "hs.socket:info()",
        "description": "Returns information on the [`hs.socket`](#new) instance\n\nParameters:\n * None\n\nReturns:\n * A table containing the following keys:\n  * connectedAddress - `string` (`sockaddr` struct)\n  * connectedHost - `string`\n  * connectedPort - `number`\n  * connectedURL - `string`\n  * connections - `number`\n  * isConnected - `boolean`\n  * isDisconnected - `boolean`\n  * isIPv4 - `boolean`\n  * isIPv4Enabled - `boolean`\n  * isIPv4PreferredOverIPv6 - `boolean`\n  * isIPv6 - `boolean`\n  * isIPv6Enabled - `boolean`\n  * isSecure - `boolean`\n  * localAddress - `string` (`sockaddr` struct)\n  * localHost - `string`\n  * localPort - `number`\n  * timeout - `number`\n  * unixSocketPath - `string`\n  * userData - `string`\n"
    },
    "Binds an unconnected [`hs.socket`](#new) instance to a port or path (Unix domain socket) for listening": {
        "prefix": "hs.socket:listen(port|path) -> self or nil",
        "body": "hs.socket:listen(${1:port|path})",
        "description": "Binds an unconnected [`hs.socket`](#new) instance to a port or path (Unix domain socket) for listening\n\nParameters:\n * port - A port number [0-65535]. Ports [1-1023] are privileged. Port 0 allows the OS to select any available port\n * path - A string containing the path to the Unix domain socket\n\nReturns:\n * The [`hs.socket`](#new) object or `nil` if an error occurred\n"
    },
    "Creates an unconnected asynchronous TCP socket object": {
        "prefix": "hs.socket.new([fn]) -> hs.socket object",
        "body": "hs.socket.new(${1:[fn]})",
        "description": "Creates an unconnected asynchronous TCP socket object\n\nParameters:\n * fn - An optional [callback function](#setCallback) for reading data from the socket, settable here for convenience\n\nReturns:\n * An [`hs.socket`](#new) object\n"
    },
    "Parses a binary socket address structure into a readable table": {
        "prefix": "hs.socket.parseAddress(sockaddr) -> table or nil",
        "body": "hs.socket.parseAddress(${1:sockaddr})",
        "description": "Parses a binary socket address structure into a readable table\n\nParameters:\n * sockaddr - A binary socket address structure, usually obtained from the [`info`](#info) method or in [`hs.socket.udp`](./hs.socket.udp.html)'s [read callback](./hs.socket.udp.html#setCallback)\n\nReturns:\n * A table describing the address with the following keys or `nil`:\n  * host - A string containing the host IP\n  * port - A number containing the port\n  * addressFamily - A number containing the address family\n\nNotes:\n * Some address family definitions from `<sys/socket.h>`:\n\naddress family | number | description\n:--- | :--- | :\nAF_UNSPEC | 0 | unspecified\nAF_UNIX | 1 | local to host (pipes)\nAF_LOCAL | AF_UNIX | backward compatibility\nAF_INET | 2 | internetwork: UDP, TCP, etc.\nAF_NS | 6 | XEROX NS protocols\nAF_CCITT | 10 | CCITT protocols, X.25 etc\nAF_APPLETALK | 16 | Apple Talk\nAF_ROUTE | 17 | Internal Routing Protocol\nAF_LINK | 18 | Link layer interface\nAF_INET6 | 30 | IPv6\n"
    },
    "Read data from the socket. Results are passed to the [callback function](#setCallback), which must be set to use this method": {
        "prefix": "hs.socket:read(delimiter[, tag]) -> self or nil",
        "body": "hs.socket:read(${1:delimiter[}, ${2:tag]})",
        "description": "Read data from the socket. Results are passed to the [callback function](#setCallback), which must be set to use this method\n\nParameters:\n * delimiter - Either a number of bytes to read, or a string delimiter such as \"&#92;n\" or \"&#92;r&#92;n\". Data is read up to and including the delimiter\n * tag - An optional integer to assist with labeling reads. It is passed to the callback to assist with implementing [state machines](https://github.com/robbiehanson/CocoaAsyncSocket/wiki/Intro_GCDAsyncSocket#reading--writing) for processing complex protocols\n\nReturns:\n * The [`hs.socket`](#new) object or `nil` if an error occured\n\nNotes:\n * If called on a listening socket with multiple connections, data is read from each of them\n"
    },
    "Alias for [`hs.socket:read`](#read)": {
        "prefix": "hs.socket:receive(delimiter[, tag]) -> self",
        "body": "hs.socket:receive(${1:delimiter[}, ${2:tag]})",
        "description": "Alias for [`hs.socket:read`](#read)\n"
    },
    "Alias for [`hs.socket:write`](#write)": {
        "prefix": "hs.socket:send(message[, tag]) -> self",
        "body": "hs.socket:send(${1:message[}, ${2:tag]})",
        "description": "Alias for [`hs.socket:write`](#write)\n"
    },
    "Creates and binds an [`hs.socket`](#new) instance to a port or path (Unix domain socket) for listening": {
        "prefix": "hs.socket.server(port|path[, fn]) -> hs.socket object",
        "body": "hs.socket.server(${1:port|path[}, ${2:fn]})",
        "description": "Creates and binds an [`hs.socket`](#new) instance to a port or path (Unix domain socket) for listening\n\nParameters:\n * port - A port number [0-65535]. Ports [1-1023] are privileged. Port 0 allows the OS to select any available port\n * path - A string containing the path to the Unix domain socket\n * fn - An optional [callback function](#setCallback) for reading data from the socket, settable here for convenience\n\nReturns:\n * An [`hs.socket`](#new) object\n"
    },
    "Sets the read callback for the [`hs.socket`](#new) instance. Must be set to read data from the socket": {
        "prefix": "hs.socket:setCallback([fn]) -> self",
        "body": "hs.socket:setCallback(${1:[fn]})",
        "description": "Sets the read callback for the [`hs.socket`](#new) instance. Must be set to read data from the socket\n\nThe callback receives 2 parameters:\n * data - The data read from the socket as a string\n * tag - The integer tag associated with the read call, which defaults to -1\n\nParameters:\n * fn - An optional callback function to process data read from the socket. `nil` or no argument clears the callback\n\nReturns:\n * The [`hs.socket`](#new) object\n"
    },
    "Sets the timeout for the socket operations. If the timeout value is negative, the operations will not use a timeout, which is the default": {
        "prefix": "hs.socket.udp:setTimeout(timeout) -> self",
        "body": "hs.socket.udp:setTimeout(${1:timeout})",
        "description": "Sets the timeout for the socket operations. If the timeout value is negative, the operations will not use a timeout, which is the default\n\nParameters:\n * timeout - A number containing the timeout duration, in seconds\n\nReturns:\n * The [`hs.socket.udp`](#new) object\n"
    },
    "Secures the socket with TLS. The socket will disconnect immediately if TLS negotiation fails": {
        "prefix": "hs.socket:startTLS([verify][, peerName]) -> self",
        "body": "hs.socket:startTLS(${1:[verify][}, ${2:peerName]})",
        "description": "Secures the socket with TLS. The socket will disconnect immediately if TLS negotiation fails\n\nParameters:\n * verify - An optional boolean that, if `false`, allows TLS handshaking with servers with self-signed certificates and does not evaluate the chain of trust. Defaults to `true` and omitted if `peerName` is supplied\n * peerName - An optional string containing the fully qualified domain name of the peer to validate against \u2014 for example, `store.apple.com`. It should match the name in the X.509 certificate given by the remote party. See notes below\n\nReturns:\n * The [`hs.socket`](#new) object\n\nNotes:\n* IMPORTANT SECURITY NOTE:\nThe default settings will check to make sure the remote party's certificate is signed by a\ntrusted 3rd party certificate agency (e.g. verisign) and that the certificate is not expired.\nHowever it will not verify the name on the certificate unless you\ngive it a name to verify against via `peerName`.\nThe security implications of this are important to understand.\nImagine you are attempting to create a secure connection to MySecureServer.com,\nbut your socket gets directed to MaliciousServer.com because of a hacked DNS server.\nIf you simply use the default settings, and MaliciousServer.com has a valid certificate,\nthe default settings will not detect any problems since the certificate is valid.\nTo properly secure your connection in this particular scenario you\nshould set `peerName` to \"MySecureServer.com\".\n"
    },
    "Timeout for the socket operations, in seconds. New [`hs.socket`](#new) objects will be created with this timeout value, but can individually change it with the [`setTimeout`](#setTimeout) method": {
        "prefix": "hs.socket.timeout",
        "body": "hs.socket.timeout",
        "description": "Timeout for the socket operations, in seconds. New [`hs.socket`](#new) objects will be created with this timeout value, but can individually change it with the [`setTimeout`](#setTimeout) method\n\nIf the timeout value is negative, the operations will not use a timeout. The default value is -1\n"
    },
    "Write data to the socket": {
        "prefix": "hs.socket:write(message[, tag][, fn]) -> self",
        "body": "hs.socket:write(${1:message[}, ${2:tag][}, ${3:fn]})",
        "description": "Write data to the socket\n\nParameters:\n * message - A string containing data to be sent on the socket\n * tag - An optional integer to assist with labeling writes\n * fn - An optional single-use callback function to execute after writing data to the socket. Receives the tag parameter\n\nReturns:\n * The [`hs.socket`](#new) object\n\nNotes:\n * If called on a listening socket with multiple connections, data is broadcasted to all connected sockets\n"
    },
    "Enables broadcasting on the underlying socket": {
        "prefix": "hs.socket.udp:broadcast([flag]) -> self or nil",
        "body": "hs.socket.udp:broadcast(${1:[flag]})",
        "description": "Enables broadcasting on the underlying socket\n\nParameters:\n * flag - An optional boolean: `true` to enable broadcasting, `false` to disable it. Defaults to `true`\n\nReturns:\n * The [`hs.socket.udp`](#new) object or `nil` if an error occurred\n\nNotes:\n * By default, the underlying socket in the OS will not allow you to send broadcast messages\n * In order to send broadcast messages, you need to enable this functionality in the socket\n * A broadcast is a UDP message to addresses like \"192.168.255.255\" or \"255.255.255.255\" that is delivered to every host on the network.\n * The reason this is generally disabled by default (by the OS) is to prevent accidental broadcast messages from flooding the network.\n"
    },
    "Immediately closes the underlying socket, freeing the [`hs.socket.udp`](#new) instance for reuse. Any pending send operations are discarded": {
        "prefix": "hs.socket.udp:close() -> self",
        "body": "hs.socket.udp:close()",
        "description": "Immediately closes the underlying socket, freeing the [`hs.socket.udp`](#new) instance for reuse. Any pending send operations are discarded\n\nParameters:\n * None\n\nReturns:\n * The [`hs.socket.udp`](#new) object\n"
    },
    "Returns the closed status of the [`hs.socket.udp`](#new) instance": {
        "prefix": "hs.socket.udp:closed() -> bool",
        "body": "hs.socket.udp:closed()",
        "description": "Returns the closed status of the [`hs.socket.udp`](#new) instance\n\nParameters:\n * None\n\nReturns:\n * `true` if closed, otherwise `false`\n\nNotes:\n * UDP sockets are typically meant to be connectionless\n * Sending a packet anywhere, regardless of whether or not the destination receives it, opens the socket until it is explicitly closed\n * An active listening socket will not be closed, but will not be 'connected' unless the [connect](#connect) method has been called\n"
    },
    "Connects an unconnected [`hs.socket.udp`](#new) instance": {
        "prefix": "hs.socket.udp:connect(host, port[, fn]) -> self or nil",
        "body": "hs.socket.udp:connect(${1:host}, ${2:port[}, ${3:fn]})",
        "description": "Connects an unconnected [`hs.socket.udp`](#new) instance\n\nParameters:\n * host - A string containing the hostname or IP address\n * port - A port number [1-65535]\n * fn - An optional single-use callback function to execute after establishing the connection. Receives no parameters\n\nReturns:\n * The [`hs.socket.udp`](#new) object or `nil` if an error occured\n\nNotes:\n* By design, UDP is a connectionless protocol, and connecting is not needed\n* Choosing to connect to a specific host/port has the following effect:\n * You will only be able to send data to the connected host/port\n * You will only be able to receive data from the connected host/port\n * You will receive ICMP messages that come from the connected host/port, such as \"connection refused\"\n* The actual process of connecting a UDP socket does not result in any communication on the socket. It simply changes the internal state of the socket\n* You cannot bind a socket after it has been connected\n* You can only connect a socket once\n"
    },
    "Returns the connection status of the [`hs.socket.udp`](#new) instance": {
        "prefix": "hs.socket.udp:connected() -> bool",
        "body": "hs.socket.udp:connected()",
        "description": "Returns the connection status of the [`hs.socket.udp`](#new) instance\n\nParameters:\n * None\n\nReturns:\n * `true` if connected, otherwise `false`\n\nNotes:\n * UDP sockets are typically meant to be connectionless\n * This method will only return `true` if the [`connect`](#connect) method has been explicitly called\n"
    },
    "Enables or disables IPv4 or IPv6 on the underlying socket. By default, both are enabled": {
        "prefix": "hs.socket.udp:enableIPv(version[, flag]) -> self or nil",
        "body": "hs.socket.udp:enableIPv(${1:version[}, ${2:flag]})",
        "description": "Enables or disables IPv4 or IPv6 on the underlying socket. By default, both are enabled\n\nParameters:\n * version - A number containing the IP version (4 or 6) to enable or disable\n * flag - A boolean: `true` to enable the chosen IP version, `false` to disable it. Defaults to `true`\n\nReturns:\n * The [`hs.socket.udp`](#new) object or `nil` if an error occurred\n\nNotes:\n * Must be called before binding the socket. If you want to create an IPv6-only server, do something like:\n  * `hs.socket.udp.new(callback):enableIPv(4, false):listen(port):receive()`\n * The convenience constructor [`hs.socket.server`](#server) will automatically bind the socket and requires closing and relistening to use this method\n"
    },
    "Returns information on the [`hs.socket.udp`](#new) instance": {
        "prefix": "hs.socket.udp:info() -> table",
        "body": "hs.socket.udp:info()",
        "description": "Returns information on the [`hs.socket.udp`](#new) instance\n\nParameters:\n * None\n\nReturns:\n * A table containing the following keys:\n  * connectedAddress - `string` (`sockaddr` struct)\n  * connectedHost - `string`\n  * connectedPort - `number`\n  * isClosed - `boolean`\n  * isConnected - `boolean`\n  * isIPv4 - `boolean`\n  * isIPv4Enabled - `boolean`\n  * isIPv4Preferred - `boolean`\n  * isIPv6 - `boolean`\n  * isIPv6Enabled - `boolean`\n  * isIPv6Preferred - `boolean`\n  * isIPVersionNeutral - `boolean`\n  * localAddress - `string` (`sockaddr` struct)\n  * localAddress_IPv4 - `string` (`sockaddr` struct)\n  * localAddress_IPv6 - `string` (`sockaddr` struct)\n  * localHost - `string`\n  * localHost_IPv4 - `string`\n  * localHost_IPv6 - `string`\n  * localPort - `number`\n  * localPort_IPv4 - `number`\n  * localPort_IPv6 - `number`\n  * maxReceiveIPv4BufferSize - `number`\n  * maxReceiveIPv6BufferSize - `number`\n  * timeout - `number`\n  * userData - `string`\n"
    },
    "Binds an unconnected [`hs.socket.udp`](#new) instance to a port for listening": {
        "prefix": "hs.socket.udp:listen(port) -> self or nil",
        "body": "hs.socket.udp:listen(${1:port})",
        "description": "Binds an unconnected [`hs.socket.udp`](#new) instance to a port for listening\n\nParameters:\n * port - A port number [0-65535]. Ports [1-1023] are privileged. Port 0 allows the OS to select any available port\n\nReturns:\n * The [`hs.socket.udp`](#new) object or `nil` if an error occured\n"
    },
    "Creates an unconnected asynchronous UDP socket object": {
        "prefix": "hs.socket.udp.new([fn]) -> hs.socket.udp object",
        "body": "hs.socket.udp.new(${1:[fn]})",
        "description": "Creates an unconnected asynchronous UDP socket object\n\nParameters:\n * fn - An optional [callback function](#setCallback) for reading data from the socket, settable here for convenience\n\nReturns:\n * An [`hs.socket.udp`](#new) object\n"
    },
    "Alias for [`hs.socket.parseAddress`](./hs.socket.html#parseAddress)": {
        "prefix": "hs.socket.udp.parseAddress(sockaddr) -> table or nil",
        "body": "hs.socket.udp.parseAddress(${1:sockaddr})",
        "description": "Alias for [`hs.socket.parseAddress`](./hs.socket.html#parseAddress)\n"
    },
    "Suspends reading of packets from the socket. Call one of the receive methods to resume": {
        "prefix": "hs.socket.udp:pause() -> self",
        "body": "hs.socket.udp:pause()",
        "description": "Suspends reading of packets from the socket. Call one of the receive methods to resume\n\nParameters:\n * None\n\nReturns:\n * The [`hs.socket.udp`](#new) object\n"
    },
    "Sets the preferred IP version: IPv4, IPv6, or neutral (first to resolve)": {
        "prefix": "hs.socket.udp:preferIPv([version]) -> self",
        "body": "hs.socket.udp:preferIPv(${1:[version]})",
        "description": "Sets the preferred IP version: IPv4, IPv6, or neutral (first to resolve)\n\nParameters:\n * version - An optional number containing the IP version to prefer. Anything but 4 or 6 else sets the default neutral behavior\n\nReturns:\n * The [`hs.socket.udp`](#new) object\n\nNotes:\n * If a DNS lookup returns only IPv4 results, the socket will automatically use IPv4\n * If a DNS lookup returns only IPv6 results, the socket will automatically use IPv6\n * If a DNS lookup returns both IPv4 and IPv6 results, then the protocol used depends on the configured preference\n"
    },
    "Alias for [`hs.socket.udp:receive`](#receive)": {
        "prefix": "hs.socket.udp:read(delimiter[, tag]) -> self",
        "body": "hs.socket.udp:read(${1:delimiter[}, ${2:tag]})",
        "description": "Alias for [`hs.socket.udp:receive`](#receive)\n"
    },
    "Alias for [`hs.socket.udp:receiveOne`](#receiveOne)": {
        "prefix": "hs.socket.udp:readOne(delimiter[, tag]) -> self",
        "body": "hs.socket.udp:readOne(${1:delimiter[}, ${2:tag]})",
        "description": "Alias for [`hs.socket.udp:receiveOne`](#receiveOne)\n"
    },
    "Reads packets from the socket as they arrive. Results are passed to the [callback function](#setCallback), which must be set to use this method": {
        "prefix": "hs.socket.udp:receive([fn]) -> self or nil",
        "body": "hs.socket.udp:receive(${1:[fn]})",
        "description": "Reads packets from the socket as they arrive. Results are passed to the [callback function](#setCallback), which must be set to use this method\n\nParameters:\n * fn - Optionally supply the [read callback](#setCallback) here\n\nReturns:\n * The [`hs.socket.udp`](#new) object or `nil` if an error occured\n\nNotes:\n * There are two modes of operation for receiving packets: one-at-a-time & continuous\n * In one-at-a-time mode, you call receiveOne every time you are ready process an incoming UDP packet\n * Receiving packets one-at-a-time may be better suited for implementing certain state machine code where your state machine may not always be ready to process incoming packets\n * In continuous mode, the callback is invoked immediately every time incoming udp packets are received\n * Receiving packets continuously is better suited to real-time streaming applications\n * You may switch back and forth between one-at-a-time mode and continuous mode\n * If the socket is currently in one-at-a-time mode, calling this method will switch it to continuous mode\n"
    },
    "Reads a single packet from the socket. Results are passed to the [callback function](#setCallback), which must be set to use this method": {
        "prefix": "hs.socket.udp:receiveOne([fn]) -> self or nil",
        "body": "hs.socket.udp:receiveOne(${1:[fn]})",
        "description": "Reads a single packet from the socket. Results are passed to the [callback function](#setCallback), which must be set to use this method\n\nParameters:\n * fn - Optionally supply the [read callback](#setCallback) here\n\nReturns:\n * The [`hs.socket.udp`](#new) object or `nil` if an error occured\n\nNotes:\n * There are two modes of operation for receiving packets: one-at-a-time & continuous\n * In one-at-a-time mode, you call receiveOne every time you are ready process an incoming UDP packet\n * Receiving packets one-at-a-time may be better suited for implementing certain state machine code where your state machine may not always be ready to process incoming packets\n * In continuous mode, the callback is invoked immediately every time incoming udp packets are received\n * Receiving packets continuously is better suited to real-time streaming applications\n * You may switch back and forth between one-at-a-time mode and continuous mode\n * If the socket is currently in continuous mode, calling this method will switch it to one-at-a-time mode\n"
    },
    "Enables port reuse on the underlying socket": {
        "prefix": "hs.socket.udp:reusePort([flag]) -> self or nil",
        "body": "hs.socket.udp:reusePort(${1:[flag]})",
        "description": "Enables port reuse on the underlying socket\n\nParameters:\n * flag - An optional boolean: `true` to enable port reuse, `false` to disable it. Defaults to `true`\n\nReturns:\n * The [`hs.socket.udp`](#new) object or `nil` if an error occurred\n\nNotes:\n * By default, only one socket can be bound to a given IP address+port at a time\n * To enable multiple processes to simultaneously bind to the same address+port, you need to enable this functionality in the socket\n * All processes that wish to use the address+port simultaneously must all enable reuse port on the socket bound to that port\n * Must be called before binding the socket\n"
    },
    "Sends a packet to the destination address": {
        "prefix": "hs.socket.udp:send(message, host, port[, tag][, fn]) -> self",
        "body": "hs.socket.udp:send(${1:message}, ${2:host}, ${3:port[}, ${4:tag][}, ${5:fn]})",
        "description": "Sends a packet to the destination address\n\nParameters:\n * message - A string containing data to be sent on the socket\n * host - A string containing the hostname or IP address\n * port - A port number [1-65535]\n * tag - An optional integer to assist with labeling writes\n * fn - An optional single-use callback function to execute after sending the packet. Receives the tag parameter\n\nReturns:\n * The [`hs.socket.udp`](#new) object\n\nNotes:\n * For non-connected sockets, the remote destination is specified for each packet\n * If the socket has been explicitly connected with [`connect`](#connect), only the message parameter and an optional tag and/or write callback can be supplied\n * Recall that connecting is optional for a UDP socket\n * For connected sockets, data can only be sent to the connected address\n"
    },
    "Creates and binds an [`hs.socket.udp`](#new) instance to a port for listening": {
        "prefix": "hs.socket.udp.server(port[, fn]) -> hs.socket.udp object",
        "body": "hs.socket.udp.server(${1:port[}, ${2:fn]})",
        "description": "Creates and binds an [`hs.socket.udp`](#new) instance to a port for listening\n\nParameters:\n * port - A port number [0-65535]. Ports [1-1023] are privileged. Port 0 allows the OS to select any available port\n * fn - An optional [callback function](#setCallback) for reading data from the socket, settable here for convenience\n\nReturns:\n * An [`hs.socket.udp`](#new) object\n"
    },
    "Sets the maximum size of the buffer that will be allocated for receive operations": {
        "prefix": "hs.socket.udp:setBufferSize(size[, version]) -> self",
        "body": "hs.socket.udp:setBufferSize(${1:size[}, ${2:version]})",
        "description": "Sets the maximum size of the buffer that will be allocated for receive operations\n\nParameters:\n * size - An number containing the receive buffer size in bytes\n * version - An optional number containing the IP version for which to set the buffer size. Anything but 4 or 6 else sets the same size for both\n\nReturns:\n * The [`hs.socket.udp`](#new) object\n\nNotes:\n * The default maximum size is 9216 bytes\n * The theoretical maximum size of any IPv4 UDP packet is UINT16_MAX = 65535\n * The theoretical maximum size of any IPv6 UDP packet is UINT32_MAX = 4294967295\n * Since the OS notifies us of the size of each received UDP packet, the actual allocated buffer size for each packet is exact\n * In practice the size of UDP packets is generally much smaller than the max. Most protocols will send and receive packets of only a few bytes, or will set a limit on the size of packets to prevent fragmentation in the IP layer.\n * If you set the buffer size too small, the sockets API in the OS will silently discard any extra data\n"
    },
    "Sets the read callback for the [`hs.socket.udp`](#new) instance. Must be set to read data from the socket": {
        "prefix": "hs.socket.udp:setCallback([fn]) -> self",
        "body": "hs.socket.udp:setCallback(${1:[fn]})",
        "description": "Sets the read callback for the [`hs.socket.udp`](#new) instance. Must be set to read data from the socket\n\nThe callback receives 2 parameters:\n * data - The data read from the socket as a string\n * sockaddr - The sending address as a binary socket address structure. See [`parseAddress`](#parseAddress)\n\nParameters:\n * fn - An optional callback function to process data read from the socket. `nil` or no argument clears the callback\n\nReturns:\n * The [`hs.socket.udp`](#new) object\n"
    },
    "Timeout for the socket operations, in seconds. New [`hs.socket.udp`](#new) objects will be created with this timeout value, but can individually change it with the [`setTimeout`](#setTimeout) method": {
        "prefix": "hs.socket.udp.timeout",
        "body": "hs.socket.udp.timeout",
        "description": "Timeout for the socket operations, in seconds. New [`hs.socket.udp`](#new) objects will be created with this timeout value, but can individually change it with the [`setTimeout`](#setTimeout) method\n\nIf the timeout value is negative, the operations will not use a timeout. The default value is -1\n"
    },
    "Alias for [`hs.socket.udp:send`](#send)": {
        "prefix": "hs.socket.udp:write(message[, tag]) -> self",
        "body": "hs.socket.udp:write(${1:message[}, ${2:tag]})",
        "description": "Alias for [`hs.socket.udp:send`](#send)\n"
    },
    "Get or set the current seek offset within an `hs.sound` object.": {
        "prefix": "hs.sound:currentTime([seekTime]) -> soundObject | seconds",
        "body": "hs.sound:currentTime(${1:[seekTime]})",
        "description": "Get or set the current seek offset within an `hs.sound` object.\n\nParameters:\n * seekTime - An optional number of seconds to seek to within the sound object\n\nReturns:\n * If a parameter is provided, returns the sound object; otherwise returns the current position."
    },
    "Get or set the playback device to use for an `hs.sound` object": {
        "prefix": "hs.sound:device([deviceUID]) -> soundObject | UID string",
        "body": "hs.sound:device(${1:[deviceUID]})",
        "description": "Get or set the playback device to use for an `hs.sound` object\n\nParameters:\n * deviceUID - An optional string containing the UID of an `hs.audiodevice` object to use for playback of this sound. Use an explicit nil to use the system's default device\n\nReturns:\n * If a parameter is provided, returns the sound object; otherwise returns the current setting.\n\nNotes:\n * To obtain the UID of a sound device, see `hs.audiodevice:uid()`"
    },
    "Gets the length of an `hs.sound` object": {
        "prefix": "hs.sound:duration() -> seconds",
        "body": "hs.sound:duration()",
        "description": "Gets the length of an `hs.sound` object\n\nParameters:\n * None\n\nReturns:\n * A number containing the length of the sound, in seconds"
    },
    "Gets a table of installed Audio Units Effect names.": {
        "prefix": "hs.sound.getAudioEffectNames() -> table",
        "body": "hs.sound.getAudioEffectNames()",
        "description": "Gets a table of installed Audio Units Effect names.\n\nParameters:\n * None\n\nReturns:\n * A table containing the names of all installed Audio Units Effects.\n\nNotes:\n * Example usage: `hs.inspect(hs.audiounit.getAudioEffectNames())`"
    },
    "Creates an `hs.sound` object from a file": {
        "prefix": "hs.sound.getByFile(path) -> sound or nil",
        "body": "hs.sound.getByFile(${1:path})",
        "description": "Creates an `hs.sound` object from a file\n\nParameters:\n * path - A string containing the path to a sound file\n\nReturns:\n * An `hs.sound` object or nil if the file could not be loaded"
    },
    "Creates an `hs.sound` object from a named sound": {
        "prefix": "hs.sound.getByName(name) -> sound or nil",
        "body": "hs.sound.getByName(${1:name})",
        "description": "Creates an `hs.sound` object from a named sound\n\nParameters:\n * name - A string containing the name of a sound\n\nReturns:\n * An `hs.sound` object or nil if no matching sound could be found\n\nNotes:\n * Sounds can only be loaded by name if they are System Sounds (i.e. those found in ~/Library/Sounds, /Library/Sounds, /Network/Library/Sounds and /System/Library/Sounds) or are sound files that have previously been loaded and named"
    },
    "Gets the current playback state of an `hs.sound` object": {
        "prefix": "hs.sound:isPlaying() -> bool",
        "body": "hs.sound:isPlaying()",
        "description": "Gets the current playback state of an `hs.sound` object\n\nParameters:\n * None\n\nReturns:\n * A boolean, true if the sound is currently playing, otherwise false"
    },
    "Get or set the looping behaviour of an `hs.sound` object": {
        "prefix": "hs.sound:loopSound([loop]) -> soundObject | bool",
        "body": "hs.sound:loopSound(${1:[loop]})",
        "description": "Get or set the looping behaviour of an `hs.sound` object\n\nParameters:\n * loop - An optional boolean, true to loop playback, false to not loop\n\nReturns:\n * If a parameter is provided, returns the sound object; otherwise returns the current setting.\n\nNotes:\n * If you have registered a callback function for completion of a sound's playback, it will not be called when the sound loops"
    },
    "Get or set the name of an `hs.sound` object": {
        "prefix": "hs.sound:name([soundName]) -> soundObject | name string",
        "body": "hs.sound:name(${1:[soundName]})",
        "description": "Get or set the name of an `hs.sound` object\n\nParameters:\n * soundName - An optional string to use as the name of the object; use an explicit nil to remove the name\n\nReturns:\n * If a parameter is provided, returns the sound object; otherwise returns the current setting.\n\nNotes:\n * If remove the sound name by specifying `nil`, the sound will automatically be set to stop when Hammerspoon is reloaded."
    },
    "Pauses an `hs.sound` object": {
        "prefix": "hs.sound:pause() -> soundObject | bool",
        "body": "hs.sound:pause()",
        "description": "Pauses an `hs.sound` object\n\nParameters:\n * None\n\nReturns:\n * The `hs.sound` object if the command was successful, otherwise false."
    },
    "Plays an `hs.sound` object": {
        "prefix": "hs.sound:play() -> soundObject | bool",
        "body": "hs.sound:play()",
        "description": "Plays an `hs.sound` object\n\nParameters:\n * None\n\nReturns:\n * The `hs.sound` object if the command was successful, otherwise false."
    },
    "Resumes playing a paused `hs.sound` object": {
        "prefix": "hs.sound:resume() -> soundObject | bool",
        "body": "hs.sound:resume()",
        "description": "Resumes playing a paused `hs.sound` object\n\nParameters:\n * None\n\nReturns:\n * The `hs.sound` object if the command was successful, otherwise false."
    },
    "Set or remove the callback for receiving completion notification for the sound object.": {
        "prefix": "hs.sound:setCallback(function) -> soundObject",
        "body": "hs.sound:setCallback(${1:function})",
        "description": "Set or remove the callback for receiving completion notification for the sound object.\n\nParameters:\n * function - A function which should be called when the sound completes playing.  Specify an explicit nil to remove the callback function.\n\nReturns:\n * the sound object\n\nNotes:\n * the callback function should accept two parameters and return none.  The parameters passed to the callback function are:\n   * state - a boolean flag indicating if the sound completed playing.  Returns true if playback completes properly, or false if a decoding error occurs or if the sound is stopped early with `hs.sound:stop`.\n   * sound - the soundObject userdata"
    },
    "Gets the supported sound file types": {
        "prefix": "hs.sound.soundFileTypes() -> table",
        "body": "hs.sound.soundFileTypes()",
        "description": "Gets the supported sound file types\n\nParameters:\n * None\n\nReturns:\n * A table containing the sound file filename extensions that are supported by the system\n\nNotes:\n * This function is unlikely to be tremendously useful, as filename extensions are essentially meaningless. The data returned by `hs.sound.soundTypes()` is far more valuable"
    },
    "Gets the supported UTI sound file formats": {
        "prefix": "hs.sound.soundTypes() -> table",
        "body": "hs.sound.soundTypes()",
        "description": "Gets the supported UTI sound file formats\n\nParameters:\n * None\n\nReturns:\n * A table containing the UTI sound formats that are supported by the system"
    },
    "Stops playing an `hs.sound` object": {
        "prefix": "hs.sound:stop() -> soundObject | bool",
        "body": "hs.sound:stop()",
        "description": "Stops playing an `hs.sound` object\n\nParameters:\n * None\n\nReturns:\n * The `hs.sound` object if the command was successful, otherwise false."
    },
    "Get or set whether a sound should be stopped when Hammerspoon reloads its configuration": {
        "prefix": "hs.sound:stopOnReload([stopOnReload]) -> soundObject | bool",
        "body": "hs.sound:stopOnReload(${1:[stopOnReload]})",
        "description": "Get or set whether a sound should be stopped when Hammerspoon reloads its configuration\n\nParameters:\n * stopOnReload - An optional boolean, true to stop playback when Hammerspoon reloads its config, false to continue playback regardless.  Defaults to true.\n\nReturns:\n * If a parameter is provided, returns the sound object; otherwise returns the current setting.\n\nNotes:\n * This method can only be used on a named `hs.sound` object, see `hs.sound:name()`"
    },
    "Gets a table of available system sounds": {
        "prefix": "hs.sound.systemSounds() -> table",
        "body": "hs.sound.systemSounds()",
        "description": "Gets a table of available system sounds\n\nParameters:\n * None\n\nReturns:\n * A table containing all of the available sound files (i.e. those found in ~/Library/Sounds, /Library/Sounds, /Network/Library/Sounds and /System/Library/Sounds)\n\nNotes:\n * The sounds listed by this function can be loaded using `hs.sound.getByName()`"
    },
    "Get or set the playback volume of an `hs.sound` object": {
        "prefix": "hs.sound:volume([level]) -> soundObject | number",
        "body": "hs.sound:volume(${1:[level]})",
        "description": "Get or set the playback volume of an `hs.sound` object\n\nParameters:\n * level - A number between 0.0 and 1.0, representing the volume of the sound object relative to the current system volume\n\nReturns:\n * If a parameter is provided, returns the sound object; otherwise returns the current value."
    },
    "Creates a new watcher for Space change events": {
        "prefix": "hs.spaces.watcher.new(handler) -> watcher",
        "body": "hs.spaces.watcher.new(${1:handler})",
        "description": "Creates a new watcher for Space change events\n\nParameters:\n * handler - A function to be called when the active Space changes. It should accept one argument, which will be the number of the new Space (or -1 if the number cannot be determined)\n\nReturns:\n * An `hs.spaces.watcher` object"
    },
    "Starts the Spaces watcher": {
        "prefix": "hs.spaces.watcher:start()",
        "body": "hs.spaces.watcher:start()",
        "description": "Starts the Spaces watcher\n\nParameters:\n * None\n\nReturns:\n * The watcher object"
    },
    "Stops the Spaces watcher": {
        "prefix": "hs.spaces.watcher:stop()",
        "body": "hs.spaces.watcher:stop()",
        "description": "Stops the Spaces watcher\n\nParameters:\n * None\n\nReturns:\n * The watcher object"
    },
    "Returns a table containing a variety of properties describing and defining the specified voice.": {
        "prefix": "hs.speech.attributesForVoice(voice) -> table",
        "body": "hs.speech.attributesForVoice(${1:voice})",
        "description": "Returns a table containing a variety of properties describing and defining the specified voice.\n\nParameters:\n * voice - the name of the voice to look up attributes for\n\nReturns:\n * a table containing key-value pairs which describe the voice specified.  These attributes may include (but is not limited to) information about specific characters recognized, sample text, gender, etc.\n\nNotes:\n * All of the names that have been encountered thus far follow this pattern for their full name:  `com.apple.speech.synthesis.voice.*name*`.  You can provide this suffix or not as you prefer when specifying a voice name."
    },
    "Returns a list of the currently installed voices for speech synthesis.": {
        "prefix": "hs.speech.availableVoices([full]) -> array",
        "body": "hs.speech.availableVoices(${1:[full]})",
        "description": "Returns a list of the currently installed voices for speech synthesis.\n\nParameters:\n * full - an optional boolean flag indicating whether or not the full internal names should be returned, or if the shorter versions should be returned.  Defaults to false.\n\nReturns:\n * an array of the available voice names.\n\nNotes:\n * All of the names that have been encountered thus far follow this pattern for their full name:  `com.apple.speech.synthesis.voice.*name*`.  This prefix is normally suppressed unless you pass in true."
    },
    "Resumes a paused speech synthesizer.": {
        "prefix": "hs.speech:continue() -> synthesizerObject",
        "body": "hs.speech:continue()",
        "description": "Resumes a paused speech synthesizer.\n\nParameters:\n * None\n\nReturns:\n * the synthesizer object"
    },
    "Returns the name of the currently selected default voice for the user.  This voice is the voice selected in the System Preferences for Dictation & Speech as the System Voice.": {
        "prefix": "hs.speech.defaultVoice([full]) -> string",
        "body": "hs.speech.defaultVoice(${1:[full]})",
        "description": "Returns the name of the currently selected default voice for the user.  This voice is the voice selected in the System Preferences for Dictation & Speech as the System Voice.\n\nParameters:\n * full - an optional boolean flag indicating whether or not the full internal name should be returned, or if the shorter version should be returned.  Defaults to false.\n\nReturns:\n * the name of the system voice.\n\nNotes:\n * All of the names that have been encountered thus far follow this pattern for their full name:  `com.apple.speech.synthesis.voice.*name*`.  This prefix is normally suppressed unless you pass in true."
    },
    "Returns whether or not the system is currently using a speech synthesizer in any application to generate speech.": {
        "prefix": "hs.speech.isAnyApplicationSpeaking() -> boolean",
        "body": "hs.speech.isAnyApplicationSpeaking()",
        "description": "Returns whether or not the system is currently using a speech synthesizer in any application to generate speech.\n\nParameters:\n * None\n\nReturns:\n * a boolean value indicating whether or not any application is currently generating speech with a synthesizer.\n\nNotes:\n * See also `hs.speech:speaking`."
    },
    "Returns whether or not the synthesizer is currently paused.": {
        "prefix": "hs.speech:isPaused() -> boolean | nil",
        "body": "hs.speech:isPaused()",
        "description": "Returns whether or not the synthesizer is currently paused.\n\nParameters:\n * None\n\nReturns:\n * True or false indicating whether or not the synthesizer is currently paused.  If there is an error, returns nil.\n\nNotes:\n * If an error occurs retrieving this value, the details will be logged in the system logs which can be viewed with the Console application.  You can also have such messages logged to the Hammerspoon console by setting the module's log level to at least Information (This can be done with the following, or similar, command: `hs.speech.log.level = 3`.  See `hs.logger` for more information)"
    },
    "Returns whether or not the synthesizer is currently speaking, either to an audio device or to a file.": {
        "prefix": "hs.speech:isSpeaking() -> boolean | nil",
        "body": "hs.speech:isSpeaking()",
        "description": "Returns whether or not the synthesizer is currently speaking, either to an audio device or to a file.\n\nParameters:\n * None\n\nReturns:\n * True or false indicating whether or not the synthesizer is currently producing speech.  If there is an error, returns nil.\n\nNotes:\n * If an error occurs retrieving this value, the details will be logged in the system logs which can be viewed with the Console application.  You can also have such messages logged to the Hammerspoon console by setting the module's log level to at least Information (This can be done with the following, or similar, command: `hs.speech.log.level = 3`.  See `hs.logger` for more information)"
    },
    "Gets or sets the pitch modulation for the synthesizer's voice.": {
        "prefix": "hs.speech:modulation([modulation]) -> synthsizerObject | modulation | nil",
        "body": "hs.speech:modulation(${1:[modulation]})",
        "description": "Gets or sets the pitch modulation for the synthesizer's voice.\n\nParameters:\n * modulation - an optional number indicating the pitch modulation for the synthesizer.\n\nReturns:\n * If no parameter is provided, returns the current value; otherwise returns the synthesizer object.  Returns nil if an error occurs.\n\nNotes:\n * Pitch modulation is expressed as a floating-point value in the range of 0.000 to 127.000. These values correspond to MIDI note values, where 60.000 is equal to middle C on a piano scale. The most useful speech pitches fall in the range of 40.000 to 55.000. A pitch modulation value of 0.000 corresponds to a monotone in which all speech is generated at the frequency corresponding to the speech pitch. Given a speech pitch value of 46.000, a pitch modulation of 2.000 would mean that the widest possible range of pitches corresponding to the actual frequency of generated text would be 44.000 to 48.000.\n\n * If an error occurs retrieving or setting this value, the details will be logged in the system logs which can be viewed with the Console application.  You can also have such messages logged to the Hammerspoon console by setting the module's log level to at least Information (This can be done with the following, or similar, command: `hs.speech.log.level = 3`.  See `hs.logger` for more information)"
    },
    "Creates a new speech synthesizer object for use by Hammerspoon.": {
        "prefix": "hs.speech.new([voice]) -> synthesizerObject",
        "body": "hs.speech.new(${1:[voice]})",
        "description": "Creates a new speech synthesizer object for use by Hammerspoon.\n\nParameters:\n * voice - an optional string specifying the voice the synthesizer should use for generating speech.  Defaults to the system voice.\n\nReturns:\n * a speech synthesizer object or nil, if the system was unable to create a new synthesizer.\n\nNotes:\n * All of the names that have been encountered thus far follow this pattern for their full name:  `com.apple.speech.synthesis.voice.*name*`.  You can provide this suffix or not as you prefer when specifying a voice name.\n * You can change the voice later with the `hs.speech:voice` method."
    },
    "Pauses the output of the speech synthesizer.": {
        "prefix": "hs.speech:pause([where]) -> synthesizerObject",
        "body": "hs.speech:pause(${1:[where]})",
        "description": "Pauses the output of the speech synthesizer.\n\nParameters:\n * where - an optional string indicating when to pause the audio output (defaults to \"immediate\").  The string can be one of the following:\n   * \"immediate\" - pauses output immediately.  If in the middle of a word, when speech is resumed, the word will be repeated.\n   * \"word\"      - pauses at the end of the current word.\n   * \"sentence\"  - pauses at the end of the current sentence.\n\nReturns:\n * the synthesizer object"
    },
    "Returns the phonemes which would be spoken if the text were to be synthesized.": {
        "prefix": "hs.speech:phonemes(text) -> string",
        "body": "hs.speech:phonemes(${1:text})",
        "description": "Returns the phonemes which would be spoken if the text were to be synthesized.\n\nParameters:\n * text - the text to tokenize into phonemes.\n\nReturns:\n * the text converted into the series of phonemes the synthesizer would use for the provided text if it were to be synthesized.\n\nNotes:\n * This method only returns a phonetic representation of the text if a Macintalk voice has been selected.  The more modern higher quality voices do not use a phonetic representation and an empty string will be returned if this method is used.\n * You can modify the phonetic representation and feed it into `hs.speech:speak` if you find that the default interpretation is not correct.  You will need to set the input mode to Phonetic by prefixing the text with \"[[inpt PHON]]\".\n * The specific phonetic symbols recognized by a given voice can be queried by examining the array returned by `hs.speech:phoneticSymbols` after setting an appropriate voice."
    },
    "Returns an array of the phonetic symbols recognized by the synthesizer for the current voice.": {
        "prefix": "hs.speech:phoneticSymbols() -> array | nil",
        "body": "hs.speech:phoneticSymbols()",
        "description": "Returns an array of the phonetic symbols recognized by the synthesizer for the current voice.\n\nParameters:\n * None\n\nReturns:\n * For MacinTalk voices, this method will return an array of the recognized symbols for the currently selected voice.  For the modern higher quality voices, or if an error occurs, returns nil.\n\nNotes:\n * Each entry in the array of phonemes returned will contain the following keys:\n   * Symbol      - The textual representation of this phoneme when returned by `hs.speech:phonemes` or that you should use for this sound when crafting a phonetic string yourself.\n   * Opcode      - The numeric opcode passed to the callback for the \"willSpeakPhoneme\" message corresponding to this phoneme.\n   * Example     - An example word which contains the sound the phoneme represents\n   * HiliteEnd   - The character position in the Example where this phoneme's sound begins\n   * HiliteStart - The character position in the Example where this phoneme's sound ends\n\n * Only the older, MacinTalk style voices support phonetic text.  The more modern, higher quality voices are not rendered phonetically and will return nil for this method.\n\n * If an error occurs retrieving this value, the details will be logged in the system logs which can be viewed with the Console application.  You can also have such messages logged to the Hammerspoon console by setting the module's log level to at least Information (This can be done with the following, or similar, command: `hs.speech.log.level = 3`.  See `hs.logger` for more information)"
    },
    "Gets or sets the base pitch for the synthesizer's voice.": {
        "prefix": "hs.speech:pitch([pitch]) -> synthsizerObject | pitch | nil",
        "body": "hs.speech:pitch(${1:[pitch]})",
        "description": "Gets or sets the base pitch for the synthesizer's voice.\n\nParameters:\n * pitch - an optional number indicating the pitch base for the synthesizer.\n\nReturns:\n * If no parameter is provided, returns the current value; otherwise returns the synthesizer object.  Returns nil if an error occurs.\n\nNotes:\n * Typical voice frequencies range from around 90 hertz for a low-pitched male voice to perhaps 300 hertz for a high-pitched child\u2019s voice. These frequencies correspond to approximate pitch values in the ranges of 30.000 to 40.000 and 55.000 to 65.000, respectively.\n\n * If an error occurs retrieving or setting this value, the details will be logged in the system logs which can be viewed with the Console application.  You can also have such messages logged to the Hammerspoon console by setting the module's log level to at least Information (This can be done with the following, or similar, command: `hs.speech.log.level = 3`.  See `hs.logger` for more information)"
    },
    "Gets or sets the synthesizers speaking rate (words per minute).": {
        "prefix": "hs.speech:rate([rate]) -> synthesizerObject | rate",
        "body": "hs.speech:rate(${1:[rate]})",
        "description": "Gets or sets the synthesizers speaking rate (words per minute).\n\nParameters:\n * rate - an optional number indicating the speaking rate for the synthesizer.\n\nReturns:\n * If no parameter is provided, returns the current value; otherwise returns the synthesizer object.\n\nNotes:\n * The range of supported rates is not predefined by the Speech Synthesis framework; but the synthesizer may only respond to a limited range of speech rates. Average human speech occurs at a rate of 180.0 to 220.0 words per minute."
    },
    "Reset a synthesizer back to its default state.": {
        "prefix": "hs.speech:reset() -> synthsizerObject | nil",
        "body": "hs.speech:reset()",
        "description": "Reset a synthesizer back to its default state.\n\nParameters:\n * None\n\nReturns:\n * Returns the synthesizer object.  Returns nil if an error occurs.\n\nNotes:\n * This method will reset a synthesizer to its default state, including pitch, modulation, volume, rate, etc.\n * The changes go into effect immediately, if queried, but will not affect a synthesis in progress.\n\n * If an error occurs retrieving or setting this value, the details will be logged in the system logs which can be viewed with the Console application.  You can also have such messages logged to the Hammerspoon console by setting the module's log level to at least Information (This can be done with the following, or similar, command: `hs.speech.log.level = 3`.  See `hs.logger` for more information)"
    },
    "Sets or removes a callback function for the synthesizer.": {
        "prefix": "hs.speech:setCallback(fn | nil) -> synthesizerObject",
        "body": "hs.speech:setCallback(${1:fn | nil})",
        "description": "Sets or removes a callback function for the synthesizer.\n\nParameters:\n * fn - a function to set as the callback for this speech synthesizer.  If the value provided is nil, any currently existing callback function is removed.\n\nReturns:\n * the synthesizer object\n\nNotes:\n * The callback function should expect between 3 and 5 arguments and should not return anything.  The first two arguments will always be the synthesizer object itself and a string indicating the activity which has caused the callback.  The value of this string also dictates the remaining arguments as follows:\n\n   * \"willSpeakWord\"     - Sent just before a synthesized word is spoken through the sound output device.\n     * provides 3 additional arguments: startIndex, endIndex, and the full text being spoken.\n     * startIndex and endIndex can be used as `string.sub(text, startIndex, endIndex)` to get the specific word being spoken.\n\n   * \"willSpeakPhoneme\"  - Sent just before a synthesized phoneme is spoken through the sound output device.\n     * provides 1 additional argument: the opcode of the phoneme about to be spoken.\n     * this callback message will only occur when using Macintalk voices; modern higher quality voices are not phonetically based and will not generate this message.\n     * the opcode can be tied to a specific phoneme by looking it up in the table returned by `hs.speech:phoneticSymbols`.\n\n   * \"didEncounterError\" - Sent when the speech synthesizer encounters an error in text being synthesized.\n     * provides 3 additional arguments: the index in the original text where the error occurred, the text being spoken, and an error message.\n     * *Special Note:* I have never been able to trigger this callback message, even with malformed embedded command sequences, so... looking for validation of the code or fixes.  File an issue if you have suggestions.\n\n   * \"didEncounterSync\"  - Sent when the speech synthesizer encounters an embedded synchronization command.\n     * provides 1 additional argument: the synchronization number provided in the text.\n     * A synchronization number can be embedded in text to be spoken by including `[[sync #]]` in the text where you wish the callback to occur.  The number is limited to 32 bits and can be presented as a base 10 or base 16 number (prefix with 0x).\n\n   * \"didFinish\"         - Sent when the speech synthesizer finishes speaking through the sound output device.\n     * provides 1 additional argument: a boolean flag indicating whether or not the synthesizer finished because synthesis is complete (true) or was stopped early with `hs.speech:stop` (false)."
    },
    "Starts speaking the provided text through the system's current audio device.": {
        "prefix": "hs.speech:speak(textToSpeak) -> synthesizerObject",
        "body": "hs.speech:speak(${1:textToSpeak})",
        "description": "Starts speaking the provided text through the system's current audio device.\n\nParameters:\n * textToSpeak - the text to speak with the synthesizer.\n\nReturns:\n * the synthesizer object"
    },
    "Returns whether or not this synthesizer is currently generating speech.": {
        "prefix": "hs.speech:speaking() -> boolean",
        "body": "hs.speech:speaking()",
        "description": "Returns whether or not this synthesizer is currently generating speech.\n\nParameters:\n * None\n\nReturns:\n * A boolean value indicating whether or not this synthesizer is currently generating speech.\n\nNotes:\n * See also `hs.speech.isAnyApplicationSpeaking`."
    },
    "Starts speaking the provided text and saves the audio as an AIFF file.": {
        "prefix": "hs.speech:speakToFile(textToSpeak, destination) -> synthesizerObject",
        "body": "hs.speech:speakToFile(${1:textToSpeak}, ${2:destination})",
        "description": "Starts speaking the provided text and saves the audio as an AIFF file.\n\nParameters:\n * textToSpeak - the text to speak with the synthesizer.\n * destination - the path to the file to create and store the audio data in.\n\nReturns:\n * the synthesizer object"
    },
    "Stops the output of the speech synthesizer.": {
        "prefix": "hs.speech:stop([where]) -> synthesizerObject",
        "body": "hs.speech:stop(${1:[where]})",
        "description": "Stops the output of the speech synthesizer.\n\nParameters:\n * where - an optional string indicating when to stop the audio output (defaults to \"immediate\").  The string can be one of the following:\n   * \"immediate\" - stops output immediately.\n   * \"word\"      - stops at the end of the current word.\n   * \"sentence\"  - stops at the end of the current sentence.\n\nReturns:\n * the synthesizer object"
    },
    "Gets or sets whether or not the synthesizer uses the speech feedback window.": {
        "prefix": "hs.speech:usesFeedbackWindow([flag]) -> synthesizerObject | boolean",
        "body": "hs.speech:usesFeedbackWindow(${1:[flag]})",
        "description": "Gets or sets whether or not the synthesizer uses the speech feedback window.\n\nParameters:\n * flag - an optional boolean indicating whether or not the synthesizer should user the speech feedback window or not.  Defaults to false.\n\nReturns:\n * If no parameter is provided, returns the current value; otherwise returns the synthesizer object.\n\nNotes:\n * *Special Note:* I am not sure where the visual feedback actually occurs -- I have not been able to locate a feedback window for synthesis in 10.11; however the method is defined and not marked deprecated, so I include it in the module.  If anyone has more information, please file an issue and the documentation will be updated."
    },
    "Gets or sets the active voice for a synthesizer.": {
        "prefix": "hs.speech:voice([full] | [voice]) -> synthesizerObject | voice",
        "body": "hs.speech:voice(${1:[full] | [voice]})",
        "description": "Gets or sets the active voice for a synthesizer.\n\nParameters:\n * full  - an optional boolean indicating whether or not you wish the full internal voice name to be returned, or if you want the shorter version.  Defaults to false.\n * voice - an optional string indicating the name of the voice to change the synthesizer to.\n\nReturns:\n * If no parameter is provided (or the parameter is a boolean value), returns the current value; otherwise returns the synthesizer object or nil if the voice could not be changed for some reason.\n\nNotes:\n * All of the names that have been encountered thus far follow this pattern for their full name:  `com.apple.speech.synthesis.voice.*name*`.  You can provide this suffix or not as you prefer when specifying a voice name.\n * The voice cannot be changed while the synthesizer is currently producing output.\n * If you change the voice while a synthesizer is paused, the current synthesis will be terminated and the voice will be changed."
    },
    "Gets or sets the synthesizers speaking volume.": {
        "prefix": "hs.speech:volume([volume]) -> synthesizerObject | volume",
        "body": "hs.speech:volume(${1:[volume]})",
        "description": "Gets or sets the synthesizers speaking volume.\n\nParameters:\n * volume - an optional number between 0.0 and 1.0 indicating the speaking volume for the synthesizer.\n\nReturns:\n * If no parameter is provided, returns the current value; otherwise returns the synthesizer object.\n\nNotes:\n * Volume units lie on a scale that is linear with amplitude or voltage. A doubling of perceived loudness corresponds to a doubling of the volume."
    },
    "Get or set whether or not the speech recognizer should block other recognizers when it is active.": {
        "prefix": "hs.speech.listener:blocksOtherRecognizers([flag]) -> recognizerObject | current value",
        "body": "hs.speech.listener:blocksOtherRecognizers(${1:[flag]})",
        "description": "Get or set whether or not the speech recognizer should block other recognizers when it is active.\n\nParameters:\n * flag - an optional boolean indicating whether or not the speech recognizer should block other speech recognizers when it is active. Defaults to false.\n\nReturns:\n * If no parameter is provided, returns the current value; otherwise returns the recognizer object."
    },
    "Get or set the commands this speech recognizer will listen for.": {
        "prefix": "hs.speech.listener:commands([commandsArray]) -> recognizerObject | current value",
        "body": "hs.speech.listener:commands(${1:[commandsArray]})",
        "description": "Get or set the commands this speech recognizer will listen for.\n\nParameters:\n * commandsArray - an optional array of strings which specify the commands the recognizer will listen for.\n\nReturns:\n * If no parameter is provided, returns the current value; otherwise returns the recognizer object.\n\nNotes:\n * The list of commands will appear in the Dictation Commands window, if it is visible, under the title of this speech recognizer.  The text of each command is a possible value which may be sent as the second argument to a callback function for this speech recognizer, if one is defined.\n * Setting this to an empty list does not disable the speech recognizer, but it does make it of limited use, other than to provide a title in the Dictation Commands window.  To disable the recognizer, use the `hs.speech.listener:stop` or `hs.speech.listener:delete` methods."
    },
    "Disables the speech recognizer and removes it from the possible available speech recognizers.": {
        "prefix": "hs.speech.listener:delete() -> recognizerObject",
        "body": "hs.speech.listener:delete()",
        "description": "Disables the speech recognizer and removes it from the possible available speech recognizers.\n\nParameters:\n * None.\n\nReturns:\n * None\n\nNotes:\n * this disables the speech recognizer and removes it from the list in the Dictation Commands window.  The object is effectively destroyed, so you will need to create a new one with `hs.speech.listener.new` if you want to bring it back.\n * if this was the only speech recognizer currently available, the Dictation Commands window and feedback display will be removed from the users display.\n * this method is automatically called during a reload or restart of Hammerspoon."
    },
    "Get or set whether or not the speech recognizer is active only when the Hammerspoon application is active.": {
        "prefix": "hs.speech.listener:foregroundOnly([flag]) -> recognizerObject | current value",
        "body": "hs.speech.listener:foregroundOnly(${1:[flag]})",
        "description": "Get or set whether or not the speech recognizer is active only when the Hammerspoon application is active.\n\nParameters:\n * flag - an optional boolean indicating whether or not the speech recognizer should respond to commands only when Hammerspoon is the active application or not. Defaults to true.\n\nReturns:\n * If no parameter is provided, returns the current value; otherwise returns the recognizer object."
    },
    "Returns a boolean value indicating whether or not the recognizer is currently enabled (started).": {
        "prefix": "hs.speech.listener:isListening() -> boolean",
        "body": "hs.speech.listener:isListening()",
        "description": "Returns a boolean value indicating whether or not the recognizer is currently enabled (started).\n\nParameters:\n * None\n\nReturns:\n * true if the listener is listening (has been started) or false if it is not."
    },
    "Creates a new speech recognizer object for use by Hammerspoon.": {
        "prefix": "hs.speech.listener.new([title]) -> recognizerObject",
        "body": "hs.speech.listener.new(${1:[title]})",
        "description": "Creates a new speech recognizer object for use by Hammerspoon.\n\nParameters:\n * title - an optional parameter specifying the title under which commands assigned to this speech recognizer will be listed in the Dictation Commands display when it is visible.  Defaults to \"Hammerspoon\".\n\nReturns:\n * a speech recognizer object or nil, if the system was unable to create a new recognizer.\n\nNotes:\n * You can change the title later with the `hs.speech.listener:title` method."
    },
    "Sets or removes a callback function for the speech recognizer.": {
        "prefix": "hs.speech.listener:setCallback(fn | nil) -> recognizerObject",
        "body": "hs.speech.listener:setCallback(${1:fn | nil})",
        "description": "Sets or removes a callback function for the speech recognizer.\n\nParameters:\n * fn - a function to set as the callback for this speech synthesizer.  If the value provided is nil, any currently existing callback function is removed.  The callback function should accept two arguments and return none.  The arguments will be the speech recognizer object itself and the string of the command which was spoken.\n\nReturns:\n * the recognizer object\n\nNotes:\n * Possible string values for the command spoken are set with the `hs.speech.listener:commands` method.\n * Removing the callback does not disable the speech recognizer, but it does make it of limited use, other than to provide a list in the Dictation Commands window.  To disable the recognizer, use the `hs.speech.listener:stop` or `hs.speech.listener:delete` methods."
    },
    "Make the speech recognizer active.": {
        "prefix": "hs.speech.listener:start() -> recognizerObject",
        "body": "hs.speech.listener:start()",
        "description": "Make the speech recognizer active.\n\nParameters:\n * None.\n\nReturns:\n * returns the recognizer object."
    },
    "Disables the speech recognizer.": {
        "prefix": "hs.speech.listener:stop() -> recognizerObject",
        "body": "hs.speech.listener:stop()",
        "description": "Disables the speech recognizer.\n\nParameters:\n * None.\n\nReturns:\n * returns the recognizer object.\n\nNotes:\n * this only disables the speech recognizer.  To completely remove it from the list in the Dictation Commands window, use `hs.speech.listener:delete`."
    },
    "Get or set the title for a speech recognizer.": {
        "prefix": "hs.speech.listener:title([title]) -> recognizerObject | current value",
        "body": "hs.speech.listener:title(${1:[title]})",
        "description": "Get or set the title for a speech recognizer.\n\nParameters:\n * title - an optional parameter specifying the title under which commands assigned to this speech recognizer will be listed in the Dictation Commands display when it is visible.  If you provide an explicit `nil`, it will reset to the default of \"Hammerspoon\".\n\nReturns:\n * If no parameter is provided, returns the current value; otherwise returns the recognizer object."
    },
    "Map a number of hotkeys according to a definition table": {
        "prefix": "hs.spoons.bindHotkeysToSpec(def, map) -> none",
        "body": "hs.spoons.bindHotkeysToSpec(${1:def}, ${2:map})",
        "description": "Map a number of hotkeys according to a definition table\n\nParameters:\n * def - table containing name-to-function definitions for the hotkeys supported by the Spoon. Each key is a hotkey name, and its value must be a function that will be called when the hotkey is invoked.\n * map - table containing name-to-hotkey definitions and an optional message to be displayed via `hs.alert()` when the hotkey has been triggered, as supported by [bindHotkeys in the Spoon API](https://github.com/Hammerspoon/hammerspoon/blob/master/SPOONS.md#hotkeys). Not all the entries in `def` must be bound, but if any keys in `map` don't have a definition, an error will be produced.\n\nReturns:\n * None"
    },
    "Check if a given Spoon is installed.": {
        "prefix": "hs.spoons.isInstalled(name) -> table | nil",
        "body": "hs.spoons.isInstalled(${1:name})",
        "description": "Check if a given Spoon is installed.\n\nParameters:\n * name - Name of the Spoon to check.\n\nReturns:\n * If the Spoon is installed, it returns a table with the Spoon information as returned by `list()`. Returns `nil` if the Spoon is not installed."
    },
    "Check if a given Spoon is loaded.": {
        "prefix": "hs.spoons.isLoaded(name) -> boolean | nil",
        "body": "hs.spoons.isLoaded(${1:name})",
        "description": "Check if a given Spoon is loaded.\n\nParameters:\n * name - Name of the Spoon to check.\n\nReturns:\n * `true` if the Spoon is loaded, `nil` otherwise."
    },
    "Return a list of installed/loaded Spoons": {
        "prefix": "hs.spoons.list() -> table",
        "body": "hs.spoons.list()",
        "description": "Return a list of installed/loaded Spoons\n\nParameters:\n * onlyLoaded - only return loaded Spoons (skips those that are installed but not loaded). Defaults to `false`\n\nReturns:\n * Table with a list of installed/loaded spoons (depending on the value of `onlyLoaded`). Each entry is a table with the following entries:\n   * `name` - Spoon name\n   * `loaded` - boolean indication of whether the Spoon is loaded (`true`) or only installed (`false`)\n   * `version` - Spoon version number. Available only for loaded Spoons."
    },
    "Create a skeleton for a new Spoon": {
        "prefix": "hs.spoons.newSpoon(name, basedir, metadata) -> string | nil",
        "body": "hs.spoons.newSpoon(${1:name}, ${2:basedir}, ${3:metadata})",
        "description": "Create a skeleton for a new Spoon\n\nParameters:\n * name: name of the new spoon, without the `.spoon` extension\n * basedir: (optional) directory where to create the template. Defaults to `~/.hammerspoon/Spoons`\n * metadata: (optional) table containing metadata values to be inserted in the template. Provided values are merged with the defaults. Defaults to:\n   ```\n   {\n     version = \"0.1\",\n     author = \"Your Name <your@email.org>\",\n     homepage = \"https://github.com/Hammerspoon/Spoons\",\n     license = \"MIT - https://opensource.org/licenses/MIT\",\n     download_url = \"https://github.com/Hammerspoon/Spoons/raw/master/Spoons/\"..name..\".spoon.zip\"\n   }\n   ```\n * template: (optional) absolute path of the template to use for the `init.lua` file of the new Spoon. Defaults to the `templates/init.tpl` file included with Hammerspoon.\n\nReturns:\n * The full directory path where the template was created, or `nil` if there was an error."
    },
    "Return full path of an object within a spoon directory, given its partial path.": {
        "prefix": "hs.spoons.resourcePath(partial) -> string",
        "body": "hs.spoons.resourcePath(${1:partial})",
        "description": "Return full path of an object within a spoon directory, given its partial path.\n\nParameters:\n * partial - path of a file relative to the Spoon directory. For example `images/img1.png` will refer to a file within the `images` directory of the Spoon.\n\nReturns:\n * Absolute path of the file. Note: no existence or other checks are done on the path."
    },
    "Return path of the current spoon.": {
        "prefix": "hs.spoons.scriptPath([n]) -> string",
        "body": "hs.spoons.scriptPath(${1:[n]})",
        "description": "Return path of the current spoon.\n\nParameters:\n * n - (optional) stack level for which to get the path. Defaults to 2, which will return the path of the spoon which called `scriptPath()`\n\nReturns:\n * String with the path from where the calling code was loaded."
    },
    "Declaratively load and configure a Spoon": {
        "prefix": "hs.spoons.use(name, arg) -> boolean | nil",
        "body": "hs.spoons.use(${1:name}, ${2:arg})",
        "description": "Declaratively load and configure a Spoon\n\nParameters:\n * name - the name of the Spoon to load (without the `.spoon` extension).\n * arg - if provided, can be used to specify the configuration of the Spoon. The following keys are recognized (all are optional):\n   * config - a table containing variables to be stored in the Spoon object to configure it. For example, `config = { answer = 42 }` will result in `spoon.<LoadedSpoon>.answer` being set to 42.\n   * hotkeys - a table containing hotkey bindings. If provided, will be passed as-is to the Spoon's `bindHotkeys()` method. The special string `\"default\"` can be given to use the Spoons `defaultHotkeys` variable, if it exists.\n   * fn - a function which will be called with the freshly-loaded Spoon object as its first argument.\n   * loglevel - if the Spoon has a variable called `logger`, its `setLogLevel()` method will be called with this value.\n   * start - if `true`, call the Spoon's `start()` method after configuring everything else.\n * noerror - if `true`, don't log an error if the Spoon is not installed, simply return `nil`.\n\nReturns:\n * `true` if the spoon was loaded, `nil` otherwise"
    },
    "Gets the id of the current track": {
        "prefix": "hs.spotify.getCurrentTrackId()",
        "body": "hs.spotify.getCurrentTrackId()",
        "description": "Gets the id of the current track\n\nParameters:\n * None\n\nReturns:\n * A string containing the id of the current track, or nil if an error occurred"
    },
    "Gets the current playback state of Spotify": {
        "prefix": "hs.spotify.getPlaybackState()",
        "body": "hs.spotify.getPlaybackState()",
        "description": "Gets the current playback state of Spotify\n\nParameters:\n * None\n\nReturns:\n * A string containing one of the following constants:\n   - `hs.spotify.state_stopped`\n   - `hs.spotify.state_paused`\n   - `hs.spotify.state_playing`"
    },
    "Gets the Spotify volume setting": {
        "prefix": "hs.spotify.getVolume()",
        "body": "hs.spotify.getVolume()",
        "description": "Gets the Spotify volume setting\n\nParameters:\n * None\n\nReturns:\n * A number containing the volume Spotify is set to between 1 and 100"
    },
    "Returns whether Spotify is currently playing": {
        "prefix": "hs.spotify.isPlaying()",
        "body": "hs.spotify.isPlaying()",
        "description": "Returns whether Spotify is currently playing\n\nParameters:\n * None\n\nReturns:\n * A boolean value indicating whether Spotify is currently playing a track, or nil if an error occurred (unknown player state). Also returns false if the application is not running"
    },
    "Returns whether Spotify is currently open. Most other functions in hs.spotify will automatically start the application, so this function can be used to guard against that.": {
        "prefix": "hs.spotify.isRunning()",
        "body": "hs.spotify.isRunning()",
        "description": "Returns whether Spotify is currently open. Most other functions in hs.spotify will automatically start the application, so this function can be used to guard against that.\n\nParameters:\n * None\n\nReturns:\n * A boolean value indicating whether the Spotify application is running."
    },
    "Skips to the next Spotify track": {
        "prefix": "hs.spotify.next()",
        "body": "hs.spotify.next()",
        "description": "Skips to the next Spotify track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Pauses the current Spotify track": {
        "prefix": "hs.spotify.pause()",
        "body": "hs.spotify.pause()",
        "description": "Pauses the current Spotify track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Plays the current Spotify track": {
        "prefix": "hs.spotify.play()",
        "body": "hs.spotify.play()",
        "description": "Plays the current Spotify track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Toggles play/pause of current Spotify track": {
        "prefix": "hs.spotify.playpause()",
        "body": "hs.spotify.playpause()",
        "description": "Toggles play/pause of current Spotify track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Plays the Spotify track with the given id": {
        "prefix": "hs.spotify.playTrack(id)",
        "body": "hs.spotify.playTrack(${1:id})",
        "description": "Plays the Spotify track with the given id\n\nParameters:\n * id - The Spotify id of the track to be played\n\nReturns:\n * None"
    },
    "Skips to previous Spotify track": {
        "prefix": "hs.spotify.previous()",
        "body": "hs.spotify.previous()",
        "description": "Skips to previous Spotify track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Sets the Spotify volume setting": {
        "prefix": "hs.spotify.setVolume(vol)",
        "body": "hs.spotify.setVolume(${1:vol})",
        "description": "Sets the Spotify volume setting\n\nParameters:\n * vol - A number between 1 and 100\n\nReturns:\n * None"
    },
    "Returned by `hs.spotify.getPlaybackState()` to indicates Spotify is paused": {
        "prefix": "hs.spotify.state_paused",
        "body": "hs.spotify.state_paused",
        "description": "Returned by `hs.spotify.getPlaybackState()` to indicates Spotify is paused"
    },
    "Returned by `hs.spotify.getPlaybackState()` to indicates Spotify is playing": {
        "prefix": "hs.spotify.state_playing",
        "body": "hs.spotify.state_playing",
        "description": "Returned by `hs.spotify.getPlaybackState()` to indicates Spotify is playing"
    },
    "Returned by `hs.spotify.getPlaybackState()` to indicates Spotify is stopped": {
        "prefix": "hs.spotify.state_stopped",
        "body": "hs.spotify.state_stopped",
        "description": "Returned by `hs.spotify.getPlaybackState()` to indicates Spotify is stopped"
    },
    "Get or specify the specific messages that should generate a callback.": {
        "prefix": "hs.spotlight:callbackMessages([messages]) -> table | spotlightObject",
        "body": "hs.spotlight:callbackMessages(${1:[messages]})",
        "description": "Get or specify the specific messages that should generate a callback.\n\nParameters:\n * `messages` - an optional table or list of items specifying the specific callback messages that will generate a callback.  Defaults to { \"didFinish\" }.\n\nReturns:\n * if an argument is provided, returns the spotlightObject; otherwise returns the current values\n\nNotes:\n * Valid messages for the table are: \"didFinish\", \"didStart\", \"didUpdate\", and \"inProgress\".  See [hs.spotlight:setCallback](#setCallback) for more details about the messages."
    },
    "A list of defined attribute keys as discovered in the macOS 10.12 SDK framework headers.": {
        "prefix": "hs.spotlight.commonAttributeKeys[]",
        "body": "hs.spotlight.commonAttributeKeys",
        "description": "A list of defined attribute keys as discovered in the macOS 10.12 SDK framework headers.\n\nThis table contains a list of attribute strings that may be available for spotlightSearch result items.  This list is by no means complete, and not every result will contain all or even most of these keys.\n\nNotes:\n * This list was generated by searching the Framework header files for string constants which matched one of the following regular expressions: \"kMDItem.+\", \"NSMetadataItem.+\", and \"NSMetadataUbiquitousItem.+\""
    },
    "Returns the number of results for the spotlightObject's query": {
        "prefix": "hs.spotlight:count() -> integer",
        "body": "hs.spotlight:count()",
        "description": "Returns the number of results for the spotlightObject's query\n\nParameters:\n * None\n\nReturns:\n * if the query has collected results, returns the number of results that match the query; if the query has not been started, this value will be 0.\n\nNotes:\n * Just because the result of this method is 0 does not mean that the query has not been started; the query itself may not match any entries in the Spotlight database.\n * A query which ran in the past but has been subsequently stopped will retain its queries unless the parameters have been changed.  The result of this method will indicate the number of results still attached to the query, even if it has been previously stopped.\n\n * For convenience, metamethods have been added to the spotlightObject which allow you to use `#spotlightObject` as a shortcut for `spotlightObject:count()`."
    },
    "A table of key-value pairs describing predefined search scopes for Spotlight queries": {
        "prefix": "hs.spotlight.definedSearchScopes[]",
        "body": "hs.spotlight.definedSearchScopes",
        "description": "A table of key-value pairs describing predefined search scopes for Spotlight queries\n\nThe keys for this table are as follows:\n * `iCloudData`              - Search all files not in the Documents directories of the app\u2019s iCloud container directories.\n * `iCloudDocuments`         - Search all files in the Documents directories of the app\u2019s iCloud container directories.\n * `iCloudExternalDocuments` - Search for documents outside the app\u2019s container.\n * `indexedLocalComputer`    - Search all indexed local mounted volumes including the current user\u2019s home directory (even if the home directory is remote).\n * `indexedNetwork`          - Search all indexed user-mounted remote volumes.\n * `localComputer`           - Search all local mounted volumes, including the user home directory. The user\u2019s home directory is searched even if it is a remote volume.\n * `network`                 - Search all user-mounted remote volumes.\n * `userHome`                - Search the user\u2019s home directory.\n\nNotes:\n * It is uncertain at this time if the `iCloud*` search scopes are actually useful within Hammerspoon as Hammerspoon is not a sandboxed application that uses the iCloud API fo document storage. Further information on your experiences with these scopes, if you use them, is welcome in the Hammerspoon Google Group or at the Hammerspoon Github web site."
    },
    "Returns the grouped results for a Spotlight query.": {
        "prefix": "hs.spotlight:groupedResults() -> table",
        "body": "hs.spotlight:groupedResults()",
        "description": "Returns the grouped results for a Spotlight query.\n\nParameters:\n * None\n\nReturns:\n * an array table containing the grouped results for the Spotlight query as specified by the [hs.spotlight:groupingAttributes](#groupingAttributes) method.  Each member of the array will be a spotlightGroupObject which is detailed in the `hs.spotlight.group` module documentation.\n\nNotes:\n * The spotlightItemObjects available with the `hs.spotlight.group:resultAtIndex` method are the subset of the full results of the spotlightObject that match the attribute and value of the spotlightGroupObject.  The same item is available through the spotlightObject and the spotlightGroupObject, though likely at different indicies."
    },
    "Get or set the grouping attributes for the Spotlight query.": {
        "prefix": "hs.spotlight:groupingAttributes([attributes]) -> table | spotlightObject",
        "body": "hs.spotlight:groupingAttributes(${1:[attributes]})",
        "description": "Get or set the grouping attributes for the Spotlight query.\n\nParameters:\n * `attributes` - an optional table or list of items specifying the grouping attributes for the Spotlight query.  Defaults to an empty array.\n\nReturns:\n * if an argument is provided, returns the spotlightObject; otherwise returns the current values\n\nNotes:\n * Setting this property while a query is running stops the query and discards the current results. The receiver immediately starts a new query.\n * Setting this property will increase CPU and memory usage while performing the Spotlight query.\n\n * Thie method allows you to access results grouped by the values of specific attributes.  See `hs.spotlight.group` for more information on using and accessing grouped results.\n * Note that not all attributes can be used as a grouping attribute.  In such cases, the grouped result will contain all results and an attribute value of nil."
    },
    "Returns a boolean specifying whether or not the query is in the active gathering phase.": {
        "prefix": "hs.spotlight:isGathering() -> boolean",
        "body": "hs.spotlight:isGathering()",
        "description": "Returns a boolean specifying whether or not the query is in the active gathering phase.\n\nParameters:\n * None\n\nReturns:\n * a boolean value of true if the query is in the active gathering phase or false if it is not.\n\nNotes:\n * An inactive query will also return false for this method since an inactive query is neither gathering nor waiting for updates.  To determine if a query is active or inactive, use the [hs.spotlight:isRunning](#isRunning) method."
    },
    "Returns a boolean specifying if the query is active or inactive.": {
        "prefix": "hs.spotlight:isRunning() -> boolean",
        "body": "hs.spotlight:isRunning()",
        "description": "Returns a boolean specifying if the query is active or inactive.\n\nParameters:\n * None\n\nReturns:\n * a boolean value of true if the query is active or false if it is inactive.\n\nNotes:\n * An active query may be gathering query results (in the initial gathering phase) or listening for changes which should cause a \"didUpdate\" message (after the initial gathering phase). To determine which state the query may be in, use the [hs.spotlight:isGathering](#isGathering) method."
    },
    "Creates a new spotlightObject to use for Spotlight searches.": {
        "prefix": "hs.spotlight.new() -> spotlightObject",
        "body": "hs.spotlight.new()",
        "description": "Creates a new spotlightObject to use for Spotlight searches.\n\nParameters:\n * None\n\nReturns:\n * a new spotlightObject"
    },
    "Creates a new spotlightObject that limits its searches to the current results of another spotlightObject.": {
        "prefix": "hs.spotlight.newWithin(spotlightObject) -> spotlightObject",
        "body": "hs.spotlight.newWithin(${1:spotlightObject})",
        "description": "Creates a new spotlightObject that limits its searches to the current results of another spotlightObject.\n\nParameters:\n * `spotlightObject` - the object whose current results are to be used to limit the scope of the new Spotlight search.\n\nReturns:\n * a new spotlightObject"
    },
    "Specify the query string for the spotlightObject": {
        "prefix": "hs.spotlight:queryString(query) -> spotlightObject",
        "body": "hs.spotlight:${1:query}String(query)",
        "description": "Specify the query string for the spotlightObject\n\nParameters:\n * a string containing the query for the spotlightObject\n\nReturns:\n * the spotlightObject\n\nNotes:\n * Setting this property while a query is running stops the query and discards the current results. The receiver immediately starts a new query.\n\n * The query string syntax is not simple enough to fully describe here.  It is a subset of the syntax supported by the Objective-C NSPredicate class.  Some references for this syntax can be found at:\n   * https://developer.apple.com/library/content/documentation/Carbon/Conceptual/SpotlightQuery/Concepts/QueryFormat.html\n   * https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Predicates/Articles/pSyntax.html\n\n * If the query string does not conform to an NSPredicate query string, this method will return an error.  If the query string does conform to an NSPredicate query string, this method will accept the query string, but if it does not conform to the Metadata query format, which is a subset of the NSPredicate query format, the error will be generated when you attempt to start the query with [hs.spotlight:start](#start). At present, starting a query is the only way to fully guarantee that a query is in a valid format.\n\n * Some of the query strings which have been used during the testing of this module are as follows (note that [[ ]] is a Lua string specifier that allows for double quotes in the content of the string):\n   * [[ kMDItemContentType == \"com.apple.application-bundle\" ]]\n   * [[ kMDItemFSName like \"*Explore*\" ]]\n   * [[ kMDItemFSName like \"AppleScript Editor.app\" or kMDItemAlternateNames like \"AppleScript Editor\"]]\n\n * Not all attributes appear to be usable in a query; see `hs.spotlight.item:attributes` for a possible explanation.\n\n * As a convenience, the __call metamethod has been setup for spotlightObject so that you can use `spotlightObject(\"query\")` as a shortcut for `spotlightObject:queryString(\"query\"):start`.  Because this shortcut includes an explicit start, this should be appended after you have set the callback function if you require a callback (e.g. `spotlightObject:setCallback(fn)(\"query\")`)."
    },
    "Returns the spotlightItemObject at the specified index of the spotlightObject": {
        "prefix": "hs.spotlight:resultAtIndex(index) -> spotlightItemObject",
        "body": "hs.spotlight:resultAtIndex(${1:index})",
        "description": "Returns the spotlightItemObject at the specified index of the spotlightObject\n\nParameters:\n * `index` - an integer specifying the index of the result to return.\n\nReturns:\n * the spotlightItemObject at the specified index or an error if the index is out of bounds.\n\nNotes:\n * For convenience, metamethods have been added to the spotlightObject which allow you to use `spotlightObject[index]` as a shortcut for `spotlightObject:resultAtIndex(index)`."
    },
    "Get or set the search scopes allowed for the Spotlight query.": {
        "prefix": "hs.spotlight:searchScopes([scope]) -> table | spotlightObject",
        "body": "hs.spotlight:searchScopes(${1:[scope]})",
        "description": "Get or set the search scopes allowed for the Spotlight query.\n\nParameters:\n * `scope` - an optional table or list of items specifying the search scope for the Spotlight query.  Defaults to an empty array, specifying that the search is not limited in scope.\n\nReturns:\n * if an argument is provided for `scope`, returns the spotlightObject; otherwise returns a table containing the current search scopes.\n\nNotes:\n * Setting this property while a query is running stops the query and discards the current results. The receiver immediately starts a new query.\n\n * Each item listed in the `scope` table may be a string or a file URL table as described in documentation for the `hs.sharing.URL` and `hs.sharing.fileURL` functions.\n   * if an item is a string and matches one of the values in the [hs.spotlight.definedSearchScopes](#definedSearchScopes) table, then the scope for that item will be added to the valid search scopes.\n   * if an item is a string and does not match one of the predefined values, it is treated as a path on the local system and will undergo tilde prefix expansion befor being added to the search scopes (i.e. \"~/\" will be expanded to \"/Users/username/\").\n   * if an item is a table, it will be treated as a file URL table."
    },
    "Set or remove the callback function for the Spotlight search object.": {
        "prefix": "hs.spotlight:setCallback(fn | nil) -> spotlightObject",
        "body": "hs.spotlight:setCallback(${1:fn | nil})",
        "description": "Set or remove the callback function for the Spotlight search object.\n\nParameters:\n * `fn` - the function to replace the current callback function.  If this argument is an explicit nil, removes the current callback function and does not replace it.  The function should expect 2 or 3 arguments and should return none.\n\nReturns:\n * the spotlightObject\n\nNotes:\n * Depending upon the messages set with the [hs.spotlight:callbackMessages](#callbackMessages) method, the following callbacks may occur:\n\n   * obj, \"didStart\" -- occurs when the initial gathering phase of a Spotlight search begins.\n     * `obj`     - the spotlightObject performing the search\n     * `message` - the message to the callback, in this case \"didStart\"\n\n   * obj, \"inProgress\", updateTable -- occurs during the initial gathering phase at intervals set by the [hs.spotlight:updateInterval](#updateInterval) method.\n     * `obj`         - the spotlightObject performing the search\n     * `message`     - the message to the callback, in this case \"inProgress\"\n     * `updateTable` - a table containing one or more of the following keys:\n       * `kMDQueryUpdateAddedItems`   - an array table of spotlightItem objects that have been added to the results\n       * `kMDQueryUpdateChangedItems` - an array table of spotlightItem objects that have changed since they were first added to the results\n       * `kMDQueryUpdateRemovedItems` - an array table of spotlightItem objects that have been removed since they were first added to the results\n\n   * obj, \"didFinish\" -- occurs when the initial gathering phase of a Spotlight search completes.\n     * `obj`     - the spotlightObject performing the search\n     * `message` - the message to the callback, in this case \"didFinish\"\n\n   * obj, \"didUpdate\", updateTable -- occurs after the initial gathering phase has completed. This indicates that a change has occurred after the initial query that affects the result set.\n     * `obj`         - the spotlightObject performing the search\n     * `message`     - the message to the callback, in this case \"didUpdate\"\n     * `updateTable` - a table containing one or more of the keys described for the `updateTable` argument of the \"inProgress\" message.\n\n * All of the results are always available through the [hs.spotlight:resultAtIndex](#resultAtIndex) method and metamethod shortcuts described in the `hs.spotlight` and `hs.spotlight.item` documentation headers; the results provided by the \"didUpdate\" and \"inProgress\" messages are just a convenience and can be used if you wish to parse partial results."
    },
    "Get or set the sorting preferences for the results of a Spotlight query.": {
        "prefix": "hs.spotlight:sortDescriptors([attributes]) -> table | spotlightObject",
        "body": "hs.spotlight:sortDescriptors(${1:[attributes]})",
        "description": "Get or set the sorting preferences for the results of a Spotlight query.\n\nParameters:\n * `attributes` - an optional table or list of items specifying sort descriptors which affect the sorting order of results for a Spotlight query.  Defaults to an empty array.\n\nReturns:\n * if an argument is provided, returns the spotlightObject; otherwise returns the current values\n\nNotes:\n * Setting this property while a query is running stops the query and discards the current results. The receiver immediately starts a new query.\n\n * A sort descriptor may be specified as a string or as a table of key-value pairs.  In the case of a string, the sort descriptor will sort items in an ascending manner.  When specified as a table, at least the following keys should be specified:\n   * `key`       - a string specifying the attribute to sort by\n   * `ascending` - a boolean, default true, specifying whether the sort order should be ascending (true) or descending (false).\n\n * This method attempts to specify the sorting order of the results returned by the Spotlight query.\n * Note that not all attributes can be used as an attribute in a sort descriptor.  In such cases, the sort descriptor will have no affect on the order of returned items."
    },
    "Begin the gathering phase of a Spotlight query.": {
        "prefix": "hs.spotlight:start() -> spotlightObject",
        "body": "hs.spotlight:start()",
        "description": "Begin the gathering phase of a Spotlight query.\n\nParameters:\n * None\n\nReturns:\n * the spotlightObject\n\nNotes:\n * If the query string set with [hs.spotlight:queryString](#queryString) is invalid, an error message will be logged to the Hammerspoon console and the query will not start.  You can test to see if the query is actually running with the [hs.spotlight:isRunning](#isRunning) method."
    },
    "Stop the Spotlight query.": {
        "prefix": "hs.spotlight:stop() -> spotlightObject",
        "body": "hs.spotlight:stop()",
        "description": "Stop the Spotlight query.\n\nParameters:\n * None\n\nReturns:\n * the spotlightObject\n\nNotes:\n * This method will prevent further gathering of items either during the initial gathering phase or from updates which may occur after the gathering phase; however it will not discard the results already discovered."
    },
    "Get or set the time interval at which the spotlightObject will send \"didUpdate\" messages during the initial gathering phase.": {
        "prefix": "hs.spotlight:updateInterval([interval]) -> number | spotlightObject",
        "body": "hs.spotlight:updateInterval(${1:[interval]})",
        "description": "Get or set the time interval at which the spotlightObject will send \"didUpdate\" messages during the initial gathering phase.\n\nParameters:\n * `interval` - an optional number, default 1.0, specifying how often in seconds the \"didUpdate\" message should be generated during the initial gathering phase of a Spotlight query.\n\nReturns:\n * if an argument is provided, returns the spotlightObject object; otherwise returns the current value."
    },
    "Get or set the attributes for which value list summaries are produced for the Spotlight query.": {
        "prefix": "hs.spotlight:valueListAttributes([attributes]) -> table | spotlightObject",
        "body": "hs.spotlight:valueListAttributes(${1:[attributes]})",
        "description": "Get or set the attributes for which value list summaries are produced for the Spotlight query.\n\nParameters:\n * `attributes` - an optional table or list of items specifying the attributes for which value list summaries are produced for the Spotlight query.  Defaults to an empty array.\n\nReturns:\n * if an argument is provided, returns the spotlightObject; otherwise returns the current values\n\nNotes:\n * Setting this property while a query is running stops the query and discards the current results. The receiver immediately starts a new query.\n * Setting this property will increase CPU and memory usage while performing the Spotlight query.\n\n * This method allows you to specify attributes for which you wish to gather summary information about.  See [hs.spotlight:valueLists](#valueLists) for more information about value list summaries.\n * Note that not all attributes can be used as a value list attribute.  In such cases, the summary for the attribute will specify all results and an attribute value of nil."
    },
    "Returns the value list summaries for the Spotlight query": {
        "prefix": "hs.spotlight:valueLists() -> table",
        "body": "hs.spotlight:valueLists()",
        "description": "Returns the value list summaries for the Spotlight query\n\nParameters:\n * None\n\nReturns:\n * an array table of the value list summaries for the Spotlight query as specified by the [hs.spotlight:valueListAttributes](#valueListAttributes) method.  Each member of the array will be a table with the following keys:\n   * `attribute` - the attribute for the summary\n   * `value`     - the value of the attribute for the summary\n   * `count`     - the number of Spotlight items in the spotlightObject results for which this attribute has this value\n\nNotes:\n * Value list summaries are a quick way to gather statistics about the number of results which match certain criteria - they do not allow you easy access to the matching members, just information about their numbers."
    },
    "Returns the name of the attribute the spotlightGroupObject results are grouped by.": {
        "prefix": "hs.spotlight.group:attribute() -> string",
        "body": "hs.spotlight.group:attribute()",
        "description": "Returns the name of the attribute the spotlightGroupObject results are grouped by.\n\nParameters:\n * None\n\nReturns:\n * the attribute name as a string"
    },
    "Returns the number of query results contained in the spotlightGroupObject.": {
        "prefix": "hs.spotlight.group:count() -> integer",
        "body": "hs.spotlight.group:count()",
        "description": "Returns the number of query results contained in the spotlightGroupObject.\n\nParameters:\n * None\n\nReturns:\n * an integer specifying the number of results that match the attribute and value represented by this spotlightGroup object.\n\nNotes:\n * For convenience, metamethods have been added to the spotlightGroupObject which allow you to use `#spotlightGroupObject` as a shortcut for `spotlightGroupObject:count()`."
    },
    "Returns the spotlightItemObject at the specified index of the spotlightGroupObject": {
        "prefix": "hs.spotlight.group:resultAtIndex(index) -> spotlightItemObject",
        "body": "hs.spotlight.group:resultAtIndex(${1:index})",
        "description": "Returns the spotlightItemObject at the specified index of the spotlightGroupObject\n\nParameters:\n * `index` - an integer specifying the index of the result to return.\n\nReturns:\n * the spotlightItemObject at the specified index or an error if the index is out of bounds.\n\nNotes:\n * For convenience, metamethods have been added to the spotlightGroupObject which allow you to use `spotlightGroupObject[index]` as a shortcut for `spotlightGroupObject:resultAtIndex(index)`."
    },
    "Returns the subgroups of the spotlightGroupObject": {
        "prefix": "hs.spotlight.group:subgroups() -> table",
        "body": "hs.spotlight.group:subgroups()",
        "description": "Returns the subgroups of the spotlightGroupObject\n\nParameters:\n * None\n\nReturns:\n * an array table containing the subgroups of the spotlightGroupObject or nil if no subgroups exist\n\nNotes:\n * Subgroups are created when you supply more than one grouping attribute to `hs.spotlight:groupingAttributes`."
    },
    "Returns the value for the attribute the spotlightGroupObject results are grouped by.": {
        "prefix": "hs.spotlight.group:value() -> value",
        "body": "hs.spotlight.group:value()",
        "description": "Returns the value for the attribute the spotlightGroupObject results are grouped by.\n\nParameters:\n * None\n\nReturns:\n * the attribute value as an appropriate data type"
    },
    "Returns a list of attributes associated with the spotlightItemObject": {
        "prefix": "hs.spotlight.item:attributes() -> table",
        "body": "hs.spotlight.item:attributes()",
        "description": "Returns a list of attributes associated with the spotlightItemObject\n\nParameters:\n * None\n\nReturns:\n * an array table containing a list of attributes associated with the result item.\n\nNotes:\n * This list of attributes is usually not a complete list of the attributes available for a given spotlightItemObject. Many of the known attribute names are included in the `hs.spotlight.commonAttributeKeys` constant array, but even this is not an exhaustive list -- an application may create and assign any key it wishes to an entity for inclusion in the Spotlight metadata database.\n\n* A common attribute, which is not usually included in the results of this method is the \"kMDItemPath\" attribute which specifies the local path to the file the entity represents. This is included here for reference, as it is a commonly desired value that is not obviously available for almost all Spotlight entries.\n * It is believed that only those keys which are explicitly set when an item is added to the Spotlight database are included in the array returned by this method. Any attribute which is calculated or restricted in a sandboxed application appears to require an explicit request. This is, however, conjecture, and when in doubt you should explicitly check for the attributes you require with [hs.spotlight.item:valueForAttribute](#valueForAttribute) and not rely solely on the results from this method."
    },
    "Returns the value for the specified attribute of the spotlightItemObject": {
        "prefix": "hs.spotlight.item:valueForAttribute(attribute) -> value",
        "body": "hs.spotlight.item:valueForAttribute(${1:attribute})",
        "description": "Returns the value for the specified attribute of the spotlightItemObject\n\nParameters:\n * `attribute` - a string specifying the attribute to get the value of for the spotlightItemObject\n\nReturns:\n * the attribute value as an appropriate data type or nil if the attribute does not exist or contains no value\n\nNotes:\n * See [hs.spotlight.item:attributes](#attributes) for information about possible attribute names.\n\n * For convenience, metamethods have been added to the spotlightItemObject which allow you to use `spotlightItemObject.attribute` as a shortcut for `spotlightItemObject:valueForAttribute(attribute)`."
    },
    "Sets/clears the button callback function for a deck": {
        "prefix": "hs.streamdeck:buttonCallback(fn)",
        "body": "hs.streamdeck:buttonCallback(${1:fn})",
        "description": "Sets/clears the button callback function for a deck\n\nParameters:\n * fn - A function to be called when a button is pressed/released on the stream deck. It should receive three arguments:\n  * The hs.streamdeck userdata object\n  * A number containing the button that was pressed/released\n  * A boolean indicating whether the button was pressed (true) or released (false)\n\nReturns:\n * The hs.streamdeck device"
    },
    "Gets the layout of buttons the device has": {
        "prefix": "hs.streamdeck:buttonLayout()",
        "body": "hs.streamdeck:buttonLayout()",
        "description": "Gets the layout of buttons the device has\n\nParamters:\n * None\n\nReturns:\n * The number of columns\n * The number of rows"
    },
    "Sets/clears a callback for reacting to device discovery events": {
        "prefix": "hs.streamdeck.discoveryCallback(fn)",
        "body": "hs.streamdeck.discoveryCallback(${1:fn})",
        "description": "Sets/clears a callback for reacting to device discovery events\n\nParameters:\n * fn - A function that will be called when a Streaming Deck is connected or disconnected. It should take the following arguments:\n  * A boolean, true if a device was connected, false if a device was disconnected\n  * An hs.streamdeck object, being the device that was connected/disconnected\n\nReturns:\n * None"
    },
    "Gets the firmware version of a deck": {
        "prefix": "hs.streamdeck:firmwareVersion()",
        "body": "hs.streamdeck:firmwareVersion()",
        "description": "Gets the firmware version of a deck\n\nParameters:\n * None\n\nReturns:\n * A string containing the firmware version of the deck"
    },
    "Gets an hs.streamdeck object for the specified device": {
        "prefix": "hs.streamdeck.getDevice(num)",
        "body": "hs.streamdeck.getDevice(${1:num})",
        "description": "Gets an hs.streamdeck object for the specified device\n\nParameters:\n * num - A number that should be within the bounds of the number of connected devices\n\nReturns:\n * An hs.streamdeck object"
    },
    "Initialises the Stream Deck driver and sets a discovery callback": {
        "prefix": "hs.streamdeck.init(fn)",
        "body": "hs.streamdeck.init(${1:fn})",
        "description": "Initialises the Stream Deck driver and sets a discovery callback\n\nParameters:\n * fn - A function that will be called when a Streaming Deck is connected or disconnected. It should take the following arguments:\n  * A boolean, true if a device was connected, false if a device was disconnected\n  * An hs.streamdeck object, being the device that was connected/disconnected\n\nReturns:\n * None\n\nNotes:\n * This function must be called before any other parts of this module are used"
    },
    "Gets the number of Stream Deck devices connected": {
        "prefix": "hs.streamdeck.numDevices()",
        "body": "hs.streamdeck.numDevices()",
        "description": "Gets the number of Stream Deck devices connected\n\nParameters:\n * None\n\nReturns:\n * A number containing the number of Stream Deck devices attached to the system"
    },
    "Resets a deck": {
        "prefix": "hs.streamdeck:reset()",
        "body": "hs.streamdeck:reset()",
        "description": "Resets a deck\n\nParameters:\n * None\n\nReturns:\n * The hs.streamdeck object"
    },
    "Gets the serial number of a deck": {
        "prefix": "hs.streamdeck:serialNumber()",
        "body": "hs.streamdeck:serialNumber()",
        "description": "Gets the serial number of a deck\n\nParameters:\n * None\n\nReturns:\n * A string containing the serial number of the deck"
    },
    "Sets the brightness of a deck": {
        "prefix": "hs.streamdeck:setBrightness(brightness)",
        "body": "hs.streamdeck:setBrightness(${1:brightness})",
        "description": "Sets the brightness of a deck\n\nParameters:\n * brightness - A whole number between 0 and 100 indicating the percentage brightness level to set\n\nReturns:\n * The hs.streamdeck device"
    },
    "Sets a button on the deck to the specified color": {
        "prefix": "hs.streamdeck:setButtonColor(button, color)",
        "body": "hs.streamdeck:setButtonColor(${1:button}, ${2:color})",
        "description": "Sets a button on the deck to the specified color\n\nParameters:\n * button - A number (from 1 to 15) describing which button to set the color on\n * color - An hs.drawing.color object\n\nReturns:\n * The hs.streamdeck object"
    },
    "Sets the image of a button on the deck": {
        "prefix": "hs.streamdeck:setButtonImage(button, image)",
        "body": "hs.streamdeck:setButtonImage(${1:button}, ${2:image})",
        "description": "Sets the image of a button on the deck\n\nParameters:\n * button - A number (from 1 to 15) describing which button to set the image for\n * image - An hs.image object\n\nReturns:\n * The hs.streamdeck object"
    },
    "Create an `hs.styledtext` object from the string provided, converting ANSI SGR color and some font sequences into the appropriate attributes.  Attributes to apply to the resulting string may also be optionally provided.": {
        "prefix": "hs.styledtext.ansi(string, [attributes]) -> styledText object",
        "body": "hs.styledtext.ansi(${1:string}, ${2:[attributes]})",
        "description": "Create an `hs.styledtext` object from the string provided, converting ANSI SGR color and some font sequences into the appropriate attributes.  Attributes to apply to the resulting string may also be optionally provided.\n\nParameters:\n * string     - The string containing the text with ANSI SGR sequences to be converted.\n * attributes - an optional table containing attribute key-value pairs to apply to the entire `hs.styledtext` object to be returned.\n\nReturns:\n * an `hs.styledtext` object\n\nNotes:\n * Because a font is required for the SGR sequences indicating Bold and Italic, the base font is determined using the following logic:\n*  * if no `attributes` table is provided, the font is assumed to be the default for `hs.drawing` as returned by the `hs.drawing.defaultTextStyle` function\n*  * if an `attributes` table is provided and it defines a `font` attribute, this font is used.\n*  * if an `attributes` table is provided, but it does not provide a `font` attribute, the NSAttributedString default of Helvetica at 12 points is used.\n * As the most common use of this constructor is likely to be from the output of a terminal shell command, you will most likely want to specify a fixed-pitch (monospace) font.  You can get a list of installed fixed-pitch fonts by typing `hs.styledtext.fontNamesWithTraits(hs.styledtext.fontTraits.fixedPitchFont)` into the Hammerspoon console.\n\n * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format which can be provided for the optional second argument.\n\n * This function was modeled after the ANSIEscapeHelper.m file at https://github.com/balthamos/geektool-3 in the /NerdTool/classes directory."
    },
    "Returns the table representation of the `hs.styledtext` object or its specified substring.": {
        "prefix": "hs.styledtext:asTable([starts], [ends]) -> table",
        "body": "hs.styledtext:asTable(${1:[starts]}, ${2:[ends]})",
        "description": "Returns the table representation of the `hs.styledtext` object or its specified substring.\n\nParameters:\n * starts - an optional index position within the text of the `hs.styledtext` object indicating the beginning of the substring to return the table for.  Defaults to 1, the beginning of the objects text.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position).\n * ends   - an optional index position within the text of the `hs.styledtext` object indicating the end of the substring to return the table for.  Defaults to the length of the objects text.  If this number is negative, it is counted backwards from the end of the object's text.\n\nReturns:\n * a table representing the `hs.styledtext` object.  The table will be an array with the following structure:\n   * index 1             - the text of the `hs.styledtext` object as a Lua String.\n   * index 2+            - a table with the following keys:\n     * starts            - the index position in the original styled text object where this list of attributes is first applied\n     * ends              - the index position in the original styled text object where the application of this list of attributes ends\n     * attributes        - a table of attribute key-value pairs that apply to the string between the positions of `starts` and `ends`\n     * unsupportedFields - this field only exists, and will be set to `true` when an attribute that was included in the attributes table that this module cannot modify.  A best effort will be made to render the attributes assigned value in the attributes table, but modifying the attribute and re-applying it with `hs.styledtext:setStyle` will be silently ignored.\n\nNotes:\n * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function.\n * The attribute which contains an attachment (image) for a converted RTFD or other document is known to set the `unsupportedFields` flag.\n\n * The indexes in the table returned are relative to their position in the original `hs.styledtext` object.  If you want the table version of a substring which does not start at index position 1 that can be safely fed as a \"proper\" table version of an `hs.styledtext` object into another function or constructor, the proper way to generate it is `destination = object:sub(i,j):asTable().\n\n * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format"
    },
    "Returns the internal numerical representation of the characters in the `hs.styledtext` object specified by the given indicies.  Mimics the Lua `string.byte` function.": {
        "prefix": "hs.styledtext:byte([starts], [ends]) -> integer, ...",
        "body": "hs.styledtext:byte(${1:[starts]}, ${2:[ends]})",
        "description": "Returns the internal numerical representation of the characters in the `hs.styledtext` object specified by the given indicies.  Mimics the Lua `string.byte` function.\n\nParameters:\n * starts - an optional index position within the text of the `hs.styledtext` object indicating the beginning of the substring to return numerical values for.  Defaults to 1, the beginning of the objects text.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position).\n * ends   - an optional index position within the text of the `hs.styledtext` object indicating the end of the substring to return numerical values for.  Defaults to the value of `starts`.  If this number is negative, it is counted backwards from the end of the object's text.\n\nReturns:\n * a list of integers representing the internal numeric representation of the characters in the `hs.styledtext` object specified by the given indicies.\n\nNotes:\n * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function."
    },
    "Converts the styledtext object into the data format specified.": {
        "prefix": "hs.styledtext:convert([type]) -> string",
        "body": "hs.styledtext:convert(${1:[type]})",
        "description": "Converts the styledtext object into the data format specified.\n\nParameters:\n * type          - a string indicating the format to convert the styletext object into.  Defaults to \"html\".  The string may be one of the following:\n   * \"text\"      - Plain text document.\n   * \"rtf\"        - Rich text format document.\n   * \"rtfd\"       - Rich text format with attachments document.\n   * \"html\"       - Hypertext Markup Language (HTML) document.\n   * \"word\"       - Microsoft Word document.\n   * \"wordXML\"    - Microsoft Word XML (WordML schema) document.\n   * \"webArchive\" - Web Kit WebArchive document.\n   * \"openXML\"    - ECMA Office Open XML text document format.\n   * \"open\"       - OASIS Open Document text document format.\n\nReturns:\n * a string containing the converted data"
    },
    "Returns the font which most closely matches the given font and the trait change requested.": {
        "prefix": "hs.styledtext.convertFont(fontTable, trait) -> table",
        "body": "hs.styledtext.convertFont(${1:fontTable}, ${2:trait})",
        "description": "Returns the font which most closely matches the given font and the trait change requested.\n\nParameters:\n * font - a string or a table which specifies a font.  If a string is given, the default system font size is assumed.  If a table is provided, it should contain the following keys:\n   * name - the name of the font (defaults to the system font)\n   * size - the point size of the font (defaults to the default system font size)\n * trait - a number corresponding to a trait listed in `hs.styledtext.fontTraits` you wish to add or remove (unboldFont and unitalicFont) from the given font, or a boolean indicating whether you want a heavier version (true) or a lighter version (false).\n\nReturns:\n * a table containing the name and size of the font which most closely matches the specified font and the trait change requested.  If no such font is available, then the original font is returned unchanged."
    },
    "Create a copy of the `hs.styledtext` object.": {
        "prefix": "hs.styledtext:copy(styledText) -> styledText object",
        "body": "hs.styledtext:copy(${1:styledText})",
        "description": "Create a copy of the `hs.styledtext` object.\n\nParameters:\n * styledText - an `hs.styledtext` object\n\nReturns:\n * a copy of the styledText object"
    },
    "A table containing the system default fonts and sizes.": {
        "prefix": "hs.styledtext.defaultFonts",
        "body": "hs.styledtext.defaultFonts",
        "description": "A table containing the system default fonts and sizes.\n\nDefined fonts included are:\n * boldSystem     - the system font used for standard interface items that are rendered in boldface type\n * controlContent - the font used for the content of controls\n * label          - the font used for standard interface labels\n * menu           - the font used for menu items\n * menuBar        - the font used for menu bar items\n * message        - the font used for standard interface items, such as button labels, menu items, etc.\n * palette        - the font used for palette window title bars\n * system         - the system font used for standard interface items, such as button labels, menu items, etc.\n * titleBar       - the font used for window title bars\n * toolTips       - the font used for tool tips labels\n * user           - the font used by default for documents and other text under the user\u2019s control\n * userFixedPitch - the font used by default for documents and other text under the user\u2019s control when that font should be fixed-pitch\n\nNotes:\n * These are useful when defining a styled text object which should be similar to or based on a specific system element type.\n\n * Because the user can change font defaults while Hammerspoon is running, this table is actually generated dynamically on request.  This should not affect of your use of this constant as a table; however, you can generate a static table if desired by invoking `hs.styledtext._defaultFonts()` directly instead."
    },
    "Returns the indicies of the first occurrence of the specified pattern in the text of the `hs.styledtext` object.  Mimics the Lua `string.find` function.": {
        "prefix": "hs.styledtext:find(pattern, [init, [plain]]) -> start, end, ... | nil",
        "body": "hs.styledtext:find(${1:pattern}, ${2:[init}, ${3:[plain]]})",
        "description": "Returns the indicies of the first occurrence of the specified pattern in the text of the `hs.styledtext` object.  Mimics the Lua `string.find` function.\n\nParameters:\n * pattern  - a string containing the pattern to locate.  See the Lua manual, section 6.4.1 (`help.lua._man._6_4_1`) for more details.\n * init     - an optional integer specifying the location within the text to start the pattern search\n * plain    - an optional boolean specifying whether or not to treat the pattern as plain text (i.e. an exact match).  Defaults to false.  If you wish to specify this argument, you must also specify init.\n\nReturns:\n * if a match is found, `start` and `end` will be the indices where the pattern was first located.  If captures were specified in the pattern, they will also be returned as additional arguments after `start` and `end`.  If the pattern was not found in the text, then this method returns nil.\n\nNotes:\n * Any captures returned are returned as Lua Strings, not as `hs.styledtext` objects."
    },
    "Returns the names of all font families installed for the system.": {
        "prefix": "hs.styledtext.fontFamilies() -> table",
        "body": "hs.styledtext.fontFamilies()",
        "description": "Returns the names of all font families installed for the system.\n\nParameters:\n * None\n\nReturns:\n * a table containing the names of every font family installed for the system."
    },
    "Get information about the font Specified in the attributes table.": {
        "prefix": "hs.styledtext.fontInfo(font) -> table",
        "body": "hs.styledtext.${1:font}Info(font)",
        "description": "Get information about the font Specified in the attributes table.\n\nParameters:\n * font - a string or a table which specifies a font.  If a string is given, the default system font size is assumed.  If a table is provided, it should contain the following keys:\n   * name - the name of the font (defaults to the system font)\n   * size - the point size of the font (defaults to the default system font size)\n\nReturns:\n * a table containing the following keys:\n   * fontName           - The font's internally recognized name.\n   * familyName         - The font's family name.\n   * displayName        - The font\u2019s display name is typically localized for the user\u2019s language.\n   * fixedPitch         - A boolean value indicating whether all glyphs in the font have the same advancement.\n   * ascender           - The top y-coordinate, offset from the baseline, of the font\u2019s longest ascender.\n   * boundingRect       - A table containing the font\u2019s bounding rectangle, scaled to the font\u2019s size.  This rectangle is the union of the bounding rectangles of every glyph in the font.\n   * capHeight          - The cap height of the font.\n   * descender          - The bottom y-coordinate, offset from the baseline, of the font\u2019s longest descender.\n   * italicAngle        - The number of degrees that the font is slanted counterclockwise from the vertical. (read-only)\n   * leading            - The leading value of the font.\n   * maximumAdvancement - A table containing the maximum advance of any of the font\u2019s glyphs.\n   * numberOfGlyphs     - The number of glyphs in the font.\n   * pointSize          - The point size of the font.\n   * underlinePosition  - The baseline offset to use when drawing underlines with the font.\n   * underlineThickness - The thickness to use when drawing underlines with the font.\n   * xHeight            - The x-height of the font."
    },
    "Returns the names of all installed fonts for the system.": {
        "prefix": "hs.styledtext.fontNames() -> table",
        "body": "hs.styledtext.fontNames()",
        "description": "Returns the names of all installed fonts for the system.\n\nParameters:\n * None\n\nReturns:\n * a table containing the names of every font installed for the system.  The individual names are strings which can be used in the `hs.drawing:setTextFont(fontname)` method."
    },
    "Returns the names of all installed fonts for the system with the specified traits.": {
        "prefix": "hs.styledtext.fontNamesWithTraits(fontTraitMask) -> table",
        "body": "hs.styledtext.fontNamesWithTraits(${1:fontTraitMask})",
        "description": "Returns the names of all installed fonts for the system with the specified traits.\n\nParameters:\n * traits - a number, specifying the fontTraitMask, or a table containing traits listed in `hs.styledtext.fontTraits` which are logically 'OR'ed together to create the fontTraitMask used.\n\nReturns:\n * a table containing the names of every font installed for the system which matches the fontTraitMask specified.  The individual names are strings which can be used in the `hs.drawing:setTextFont(fontname)` method.\n\nNotes:\n * specifying 0 or an empty table will match all fonts that are neither italic nor bold.  This would be the same list as you'd get with { hs.styledtext.fontTraits.unBold, hs.styledtext.fontTraits.unItalic } as the parameter."
    },
    "Get the path of a font.": {
        "prefix": "hs.styledtext.fontPath(font) -> table",
        "body": "hs.styledtext.${1:font}Path(font)",
        "description": "Get the path of a font.\n\nParameters:\n * font - a string containing the name of the font you want to check.\n\nReturns:\n * The path to the font or `nil` if the font name is not valid."
    },
    "Returns an array containing fonts available for the specified font family or nil if no fonts for the specified family are present.": {
        "prefix": "hs.styledtext.fontsForFamily(familyName) -> table",
        "body": "hs.styledtext.fontsForFamily(${1:familyName})",
        "description": "Returns an array containing fonts available for the specified font family or nil if no fonts for the specified family are present.\n\nParameters:\n * `familyName` - a string specifying the font family to return available fonts for. The strings should be one of the values returned by the [hs.styledtext.fontFamiles](#fontFamilies) function.\n\nReturns:\n * a table containing an array of available fonts for the specified family. Each array entry will be a table, also as an array, in the following order:\n   * a string specifying the font name which can be used in the `hs.drawing:setTextFont(fontname)` method.\n   * a string specifying the basic style of the font (e.g. Bold, Italic, Roman, etc.)\n   * a table containing one or more strings specifying common names for the weight of the font. ISO equivalent names are preceded with \"ISO:\". Possible values are:\n            `{ \"ultralight\" }`\n            `{ \"thin\", \"ISO:ultralight\" }`\n            `{ \"light\", \"extralight\", \"ISO:extralight\" }`\n            `{ \"book\", \"ISO:light\" }`\n            `{ \"regular\", \"plain\", \"display\", \"roman\", \"ISO:semilight\" }`\n            `{ \"medium\", \"ISO:medium\" }`\n            `{ \"demi\", \"demibold\" }`\n            `{ \"semi\", \"semibold\", \"ISO:semibold\" }`\n            `{ \"bold\", \"ISO:bold\" }`\n            `{ \"extra\", \"extrabold\", \"ISO:extrabold\" }`\n            `{ \"heavy\", \"heavyface\" }`\n            `{ \"black\", \"super\", \"ISO:ultrabold\" }`\n            `{ \"ultra\", \"ultrablack\", \"fat\" }`\n            `{ \"extrablack\", \"obese\", \"nord\" }`\n   * a table specifying zero or more traits for the font as defined in the [hs.styledtext.fontTraits](#fontTraits) table. A field with the key `_numeric` is also set which specified the numeric value corresponding to the traits for easy use with the [hs.styledtext.convertFont](#convertFont) function."
    },
    "A table for containing Font Trait masks for use with `hs.styledtext.fontNamesWithTraits(...)`": {
        "prefix": "hs.styledtext.fontTraits -> table",
        "body": "hs.styledtext.fontTraits",
        "description": "A table for containing Font Trait masks for use with `hs.styledtext.fontNamesWithTraits(...)`\n\n * boldFont                    - fonts with the 'Bold' attribute set\n * compressedFont              - fonts with the 'Compressed' attribute set\n * condensedFont               - fonts with the 'Condensed' attribute set\n * expandedFont                - fonts with the 'Expanded' attribute set\n * fixedPitchFont              - fonts with the 'FixedPitch' attribute set\n * italicFont                  - fonts with the 'Italic' attribute set\n * narrowFont                  - fonts with the 'Narrow' attribute set\n * posterFont                  - fonts with the 'Poster' attribute set\n * smallCapsFont               - fonts with the 'SmallCaps' attribute set\n * nonStandardCharacterSetFont - fonts with the 'NonStandardCharacterSet' attribute set\n * unboldFont                  - fonts that do not have the 'Bold' attribute set\n * unitalicFont                - fonts that do not have the 'Italic' attribute set"
    },
    "Returns the text of the `hs.styledtext` object as a Lua String": {
        "prefix": "hs.styledtext:getString([starts], [ends]) -> string",
        "body": "hs.styledtext:getString(${1:[starts]}, ${2:[ends]})",
        "description": "Returns the text of the `hs.styledtext` object as a Lua String\n\nParameters:\n * starts - an optional index position within the text of the `hs.styledtext` object indicating the beginning of the substring to return the string for.  Defaults to 1, the beginning of the objects text.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position).\n * ends   - an optional index position within the text of the `hs.styledtext` object indicating the end of the substring to return the string for.  Defaults to the length of the objects text.  If this number is negative, it is counted backwards from the end of the object's text.\n\nReturns:\n * a string containing the text of the `hs.styledtext` object specified\n\nNotes:\n * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function."
    },
    "Converts the provided data into a styled text string.": {
        "prefix": "hs.styledtext.getStyledTextFromData(data, [type]) -> styledText object",
        "body": "hs.styledtext.getStyledTextFromData(${1:data}, ${2:[type]})",
        "description": "Converts the provided data into a styled text string.\n\nParameters:\n * data          - the data, as a lua string, which contains the raw data to be converted to a styledText object\n * type          - a string indicating the format of the contents in `data`.  Defaults to \"html\".  The string may be one of the following (not all formats may be fully representable as a simple string container - see also `hs.styledtext.setTextFromFile`):\n   * \"text\"      - Plain text document.\n   * \"rtf\"        - Rich text format document.\n   * \"rtfd\"       - Rich text format with attachments document.\n   * \"simpleText\" - Macintosh SimpleText document.\n   * \"html\"       - Hypertext Markup Language (HTML) document.\n   * \"word\"       - Microsoft Word document.\n   * \"wordXML\"    - Microsoft Word XML (WordML schema) document.\n   * \"webArchive\" - Web Kit WebArchive document.\n   * \"openXML\"    - ECMA Office Open XML text document format.\n   * \"open\"       - OASIS Open Document text document format.\n\nReturns:\n * the styledText object\n\nNotes:\n * See also `hs.styledtext.getStyledTextFromFile`"
    },
    "Converts the data in the specified file into a styled text string.": {
        "prefix": "hs.styledtext.getStyledTextFromFile(file, [type]) -> styledText object",
        "body": "hs.styledtext.getStyledTextFromFile(${1:file}, ${2:[type]})",
        "description": "Converts the data in the specified file into a styled text string.\n\nParameters:\n * file          - the path to the file to use as the source for the data to convert into a styledText object\n * type          - a string indicating the format of the contents in `data`.  Defaults to \"html\".  The string may be one of the following (not all formats may be fully representable as a simple string container - see also `hs.styledtext.setTextFromFile`):\n   * \"text\"      - Plain text document.\n   * \"rtf\"        - Rich text format document.\n   * \"rtfd\"       - Rich text format with attachments document.\n   * \"simpleText\" - Macintosh SimpleText document.\n   * \"html\"       - Hypertext Markup Language (HTML) document.\n   * \"word\"       - Microsoft Word document.\n   * \"wordXML\"    - Microsoft Word XML (WordML schema) document.\n   * \"webArchive\" - Web Kit WebArchive document.\n   * \"openXML\"    - ECMA Office Open XML text document format.\n   * \"open\"       - OASIS Open Document text document format.\n\nReturns:\n * the styledText object\n\nNotes:\n * See also `hs.styledtext.getStyledTextFromData`"
    },
    "Returns an iterator function which will return the captures (or the entire pattern) of the next match of the specified pattern in the text of the `hs.styledtext` object each time it is called.  Mimics the Lua `string.gmatch` function.": {
        "prefix": "hs.styledtext:gmatch(pattern) -> iterator-function",
        "body": "hs.styledtext:gmatch(${1:pattern})",
        "description": "Returns an iterator function which will return the captures (or the entire pattern) of the next match of the specified pattern in the text of the `hs.styledtext` object each time it is called.  Mimics the Lua `string.gmatch` function.\n\nParameters:\n * pattern  - a string containing the pattern to locate.  See the Lua manual, section 6.4.1 (`help.lua._man._6_4_1`) for more details.\n\nReturns:\n * an iterator function which will return the captures (or the entire pattern) of the next match of the specified pattern in the text of the `hs.styledtext` object each time it is called.\n\nNotes:\n * Any captures (or the entire pattern) returned by the iterator are returned as Lua Strings, not as `hs.styledtext` objects."
    },
    "Determine if the `styledText` object is identical to the one specified.": {
        "prefix": "hs.styledtext:isIdentical(styledText) -> boolean",
        "body": "hs.styledtext:isIdentical(${1:styledText})",
        "description": "Determine if the `styledText` object is identical to the one specified.\n\nParameters:\n * styledText - an `hs.styledtext` object\n\nReturns:\n * a boolean value indicating whether or not the styled text objects are identical, both in text content and attributes specified.\n\nNotes:\n * comparing two `hs.styledtext` objects with the `==` operator only compares whether or not the string values are identical.  This method also compares their attributes."
    },
    "Returns the length of the text of the `hs.styledtext` object.  Mimics the Lua `string.len` function.": {
        "prefix": "hs.styledtext:len() -> integer",
        "body": "hs.styledtext:len()",
        "description": "Returns the length of the text of the `hs.styledtext` object.  Mimics the Lua `string.len` function.\n\nParameters:\n * None\n\nReturns:\n * an integer which is the length of the text of the `hs.styledtext` object."
    },
    "A table of values indicating how the line for underlining or strike-through are applied to the text.": {
        "prefix": "hs.styledtext.lineAppliesTo",
        "body": "hs.styledtext.lineAppliesTo",
        "description": "A table of values indicating how the line for underlining or strike-through are applied to the text.\n\nNotes:\n * Valid keys are as follows:\n   * line - the underline or strike-through is applied to an entire line of text\n   * word - the underline or strike-through is only applied to words and not the spaces in a line of text\n\n * When specifying a line type for underlining or strike-through, you can combine one entry from each of the following tables:\n   * hs.styledtext.lineStyles\n   * hs.styledtext.linePatterns\n   * hs.styledtext.lineAppliesTo\n\n * The entries chosen should be combined with the `or` operator to provide a single value. for example:\n   * hs.styledtext.lineStyles.single | hs.styledtext.linePatterns.dash | hs.styledtext.lineAppliesToWord"
    },
    "A table of patterns which apply to the line for underlining or strike-through.": {
        "prefix": "hs.styledtext.linePatterns",
        "body": "hs.styledtext.linePatterns",
        "description": "A table of patterns which apply to the line for underlining or strike-through.\n\nNotes:\n * Valid line pattern keys are as follows:\n   * solid      - a solid line\n   * dot        - a dotted line\n   * dash       - a dashed line\n   * dashDot    - a pattern of a dash followed by a dot\n   * dashDotDot - a pattern of a dash followed by two dots\n\n * When specifying a line type for underlining or strike-through, you can combine one entry from each of the following tables:\n   * hs.styledtext.lineStyles\n   * hs.styledtext.linePatterns\n   * hs.styledtext.lineAppliesTo\n\n * The entries chosen should be combined with the `or` operator to provide a single value. for example:\n   * hs.styledtext.lineStyles.single | hs.styledtext.linePatterns.dash | hs.styledtext.lineAppliesToWord"
    },
    "A table of styles which apply to the line for underlining or strike-through.": {
        "prefix": "hs.styledtext.lineStyles",
        "body": "hs.styledtext.lineStyles",
        "description": "A table of styles which apply to the line for underlining or strike-through.\n\nNotes:\n * Valid line style keys are as follows:\n   * none   - no line style\n   * single - a single thin line\n   * thick  - a single thick line (usually double the single line's thickness)\n   * double - double think lines\n\n * When specifying a line type for underlining or strike-through, you can combine one entry from each of the following tables:\n   * hs.styledtext.lineStyles\n   * hs.styledtext.linePatterns\n   * hs.styledtext.lineAppliesTo\n\n * The entries chosen should be combined with the `or` operator to provide a single value. for example:\n   * hs.styledtext.lineStyles.single | hs.styledtext.linePatterns.dash | hs.styledtext.lineAppliesToWord"
    },
    "Loads a font from a file at the specified path.": {
        "prefix": "hs.styledtext.loadFont(path) -> boolean[, string]",
        "body": "hs.styledtext.loadFont(${1:path})",
        "description": "Loads a font from a file at the specified path.\n\nParamaters:\n * `path` - the path and filename of the font file to attempt to load\n\nReturns:\n * If the font can be registered returns `true`, otherwise `false` and an error message as string."
    },
    "Returns a copy of the `hs.styledtext` object with all alpha characters converted to lower case.  Mimics the Lua `string.lower` function.": {
        "prefix": "hs.styledtext:lower() -> styledText object",
        "body": "hs.styledtext:lower()",
        "description": "Returns a copy of the `hs.styledtext` object with all alpha characters converted to lower case.  Mimics the Lua `string.lower` function.\n\nParameters:\n * None\n\nReturns:\n * a copy of the `hs.styledtext` object with all alpha characters converted to lower case"
    },
    "Returns the first occurrence of the captures in the specified pattern (or the complete pattern, if no captures are specified) in the text of the `hs.styledtext` object.  Mimics the Lua `string.match` function.": {
        "prefix": "hs.styledtext:match(pattern, [init]) -> match ... | nil",
        "body": "hs.styledtext:match(${1:pattern}, ${2:[init]})",
        "description": "Returns the first occurrence of the captures in the specified pattern (or the complete pattern, if no captures are specified) in the text of the `hs.styledtext` object.  Mimics the Lua `string.match` function.\n\nParameters:\n * pattern  - a string containing the pattern to locate.  See the Lua manual, section 6.4.1 (`help.lua._man._6_4_1`) for more details.\n * init     - an optional integer specifying the location within the text to start the pattern search\n\nReturns:\n * if a match is found, the captures in the specified pattern (or the complete pattern, if no captures are specified).  If the pattern was not found in the text, then this method returns nil.\n\nNotes:\n * Any captures (or the entire pattern) returned are returned as Lua Strings, not as `hs.styledtext` objects."
    },
    "Create an `hs.styledtext` object from the string or table representation provided.  Attributes to apply to the resulting string may also be optionally provided.": {
        "prefix": "hs.styledtext.new(string, [attributes]) -> styledText object",
        "body": "hs.styledtext.new(${1:string}, ${2:[attributes]})",
        "description": "Create an `hs.styledtext` object from the string or table representation provided.  Attributes to apply to the resulting string may also be optionally provided.\n\nParameters:\n * string     - a string, table, or `hs.styledtext` object to create a new `hs.styledtext` object from.\n * attributes - an optional table containing attribute key-value pairs to apply to the entire `hs.styledtext` object to be returned.\n\nReturns:\n * an `hs.styledtext` object\n\nNotes:\n * See `hs.styledtext:asTable` for a description of the table representation of an `hs.styledtext` object\n * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format which can be provided for the optional second argument.\n\n * Passing an `hs.styledtext` object as the first parameter without specifying an `attributes` table is the equivalent of invoking `hs.styledtext:copy`."
    },
    "Return a copy of the `hs.styledtext` object containing the changes to its attributes specified in the `attributes` table.": {
        "prefix": "hs.styledtext:setString(string, [starts], [ends], [clear]) -> styledText object",
        "body": "hs.styledtext:setString(${1:string}, ${2:[starts]}, ${3:[ends]}, ${4:[clear]})",
        "description": "Return a copy of the `hs.styledtext` object containing the changes to its attributes specified in the `attributes` table.\n\nParameters:\n * string     - a string, table, or `hs.styledtext` object to insert or replace the substring specified.\n * starts     - an optional index position within the text of the `hs.styledtext` object indicating the beginning of the destination for the specified string.  Defaults to 1, the beginning of the objects text.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position).\n * ends       - an optional index position within the text of the `hs.styledtext` object indicating the end of destination for the specified string.  Defaults to the length of the objects text.  If this number is negative, it is counted backwards from the end of the object's text.  If this number is 0, then the substring is inserted at the index specified by `starts` rather than replacing it.\n * clear      - an optional boolean indicating whether or not the attributes of the new string should be included (true) or whether the new substring should inherit the attributes of the first character replaced (false).  Defaults to false if `string` is a Lua String or number; otherwise defaults to true.\n\nReturns:\n * a copy of the `hs.styledtext` object with the specified substring replacement to the original object, or nil if an error occurs\n\nNotes:\n * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function except that `starts` must refer to an index preceding or equal to `ends`, even after negative and out-of-bounds indices are adjusted for.\n\n * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format"
    },
    "Returns an `hs.styledtext` object which contains `n` repetitions of the `hs.styledtext` object, optionally with `separator` between each repetition.  Mimics the Lua `string.rep` function.": {
        "prefix": "hs.styledtext:rep(n, [separator]) -> styledText object",
        "body": "hs.styledtext:rep(${1:n}, ${2:[separator]})",
        "description": "Returns an `hs.styledtext` object which contains `n` repetitions of the `hs.styledtext` object, optionally with `separator` between each repetition.  Mimics the Lua `string.rep` function.\n\nParameters:\n * n         - the number of times to repeat the `hs.styledtext` object.\n * separator - an optional string or `hs.styledtext` object to insert between repetitions.\n\nReturns:\n * an `hs.styledtext` object which contains `n` repitions of the object, including `separator` between repetitions, if it is specified."
    },
    "Return a copy of the `hs.styledtext` object containing the changes to its attributes specified in the `attributes` table._1": {
        "prefix": "hs.styledtext:setStyle(attributes, [starts], [ends], [clear]) -> styledText object",
        "body": "hs.styledtext:setStyle(${1:attributes}, ${2:[starts]}, ${3:[ends]}, ${4:[clear]})",
        "description": "Return a copy of the `hs.styledtext` object containing the changes to its attributes specified in the `attributes` table.\n\nParameters:\n * attributes - a table of attribute key-value pairs to apply to the object between the positions of `starts` and `ends`\n * starts     - an optional index position within the text of the `hs.styledtext` object indicating the beginning of the substring to set attributes for.  Defaults to 1, the beginning of the objects text.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position).\n * ends       - an optional index position within the text of the `hs.styledtext` object indicating the end of the substring to set attributes for.  Defaults to the length of the objects text.  If this number is negative, it is counted backwards from the end of the object's text.\n * clear      - an optional boolean indicating whether or not the attributes specified should completely replace the existing attributes (true) or be added to/modify them (false).  Defaults to false.\n\nReturns:\n * a copy of the `hs.styledtext` object with the attributes specified applied to the given range of the original object.\n\nNotes:\n * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function.\n\n * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format"
    },
    "Returns a substring, including the style attributes, specified by the given indicies from the `hs.styledtext` object.  Mimics the Lua `string.sub` function.": {
        "prefix": "hs.styledtext:sub(starts, [ends]) -> styledText object",
        "body": "hs.styledtext:sub(${1:starts}, ${2:[ends]})",
        "description": "Returns a substring, including the style attributes, specified by the given indicies from the `hs.styledtext` object.  Mimics the Lua `string.sub` function.\n\nParameters:\n * starts - the index position within the text of the `hs.styledtext` object indicating the beginning of the substring to return.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position).\n * ends   - an optional index position within the text of the `hs.styledtext` object indicating the end of the substring to return.  Defaults to the length of the objects text.  If this number is negative, it is counted backwards from the end of the object's text.\n\nReturns:\n * an `hs.styledtext` object containing the specified substring.\n\nNotes:\n * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function."
    },
    "Returns a copy of the `hs.styledtext` object with all alpha characters converted to upper case.  Mimics the Lua `string.upper` function.": {
        "prefix": "hs.styledtext:upper() -> styledText object",
        "body": "hs.styledtext:upper()",
        "description": "Returns a copy of the `hs.styledtext` object with all alpha characters converted to upper case.  Mimics the Lua `string.upper` function.\n\nParameters:\n * None\n\nReturns:\n * a copy of the `hs.styledtext` object with all alpha characters converted to upper case"
    },
    "Checks to see if a font is valid.": {
        "prefix": "hs.styledtext.validFont(font) -> boolean",
        "body": "hs.styledtext.validFont(${1:font})",
        "description": "Checks to see if a font is valid.\n\nParameters:\n * font - a string containing the name of the font you want to check.\n\nReturns:\n * `true` if valid, otherwise `false`."
    },
    "Places all the windows of an app into one place and tab them": {
        "prefix": "hs.tabs.enableForApp(app)",
        "body": "hs.tabs.enableForApp(${1:app})",
        "description": "Places all the windows of an app into one place and tab them\n\nParameters:\n * app - An `hs.application` object or the app title\n\nReturns:\n * None"
    },
    "Focuses a specific tab of an app": {
        "prefix": "hs.tabs.focusTab(app, num)",
        "body": "hs.tabs.focusTab(${1:app}, ${2:num})",
        "description": "Focuses a specific tab of an app\n\nParameters:\n * app - An `hs.application` object previously enabled for tabbing\n * num - A tab number to switch to\n\nReturns:\n * None\n\nNotes:\n * If num is higher than the number of tabs, the last tab will be focussed"
    },
    "Gets a list of the tabs of a window": {
        "prefix": "hs.tabs.tabWindows(app)",
        "body": "hs.tabs.tabWindows(${1:app})",
        "description": "Gets a list of the tabs of a window\n\nParameters:\n * app - An `hs.application` object\n\nReturns:\n * An array of the tabbed windows of an app in the same order as they would be tabbed\n\nNotes:\n * This function can be used when writing tab switchers"
    },
    "Definitions for reserved action IDs.": {
        "prefix": "hs.tangent.reserved.action -> table",
        "body": "hs.tangent.reserved.action",
        "description": "Definitions for reserved action IDs.\n\nNotes:\n * `alt`                     - toggles the 'ALT' function.\n * `nextKnobBank`            - switches to the next knob bank.\n * `prevKnobBank`            - switches to the previous knob bank.\n * `nextButtonBank`          - switches to the next button bank.\n * `prevBasketBank`          - switches to the previous button bank.\n * `nextTrackerballBank`     - switches to the next trackerball bank.\n * `prevTrackerballBank`     - switches to the previous trackerball bank.\n * `nextMode`                - switches to the next mode.\n * `prevMode`                - switches to the previous mode.\n * `goToMode`                - switches to the specified mode, requiring a Argument with the mode ID.\n * `toggleJogShuttle`        - toggles jog/shuttle mode.\n * `toggleMouseEmulation`    - toggles mouse emulation.\n * `fakeKeypress`            - generates a keypress, requiring an Argument with the key code.\n * `showHUD`                 - shows the HUD on screen.\n * `goToKnobBank`            - goes to the specific knob bank, requiring an Argument with the bank number.\n * `goToButtonBank`          - goes to the specific button bank, requiring an Argument with the bank number.\n * `goToTrackerballBank`     - goes to the specific trackerball bank, requiring an Argument with the bank number."
    },
    "Automatically send the \"Application Definition\" response. Defaults to `true`.": {
        "prefix": "hs.tangent.automaticallySendApplicationDefinition -> boolean",
        "body": "hs.tangent.automaticallySendApplicationDefinition",
        "description": "Automatically send the \"Application Definition\" response. Defaults to `true`."
    },
    "Sets a callback when new messages are received.": {
        "prefix": "hs.tangent.callback() -> boolean",
        "body": "hs.tangent.callback()",
        "description": "Sets a callback when new messages are received.\n\nParameters:\n * callbackFn - a function to set as the callback for `hs.tangent`. If the value provided is `nil`, any currently existing callback function is removed.\n\nReturns:\n * `true` if successful otherwise `false`\n\nNotes:\n * Full documentation for the Tangent API can be downloaded [here](http://www.tangentwave.co.uk/download/developer-support-pack/).\n * The callback function should expect 1 argument and should not return anything.\n * The 1 argument will be a table, which can contain one or many commands. Each command is it's own table with the following contents:\n   * id - the message ID of the incoming message\n   * metadata - A table of data for the Tangent command (see below).\n * The metadata table will return the following, depending on the `id` for the callback:\n   * `connected` - Connection to Tangent Hub successfully established.\n   * `disconnected` - The connection to Tangent Hub was dropped.\n   * `initiateComms` - Initiates communication between the Hub and the application.\n     * `protocolRev` - The revision number of the protocol.\n     * `numPanels` - The number of panels connected.\n     * `panels`\n       * `panelID` - The ID of the panel.\n       * `panelType` - The type of panel connected.\n     * `data` - The raw data from the Tangent Hub\n   * `parameterChange` - Requests that the application increment a parameter.\n     * `paramID` - The ID value of the parameter.\n     * `increment` - The incremental value which should be applied to the parameter.\n   * `parameterReset` - Requests that the application changes a parameter to its reset value.\n     * `paramID` - The ID value of the parameter.\n   * `parameterValueRequest` - Requests that the application sends a `ParameterValue (0x82)` command to the Hub.\n     * `paramID` - The ID value of the parameter.\n   * `menuChange` - Requests the application change a menu index by +1 or -1.\n     * `menuID` - The ID value of the menu.\n     * `increment` - The incremental amount by which the menu index should be changed which will always be an integer value of +1 or -1.\n   * `menuReset` - Requests that the application changes a menu to its reset value.\n     * `menuID` - The ID value of the menu.\n   * `menuStringRequest` - Requests that the application sends a `MenuString (0x83)` command to the Hub.\n     * `menuID` - The ID value of the menu.\n   * `actionOn` - Requests that the application performs the specified action.\n     * `actionID` - The ID value of the action.\n   * `modeChange` - Requests that the application changes to the specified mode.\n     * `modeID` - The ID value of the mode.\n   * `transport` - Requests the application to move the currently active transport.\n     * `jogValue` - The number of jog steps to move the transport.\n     * `shuttleValue` - An incremental value to add to the shuttle speed.\n   * `actionOff` - Requests that the application cancels the specified action.\n     * `actionID` - The ID value of the action.\n   * `unmanagedPanelCapabilities` - Only used when working in Unmanaged panel mode. Sent in response to a `UnmanagedPanelCapabilitiesRequest (0xA0)` command.\n     * `panelID` - The ID of the panel as reported in the `InitiateComms` command.\n     * `numButtons` - The number of buttons on the panel.\n     * `numEncoders` - The number of encoders on the panel.\n     * `numDisplays` - The number of displays on the panel.\n     * `numDisplayLines` - The number of lines for each display on the panel.\n     * `numDisplayChars` - The number of characters on each line of each display on the panel.\n   * `unmanagedButtonDown` - Only used when working in Unmanaged panel mode. Issued when a button has been pressed.\n     * `panelID` - The ID of the panel as reported in the `InitiateComms` command.\n     * `buttonID` - The hardware ID of the button\n   * `unmanagedButtonUp` - Only used when working in Unmanaged panel mode. Issued when a button has been released.\n     * `panelID` - The ID of the panel as reported in the `InitiateComms` command.\n     * `buttonID` - The hardware ID of the button.\n   * `unmanagedEncoderChange` - Only used when working in Unmanaged panel mode. Issued when an encoder has been moved.\n     * `panelID` - The ID of the panel as reported in the `InitiateComms` command.\n     * `paramID` - The hardware ID of the encoder.\n     * `increment` - The incremental value.\n   * `unmanagedDisplayRefresh` - Only used when working in Unmanaged panel mode. Issued when a panel has been connected or the focus of the panel has been returned to your application.\n     * `panelID` - The ID of the panel as reported in the `InitiateComms` command.\n   * `panelConnectionState`\n     * `panelID` - The ID of the panel as reported in the `InitiateComms` command.\n     * `state` - The connected state of the panel, `true` if connected, `false` if disconnected."
    },
    "Connects to the Tangent Hub.": {
        "prefix": "hs.tangent.connect(applicationName, systemPath[, userPath]) -> boolean, errorMessage",
        "body": "hs.tangent.connect(${1:applicationName}, ${2:systemPath[}, ${3:userPath]})",
        "description": "Connects to the Tangent Hub.\n\nParameters:\n * applicationName - Your application name as a string\n * systemPath - A string containing the absolute path of the directory that contains the Controls and Default Map XML files.\n * [userPath] - An optional string containing the absolute path of the directory that contains the User\u2019s Default Map XML files.\n\nReturns:\n * success - `true` on success, otherwise `nil`\n * errorMessage - The error messages as a string or `nil` if `success` is `true`."
    },
    "Checks to see whether or not you're successfully connected to the Tangent Hub.": {
        "prefix": "hs.tangent.connected() -> boolean",
        "body": "hs.tangent.connected()",
        "description": "Checks to see whether or not you're successfully connected to the Tangent Hub.\n\nParameters:\n * None\n\nReturns:\n * `true` if connected, otherwise `false`"
    },
    "Disconnects from the Tangent Hub.": {
        "prefix": "hs.tangent.disconnect() -> none",
        "body": "hs.tangent.disconnect()",
        "description": "Disconnects from the Tangent Hub.\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Definitions for IPC Commands from the HUB to Hammerspoon.": {
        "prefix": "hs.tangent.fromHub -> table",
        "body": "hs.tangent.fromHub",
        "description": "Definitions for IPC Commands from the HUB to Hammerspoon.\n\nNotes:\n * `connected`                       - a connection is established with the Hub.\n * `disconnected`                    - the connection is dropped with the Hub.\n * `initiateComms`                   - sent when the Hub wants to initiate communications.\n * `parameterChange`                 - a parameter was incremented.\n * `parameterReset`                  - a parameter was reset.\n * `parameterValueRequest`           - the Hub wants the current value of the parameter.\n * `menuChange`                      - The menu was changed, `+1` or `-1`.\n * `menuReset`                       - The menu was reset.\n * `menuStringRequest`               - The application should send a `menuString` with the current value.\n * `actionOn`                        - An action button was pressed.\n * `actionOff`                       - An action button was released.\n * `modeChange`                      - The current mode was changed.\n * `transport`                       - The transport.\n * `unmanagedPanelCapabilities`      - Send by the Hub to advertise an unmanaged panel.\n * `unmanagedButtonDown`             - A button on an unmanaged panel was pressed.\n * `unmanagedButtonUp`               - A button on an unmanaged panel was released.\n * `unmanagedEncoderChange`          - An encoder (dial/wheel) on an unmanaged panel changed.\n * `unmanagedDisplayRefresh`         - Triggered when an unmanaged panel's display needs to update.\n * `panelConnectionState`            - A panel's connection state changed."
    },
    "IP Address that the Tangent Hub is located at. Defaults to 127.0.0.1.": {
        "prefix": "hs.tangent.ipAddress -> number",
        "body": "hs.tangent.ipAddress",
        "description": "IP Address that the Tangent Hub is located at. Defaults to 127.0.0.1."
    },
    "Checks to see whether or not the Tangent Hub software is installed.": {
        "prefix": "hs.tangent.isTangentHubInstalled() -> boolean",
        "body": "hs.tangent.isTangentHubInstalled()",
        "description": "Checks to see whether or not the Tangent Hub software is installed.\n\nParameters:\n * None\n\nReturns:\n * `true` if Tangent Hub is installed otherwise `false`."
    },
    "Tangent Panel Types.": {
        "prefix": "hs.tangent.panelType -> table",
        "body": "hs.tangent.panelType",
        "description": "Tangent Panel Types."
    },
    "A table of reserved parameter IDs.": {
        "prefix": "hs.tangent.reserved.parameter -> table",
        "body": "hs.tangent.reserved.parameter",
        "description": "A table of reserved parameter IDs.\n\nNotes:\n * `transportRing`           - transport ring.\n * `fakeKeypress`            - sends a fake keypress."
    },
    "The port that Tangent Hub monitors. Defaults to 64246.": {
        "prefix": "hs.tangent.port -> number",
        "body": "hs.tangent.port",
        "description": "The port that Tangent Hub monitors. Defaults to 64246."
    },
    "Sends a \"bytestring\" message to the Tangent Hub. This should be a full": {
        "prefix": "hs.tangent.send(byteString) -> boolean, string",
        "body": "hs.tangent.send(${1:byteString})",
        "description": "Sends a \"bytestring\" message to the Tangent Hub. This should be a full\nencoded string for the command you want to send, withouth the leading 'size' section,\nwhich the function will calculate automatically.\n\nIn general, you should use the more specific functions that package the command for you,\nsuch as `sendParameterValue(...)`. This function can be used to send a message that\nthis API doesn't yet support.\n\nParameters:\n * byteString   - The string of bytes to send to tangent.\n\nReturns:\n * success - `true` if connected, otherwise `false`\n * errorMessage - An error message if an error occurs, as a string\n\nNotes:\n * Full documentation for the Tangent API can be downloaded [here](http://www.tangentwave.co.uk/download/developer-support-pack/)."
    },
    "Tells the Hub that a large number of software-controls have changed.": {
        "prefix": "hs.tangent.sendAllChange() -> boolean, string",
        "body": "hs.tangent.sendAllChange()",
        "description": "Tells the Hub that a large number of software-controls have changed.\nThe Hub responds by requesting all the current values of\nsoftware-controls it is currently controlling.\n\nParameters:\n * None\n\nReturns:\n * `true` if successful, or `false` and an error message if not."
    },
    "Sends the application details to the Tangent Hub.": {
        "prefix": "hs.tangent.sendApplicationDefinition([appName, systemPath, userPath]) -> boolean, string",
        "body": "hs.tangent.sendApplicationDefinition(${1:[appName}, ${2:systemPath}, ${3:userPath]})",
        "description": "Sends the application details to the Tangent Hub.\nIf no details are provided the ones stored in the module are used.\n\nParameters:\n * appName       - The human-readable name of the application.\n * systemPath    - A string containing the absolute path of the directory that contains the Controls and Default Map XML files (Path String)\n * userPath      - A string containing the absolute path of the directory that contains the User\u2019s Default Map XML files (Path String)\n\nReturns:\n * `true` if successful, `false` and an error message if there was a problem."
    },
    " * Updates the Hub with a number of character strings that will be displayed": {
        "prefix": "hs.tangent.sendDisplayText(messages[, doubleHeight]) -> boolean, string",
        "body": "hs.tangent.sendDisplayText(${1:messages[}, ${2:doubleHeight]})",
        "description": " * Updates the Hub with a number of character strings that will be displayed\n  on connected panels if there is space.\n * Strings may either be 32 character, single height or 16 character\n  double-height. They will be displayed in the order received; the first\n  string displayed at the top of the display.\n * If a string is not defined as double-height then it will occupy the\n  next line.\n * If a string is defined as double-height then it will occupy the next\n  2 lines.\n * The maximum number of lines which will be used by the application\n  must be indicated in the Controls XML file.\n * Text which exceeds 32 (single-height) or 16 (double-height) characters will be truncated.\n\nExample:\n\n```lua\nhs.tangent.sendDisplayText(\n    { \"Single Height\", \"Double Height\" }, {false, true}\n)\n```\n\nIf all text is single-height, the `doubleHeight` table can be omitted.\n\nParameters:\n * messages      - A list of messages to send.\n * doubleHeight  - An optional list of `boolean`s indicating if the corresponding message is double-height.\n\nReturns:\n * `true` if successful, or `false` and an error message if not."
    },
    " * Highlights the control on any panel where this feature is available.": {
        "prefix": "hs.tangent.sendHighlightControl(targetID, active) -> boolean, string",
        "body": "hs.tangent.sendHighlightControl(${1:targetID}, ${2:active})",
        "description": " * Highlights the control on any panel where this feature is available.\n * When applied to Modes, buttons which are mapped to the reserved \"Go To\n  Mode\" action for this particular mode will highlight.\n\nParameters:\n * targetID      - The id of any application defined Parameter, Menu, Action or Mode (Unsigned Int)\n * active        - If `true`, the control is highlighted, otherwise it is not.\n\nReturns:\n * `true` if sent successfully, `false` and an error message if no."
    },
    " * Sets the Indicator of the control on any panel where this feature is": {
        "prefix": "hs.tangent.sendIndicateControl(targetID, indicated) -> boolean, string",
        "body": "hs.tangent.sendIndicateControl(${1:targetID}, ${2:indicated})",
        "description": " * Sets the Indicator of the control on any panel where this feature is\n  available.\n * This indicator is driven by the `atDefault` argument for Parameters and\n  Menus. This command therefore only applies to controls mapped to Actions\n  and Modes.\n * When applied to Modes, buttons which are mapped to the reserved \"Go To\n  Mode\" action for this particular mode will have their indicator set.\n\nParameters:\n * targetID      - The id of any application defined Parameter, Menu, Action or Mode\n * active        - If `true`, the control is indicated, otherwise it is not.\n\nReturns:\n * `true` if sent successfully, `false` and an error message if no."
    },
    "Updates the Hub with a menu value.": {
        "prefix": "hs.tangent.sendMenuString(menuID, value[, atDefault]) -> boolean, string",
        "body": "hs.tangent.sendMenuString(${1:menuID}, ${2:value[}, ${3:atDefault]})",
        "description": "Updates the Hub with a menu value.\nThe Hub then updates the displays of any panels which are currently\nshowing the menu.\nIf a value of `nil` is sent then the Hub will not attempt to display a\nvalue for the menu. However the `atDefault` flag will still be recognised.\n\nParameters:\n * menuID - The ID value of the menu (Unsigned Int)\n * value - The current \u2018value\u2019 of the parameter represented as a string\n * atDefault - if `true` the value represents the default. Otherwise `false`.\n\nReturns:\n * `true` if successful, or `false` and an error message if not."
    },
    "Updates the Hub with a mode value.": {
        "prefix": "hs.tangent.sendModeValue(modeID) -> boolean, string",
        "body": "hs.tangent.sendModeValue(${1:modeID})",
        "description": "Updates the Hub with a mode value.\nThe Hub then changes mode and requests all the current values of\nsoftware-controls it is controlling.\n\nParameters:\n * modeID - The ID value of the mode (Unsigned Int)\n\nReturns:\n * `true` if successful, or `false` and an error message if not."
    },
    " * Requests the Hub to respond with a sequence of PanelConnectionState": {
        "prefix": "hs.tangent.sendPanelConnectionStatesRequest())",
        "body": "hs.tangent.sendPanelConnectionStatesRequest())",
        "description": " * Requests the Hub to respond with a sequence of PanelConnectionState\n  (0x35) commands to report the connected/disconnected status of each\n  configured panel.\n * A single request may result in multiple state responses.\n\nParameters:\n * None\n\nReturns:\n * `true` if sent successfully, `false` and an error message if not."
    },
    "Updates the Hub with a parameter value.": {
        "prefix": "hs.tangent.sendParameterValue(paramID, value[, atDefault]) -> boolean, string",
        "body": "hs.tangent.sendParameterValue(${1:paramID}, ${2:value[}, ${3:atDefault]})",
        "description": "Updates the Hub with a parameter value.\nThe Hub then updates the displays of any panels which are currently\nshowing the parameter value.\n\nParameters:\n * paramID - The ID value of the parameter (Unsigned Int)\n * value - The current value of the parameter (Float)\n * atDefault - if `true` the value represents the default. Defaults to `false`.\n\nReturns:\n * `true` if successful, or `false` and an error message if not."
    },
    " * Renames a control dynamically.": {
        "prefix": "hs.tangent.sendRenameControl(targetID, newName) -> boolean, string",
        "body": "hs.tangent.sendRenameControl(${1:targetID}, ${2:newName})",
        "description": " * Renames a control dynamically.\n * The string supplied will replace the normal text which has been\n  derived from the Controls XML file.\n * To remove any existing replacement name set `newName` to `\"\"`,\n  this will remove any renaming and return the system to the normal\n  display text\n * When applied to Modes, the string displayed on buttons which mapped to\n  the reserved \"Go To Mode\" action for this particular mode will also change.\n\nParameters:\n * targetID  - The id of any application defined Parameter, Menu, Action or Mode (Unsigned Int)\n * newName   - The new name to apply.\n\nReturns:\n * `true` if successful, `false` and an error message if not."
    },
    " * Only used when working in Unmanaged panel mode.": {
        "prefix": "hs.tangent.sendUnmanagedDisplayWrite(panelID, displayID, lineNum, pos, message) -> boolean, string",
        "body": "hs.tangent.sendUnmanagedDisplayWrite(${1:panelID}, ${2:displayID}, ${3:lineNum}, ${4:pos}, ${5:message})",
        "description": " * Only used when working in Unmanaged panel mode.\n * Updates the Hub with text that will be displayed on a specific panel at\n  the given line and starting position where supported by the panel capabilities.\n * If the most significant bit of any individual text character in `message`\n  is set it will be displayed as inversed with dark text on a light background.\n\nParameters:\n * panelID       - The ID of the panel as reported in the InitiateComms command (Unsigned Int)\n * displayID     - The ID of the display to be written to (Unsigned Int)\n * lineNum       - The line number of the display to be written to with `1` as the top line (Unsigned Int)\n * pos           - The position on the line to start writing from with `1` as the first column (Unsigned Int)\n * message       - A line of text (Character String)\n\nReturns:\n * `true` if successful, or `false` and an error message if not."
    },
    " * Only used when working in Unmanaged panel mode": {
        "prefix": "hs.tangent.sendUnmanagedPanelCapabilitiesRequest(panelID) -> boolean, string",
        "body": "hs.tangent.sendUnmanagedPanelCapabilitiesRequest(${1:panelID})",
        "description": " * Only used when working in Unmanaged panel mode\n * Requests the Hub to respond with an UnmanagedPanelCapabilities (0x30) command.\n\nParameters:\n * panelID - The ID of the panel as reported in the InitiateComms command (Unsigned Int)\n\nReturns:\n * `true` if successful, or `false` and an error message if not."
    },
    "Sets the Log Level.": {
        "prefix": "hs.tangent.setLogLevel(loglevel) -> none",
        "body": "hs.tangent.setLogLevel(${1:loglevel})",
        "description": "Sets the Log Level.\n\nParameters:\n * loglevel - can be 'nothing', 'error', 'warning', 'info', 'debug', or 'verbose'; or a corresponding number between 0 and 5\n\nReturns:\n * None"
    },
    "Definitions for IPC Commands from Hammerspoon to the HUB.": {
        "prefix": "hs.tangent.toHub -> table",
        "body": "hs.tangent.toHub",
        "description": "Definitions for IPC Commands from Hammerspoon to the HUB."
    },
    "Closes the task's stdin": {
        "prefix": "hs.task:closeInput() -> hs.task object",
        "body": "hs.task:closeInput()",
        "description": "Closes the task's stdin\n\nParameters:\n * None\n\nReturns:\n * The hs.task object\n\nNotes:\n * This should only be called on tasks with a streaming callback - tasks without it will automatically close stdin when any data supplied via `hs.task:setInput()` has been written\n * This is primarily useful for sending EOF to long-running tasks"
    },
    "Returns the environment variables as a table for the task.": {
        "prefix": "hs.task:environment() -> environment",
        "body": "hs.task:environment()",
        "description": "Returns the environment variables as a table for the task.\n\nParameters:\n * None\n\nReturns:\n * a table of the environment variables for the task where each key is the environment variable name.\n\nNote:\n * if you have not yet set an environment table with the `hs.task:setEnvironment` method, this method will return a copy of the Hammerspoon environment table, as this is what the task will inherit by default."
    },
    "Interrupts the task": {
        "prefix": "hs.task:interrupt() -> hs.task object",
        "body": "hs.task:interrupt()",
        "description": "Interrupts the task\n\nParameters:\n * None\n\nReturns:\n * The `hs.task` object\n\nNotes:\n * This will send SIGINT to the process"
    },
    "Test if a task is still running.": {
        "prefix": "hs.task:isRunning() -> boolean",
        "body": "hs.task:isRunning()",
        "description": "Test if a task is still running.\n\nParameters:\n * None\n\nReturns:\n * true if the task is running or false if it is not.\n\nNotes:\n * A task which has not yet been started yet will also return false."
    },
    "Creates a new hs.task object": {
        "prefix": "hs.task.new(launchPath, callbackFn[, streamCallbackFn][, arguments]) -> hs.task object",
        "body": "hs.task.new(${1:launchPath}, ${2:callbackFn[}, ${3:streamCallbackFn][}, ${4:arguments]})",
        "description": "Creates a new hs.task object\n\nParameters:\n * launchPath - A string containing the path to an executable file.  This must be the full path to an executable and not just an executable which is in your environment's path (e.g. `/bin/ls` rather than just `ls`).\n * callbackFn - A callback function to be called when the task terminates, or nil if no callback should be called. The function should accept three arguments:\n  * exitCode - An integer containing the exit code of the process\n  * stdOut - A string containing the standard output of the process\n  * stdErr - A string containing the standard error output of the process\n * streamCallbackFn - A optional callback function to be called whenever the task outputs data to stdout or stderr. The function must return a boolean value - true to continue calling the streaming callback, false to stop calling it. The function should accept three arguments:\n  * task - The hs.task object or nil if this is the final output of the completed task.\n  * stdOut - A string containing the standard output received since the last call to this callback\n  * stdErr - A string containing the standard error output received since the last call to this callback\n * arguments - An optional table of command line argument strings for the executable\n\nReturns:\n * An `hs.task` object\n\nNotes:\n * The arguments are not processed via a shell, so you do not need to do any quoting or escaping. They are passed to the executable exactly as provided.\n * When using a stream callback, the callback may be invoked one last time after the termination callback has already been invoked. In this case, the `task` argument to the stream callback will be `nil` rather than the task userdata object and the return value of the stream callback will be ignored."
    },
    "Pauses the task": {
        "prefix": "hs.task:pause() -> boolean",
        "body": "hs.task:pause()",
        "description": "Pauses the task\n\nParameters:\n * None\n\nReturns:\n *  If the task was paused successfully, returns the task object; otherwise returns false\n\nNotes:\n * If the task is not paused, the error message will be printed to the Hammerspoon Console\n * This method can be called multiple times, but a matching number of `hs.task:resume()` calls will be required to allow the process to continue"
    },
    "Gets the PID of a running/finished task": {
        "prefix": "hs.task:pid() -> integer",
        "body": "hs.task:pid()",
        "description": "Gets the PID of a running/finished task\n\nParameters:\n * None\n\nReturns:\n * An integer containing the PID of the task\n\nNotes:\n * The PID will still be returned if the task has already completed and the process terminated"
    },
    "Resumes the task": {
        "prefix": "hs.task:resume() -> boolean",
        "body": "hs.task:resume()",
        "description": "Resumes the task\n\nParameters:\n * None\n\nReturns:\n *  If the task was resumed successfully, returns the task object; otherwise returns false\n\nNotes:\n * If the task is not resumed successfully, the error message will be printed to the Hammerspoon Console"
    },
    "Set or remove a callback function for a task.": {
        "prefix": "hs.task:setCallback(fn) -> hs.task object",
        "body": "hs.task:setCallback(${1:fn})",
        "description": "Set or remove a callback function for a task.\n\nParameters:\n * fn - A function to be called when the task completes or is terminated, or nil to remove an existing callback\n\nReturns:\n * the hs.task object"
    },
    "Sets the environment variables for the task.": {
        "prefix": "hs.task:setEnvironment(environment) -> hs.task object | false",
        "body": "hs.task:setEnvironment(${1:environment})",
        "description": "Sets the environment variables for the task.\n\nParameters:\n * environment - a table of key-value pairs representing the environment variables that will be set for the task.\n\nReturns:\n * The hs.task object, or false if the table was not set (usually because the task is already running or has completed)\n\nNote:\n * If you do not set an environment table with this method, the task will inherit the environment variables of the Hammerspoon application.  Set this to an empty table if you wish for no variables to be set for the task."
    },
    "Sets the standard input data for a task": {
        "prefix": "hs.task:setInput(inputData) -> hs.task object",
        "body": "hs.task:setInput(${1:inputData})",
        "description": "Sets the standard input data for a task\n\nParameters:\n * inputData - Data, in string form, to pass to the task as its standard input\n\nReturns:\n * The hs.task object\n\nNotes:\n * This method can be called before the task has been started, to prepare some input for it (particularly if it is not a streaming task)\n * If this method is called multiple times, any input that has not been passed to the task already, is discarded (for streaming tasks, the data is generally consumed very quickly, but for now there is no way to syncronise this)"
    },
    "Set a stream callback function for a task": {
        "prefix": "hs.task:setStreamingCallback(fn) -> hs.task object",
        "body": "hs.task:setStreamingCallback(${1:fn})",
        "description": "Set a stream callback function for a task\n\nParameters:\n * fn - A function to be called when the task outputs to stdout or stderr, or nil to remove a callback\n\nReturns:\n * The hs.task object\n\nNotes:\n * For information about the requirements of the callback function, see `hs.task.new()`\n * If a callback is removed without it previously having returned false, any further stdout/stderr output from the task will be silently discarded"
    },
    "Sets the working directory for the task.": {
        "prefix": "hs.task:setWorkingDirectory(path) -> hs.task object | false",
        "body": "hs.task:setWorkingDirectory(${1:path})",
        "description": "Sets the working directory for the task.\n\nParameters:\n * path - a string containing the path you wish to be the working directory for the task.\n\nReturns:\n * The hs.task object, or false if the working directory was not set (usually because the task is already running or has completed)\n\nNotes:\n * You can only set the working directory if the task has not already been started.\n * This will only set the directory that the task starts in.  The task itself can change the directory while it is running."
    },
    "Starts the task": {
        "prefix": "hs.task:start() -> hs.task object | false",
        "body": "hs.task:start()",
        "description": "Starts the task\n\nParameters:\n * None\n\nReturns:\n *  If the task was started successfully, returns the task object; otherwise returns false\n\nNotes:\n * If the task does not start successfully, the error message will be printed to the Hammerspoon Console"
    },
    "Terminates the task": {
        "prefix": "hs.task:terminate() -> hs.task object",
        "body": "hs.task:terminate()",
        "description": "Terminates the task\n\nParameters:\n * None\n\nReturns:\n * The `hs.task` object\n\nNotes:\n * This will send SIGTERM to the process"
    },
    "Returns the termination reason for a task, or false if the task is still running.": {
        "prefix": "hs.task:terminationReason() -> exitCode | false",
        "body": "hs.task:terminationReason()",
        "description": "Returns the termination reason for a task, or false if the task is still running.\n\nParameters:\n * None\n\nReturns:\n * a string value of \"exit\" if the process exited normally or \"interrupt\" if it was killed by a signal.  Returns false if the termination reason is unavailable (the task is still running, or has not yet been started)."
    },
    "Returns the termination status of a task, or false if the task is still running.": {
        "prefix": "hs.task:terminationStatus() -> exitCode | false",
        "body": "hs.task:terminationStatus()",
        "description": "Returns the termination status of a task, or false if the task is still running.\n\nParameters:\n * None\n\nReturns:\n * the numeric exitCode of the task, or the boolean false if the task has not yet exited (either because it has not yet been started or because it is still running)."
    },
    "Blocks Hammerspoon until the task exits": {
        "prefix": "hs.task:waitUntilExit() -> hs.task object",
        "body": "hs.task:waitUntilExit()",
        "description": "Blocks Hammerspoon until the task exits\n\nParameters:\n * None\n\nReturns:\n * The `hs.task` object\n\nNotes:\n * All Lua and Hammerspoon activity will be blocked by this method. Its use is highly discouraged."
    },
    "Returns the working directory for the task.": {
        "prefix": "hs.task:workingDirectory() -> path",
        "body": "hs.task:workingDirectory()",
        "description": "Returns the working directory for the task.\n\nParameters:\n * None\n\nReturns:\n * a string containing the working directory for the task.\n\nNotes:\n * This only returns the directory that the task starts in.  If the task changes the directory itself, this value will not reflect that change."
    },
    "Returns the absolute time in nanoseconds since the last system boot.": {
        "prefix": "hs.timer.absoluteTime() -> nanoseconds",
        "body": "hs.timer.absoluteTime()",
        "description": "Returns the absolute time in nanoseconds since the last system boot.\n\nParameters:\n * None\n\nReturns:\n * the time since the last system boot in nanoseconds\n\nNotes:\n * this value does not include time that the system has spent asleep\n * this value is used for the timestamps in system generated events."
    },
    "Converts days to seconds": {
        "prefix": "hs.timer.days(n) -> sec",
        "body": "hs.timer.days(${1:n})",
        "description": "Converts days to seconds\n\nParameters:\n * n - A number of days\n\nReturns:\n * The number of seconds in n days"
    },
    "Calls a function after a delay": {
        "prefix": "hs.timer.doAfter(sec, fn) -> timer",
        "body": "hs.timer.doAfter(${1:sec}, ${2:fn})",
        "description": "Calls a function after a delay\n\nParameters:\n * sec - A number of seconds to wait before calling the function\n * fn - A function to call\n\nReturns:\n * An `hs.timer` object\n\nNotes:\n * There is no need to call `:start()` on the returned object, the timer will be already running.\n * The callback can be cancelled by calling the `:stop()` method on the returned object before `sec` seconds have passed."
    },
    "Creates and starts a timer which will perform `fn` at the given (local) `time` and then (optionally) repeat it every `interval`.": {
        "prefix": "hs.timer.doAt(time[, repeatInterval], fn[, continueOnError]) -> timer",
        "body": "hs.timer.doAt(${1:time[}, ${2:repeatInterval]}, ${3:fn[}, ${4:continueOnError]})",
        "description": "Creates and starts a timer which will perform `fn` at the given (local) `time` and then (optionally) repeat it every `interval`.\n\nParameters:\n * time - number of seconds after (local) midnight, or a string in the format \"HH:MM\" (24-hour local time), indicating\n   the desired trigger time\n * repeatInterval - (optional) number of seconds between triggers, or a string in the format\n   \"DDd\", \"DDdHHh\", \"HHhMMm\", \"HHh\" or \"MMm\" indicating days, hours and/or minutes between triggers; if omitted\n   or `0` the timer will trigger only once\n * fn - a function to call every time the timer triggers\n * continueOnError - an optional boolean flag, defaulting to false, which indicates that the timer should not be automatically stopped if the callback function results in an error.\n\nReturns:\n * a timer object\n\nNotes:\n * The timer can trigger up to 1 second early or late\n * The first trigger will be set to the earliest occurrence given the `repeatInterval`; if that's omitted,\n   and `time` is earlier than the current time, the timer will trigger the next day. If the repeated interval\n   results in exactly 24 hours you can schedule regular jobs that will run at the expected time independently\n   of when Hammerspoon was restarted/reloaded. E.g.:\n   * If it's 19:00, `hs.timer.doAt(\"20:00\",somefn)` will set the timer 1 hour from now\n   * If it's 21:00, `hs.timer.doAt(\"20:00\",somefn)` will set the timer 23 hours from now\n   * If it's 21:00, `hs.timer.doAt(\"20:00\",\"6h\",somefn)` will set the timer 5 hours from now (at 02:00)\n   * To run a job every hour on the hour from 8:00 to 20:00: `for h=8,20 do hs.timer.doAt(h..\":00\",\"1d\",runJob) end`"
    },
    "Repeats fn every interval seconds.": {
        "prefix": "hs.timer.doEvery(interval, fn) -> timer",
        "body": "hs.timer.doEvery(${1:interval}, ${2:fn})",
        "description": "Repeats fn every interval seconds.\n\nParameters:\n * interval - A number of seconds between triggers\n * fn - A function to call every time the timer triggers\n\nReturns:\n * An `hs.timer` object\n\nNotes:\n * This function is a shorthand for `hs.timer.new(interval, fn):start()`"
    },
    "Creates and starts a timer which will perform `actionFn` every `checkinterval` seconds until `predicateFn` returns true.  The timer is automatically stopped when `predicateFn` returns true.": {
        "prefix": "hs.timer.doUntil(predicateFn, actionFn[, checkInterval]) -> timer",
        "body": "hs.timer.doUntil(${1:predicateFn}, ${2:actionFn[}, ${3:checkInterval]})",
        "description": "Creates and starts a timer which will perform `actionFn` every `checkinterval` seconds until `predicateFn` returns true.  The timer is automatically stopped when `predicateFn` returns true.\n\nParameters:\n * predicateFn - a function which determines when to stop calling `actionFn`.  This function takes no arguments, but should return true when it is time to stop calling `actionFn`.\n * actionFn - a function which performs the desired action.  This function may take a single argument, the timer itself.\n * checkInterval - an optional parameter indicating how often to repeat the `predicateFn` check. Defaults to 1 second.\n\nReturns:\n * a timer object\n\nNotes:\n * The timer is passed as an argument to `actionFn` so that it may stop the timer prematurely (i.e. before predicateFn returns true) if desired.\n * See also `hs.timer.doWhile`, which is essentially the opposite of this function"
    },
    "Creates and starts a timer which will perform `actionFn` every `checkinterval` seconds while `predicateFn` returns true.  The timer is automatically stopped when `predicateFn` returns false.": {
        "prefix": "hs.timer.doWhile(predicateFn, actionFn[, checkInterval]) -> timer",
        "body": "hs.timer.doWhile(${1:predicateFn}, ${2:actionFn[}, ${3:checkInterval]})",
        "description": "Creates and starts a timer which will perform `actionFn` every `checkinterval` seconds while `predicateFn` returns true.  The timer is automatically stopped when `predicateFn` returns false.\n\nParameters:\n * predicateFn - a function which determines when to stop calling `actionFn`.  This function takes no arguments, but should return false when it is time to stop calling `actionFn`.\n * actionFn - a function which performs the desired action.  This function may take a single argument, the timer itself.\n * checkInterval - an optional parameter indicating how often to repeat the `predicateFn` check. Defaults to 1 second.\n\nReturns:\n * a timer object\n\nNotes:\n * The timer is passed as an argument to `actionFn` so that it may stop the timer prematurely (i.e. before predicateFn returns false) if desired.\n * See also `hs.timer.doUntil`, which is essentially the opposite of this function"
    },
    "Immediately fires a timer": {
        "prefix": "hs.timer:fire() -> timer",
        "body": "hs.timer:fire()",
        "description": "Immediately fires a timer\n\nParameters:\n * None\n\nReturns:\n * The `hs.timer` object\n\nNotes:\n * This cannot be used on a timer which has already stopped running"
    },
    "Converts hours to seconds": {
        "prefix": "hs.timer.hours(n) -> seconds",
        "body": "hs.timer.hours(${1:n})",
        "description": "Converts hours to seconds\n\nParameters:\n * n - A number of hours\n\nReturns:\n * The number of seconds in n hours"
    },
    "Returns the number of seconds since local time midnight": {
        "prefix": "hs.timer.localTime() -> number",
        "body": "hs.timer.localTime()",
        "description": "Returns the number of seconds since local time midnight\n\nParameters:\n  * None\n\nReturns:\n  * the number of seconds"
    },
    "Converts minutes to seconds": {
        "prefix": "hs.timer.minutes(n) -> seconds",
        "body": "hs.timer.mi${1:n}utes(n)",
        "description": "Converts minutes to seconds\n\nParameters:\n * n - A number of minutes\n\nReturns:\n * The number of seconds in n minutes"
    },
    "Creates a new `hs.timer` object for repeating interval callbacks": {
        "prefix": "hs.timer.new(interval, fn [, continueOnError]) -> timer",
        "body": "hs.timer.new(${1:interval}, ${2:fn [}, ${3:continueOnError]})",
        "description": "Creates a new `hs.timer` object for repeating interval callbacks\n\nParameters:\n * interval - A number of seconds between firings of the timer\n * fn - A function to call every time the timer fires\n * continueOnError - An optional boolean, true if the timer should continue to be triggered after the callback function has produced an error, false if the timer should stop being triggered after the callback function has produced an error. Defaults to false.\n\nReturns:\n * An `hs.timer` object\n\nNotes:\n * The returned object does not start its timer until its `:start()` method is called\n * If `interval` is 0, the timer will not repeat (because if it did, it would be repeating as fast as your machine can manage, which seems generally unwise)\n * For non-zero intervals, the lowest acceptable value for the interval is 0.00001s. Values >0 and <0.00001 will be coerced to 0.00001"
    },
    "Returns the number of seconds until the timer will next trigger": {
        "prefix": "hs.timer:nextTrigger() -> number",
        "body": "hs.timer:nextTrigger()",
        "description": "Returns the number of seconds until the timer will next trigger\n\nParameters:\n * None\n\nReturns:\n * A number containing the number of seconds until the next firing\n\nNotes:\n * The return value may be a negative integer in two circumstances:\n  * Hammerspoon's runloop is backlogged and is catching up on missed timer triggers\n  * The timer object is not currently running. In this case, the return value of this method is the number of seconds since the last firing (you can check if the timer is running or not, with `hs.timer:running()`"
    },
    "Returns a boolean indicating whether or not the timer is currently running.": {
        "prefix": "hs.timer:running() -> boolean",
        "body": "hs.timer:running()",
        "description": "Returns a boolean indicating whether or not the timer is currently running.\n\nParameters:\n * None\n\nReturns:\n * A boolean value indicating whether or not the timer is currently running."
    },
    "Converts a string with a time of day or a duration into number of seconds": {
        "prefix": "hs.timer.seconds(timeOrDuration) -> seconds",
        "body": "hs.timer.seconds(${1:timeOrDuration})",
        "description": "Converts a string with a time of day or a duration into number of seconds\n\nParameters:\n * timeOrDuration - a string that can have any of the following formats:\n   * \"HH:MM:SS\" or \"HH:MM\" - represents a time of day (24-hour clock), returns the number of seconds since midnight\n   * \"DDdHHh\", \"HHhMMm\", \"MMmSSs\", \"DDd\", \"HHh\", \"MMm\", \"SSs\", \"NNNNms\" - represents a duration in days, hours, minutes,\n     seconds and/or milliseconds\n\nReturns:\n * The number of seconds"
    },
    "Gets the (fractional) number of seconds since the UNIX epoch (January 1, 1970)": {
        "prefix": "hs.timer.secondsSinceEpoch() -> sec",
        "body": "hs.timer.secondsSinceEpoch()",
        "description": "Gets the (fractional) number of seconds since the UNIX epoch (January 1, 1970)\n\nParameters:\n * None\n\nReturns:\n * The number of seconds since the epoch\n\nNotes:\n * This has much better precision than `os.time()`, which is limited to whole seconds."
    },
    "Sets the next trigger time of a timer": {
        "prefix": "hs.timer:setNextTrigger(seconds) -> timer",
        "body": "hs.timer:setNextTrigger(${1:seconds})",
        "description": "Sets the next trigger time of a timer\n\nParameters:\n * seconds - A number of seconds after which to trigger the timer\n\nReturns:\n * The `hs.timer` object, or nil if an error occurred\n\nNotes:\n * If the timer is not already running, this will start it"
    },
    "Starts an `hs.timer` object": {
        "prefix": "hs.timer:start() -> timer",
        "body": "hs.timer:start()",
        "description": "Starts an `hs.timer` object\n\nParameters:\n * None\n\nReturns:\n * The `hs.timer` object\n\nNotes:\n * The timer will not call the callback immediately, the timer will wait until it fires\n * If the callback function results in an error, the timer will be stopped to prevent repeated error notifications (see the `continueOnError` parameter to `hs.timer.new()` to override this)"
    },
    "Stops an `hs.timer` object": {
        "prefix": "hs.timer:stop() -> timer",
        "body": "hs.timer:stop()",
        "description": "Stops an `hs.timer` object\n\nParameters:\n * None\n\nReturns:\n * The `hs.timer` object"
    },
    "Blocks Lua execution for the specified time": {
        "prefix": "hs.timer.usleep(microsecs)",
        "body": "hs.timer.usleep(${1:microsecs})",
        "description": "Blocks Lua execution for the specified time\n\nParameters:\n * microsecs - A number containing a time in microseconds to block for\n\nReturns:\n * None\n\nNotes:\n * Use of this function is strongly discouraged, as it blocks all main-thread execution in Hammerspoon. This means no hotkeys or events will be processed in that time, no GUI updates will happen, and no Lua will execute. This is only provided as a last resort, or for extremely short sleeps. For all other purposes, you really should be splitting up your code into multiple functions and calling `hs.timer.doAfter()`"
    },
    "Creates and starts a timer which will perform `actionFn` when `predicateFn` returns true.  The timer is automatically stopped when `actionFn` is called.": {
        "prefix": "hs.timer.waitUntil(predicateFn, actionFn[, checkInterval]) -> timer",
        "body": "hs.timer.waitUntil(${1:predicateFn}, ${2:actionFn[}, ${3:checkInterval]})",
        "description": "Creates and starts a timer which will perform `actionFn` when `predicateFn` returns true.  The timer is automatically stopped when `actionFn` is called.\n\nParameters:\n * predicateFn - a function which determines when `actionFn` should be called.  This function takes no arguments, but should return true when it is time to call `actionFn`.\n * actionFn - a function which performs the desired action.  This function may take a single argument, the timer itself.\n * checkInterval - an optional parameter indicating how often to repeat the `predicateFn` check. Defaults to 1 second.\n\nReturns:\n * a timer object\n\nNotes:\n * The timer is stopped before `actionFn` is called, but the timer is passed as an argument to `actionFn` so that the actionFn may restart the timer to be called again the next time predicateFn returns true.\n * See also `hs.timer.waitWhile`, which is essentially the opposite of this function"
    },
    "Creates and starts a timer which will perform `actionFn` when `predicateFn` returns false.  The timer is automatically stopped when `actionFn` is called.": {
        "prefix": "hs.timer.waitWhile(predicateFn, actionFn[, checkInterval]) -> timer",
        "body": "hs.timer.waitWhile(${1:predicateFn}, ${2:actionFn[}, ${3:checkInterval]})",
        "description": "Creates and starts a timer which will perform `actionFn` when `predicateFn` returns false.  The timer is automatically stopped when `actionFn` is called.\n\nParameters:\n * predicateFn - a function which determines when `actionFn` should be called.  This function takes no arguments, but should return false when it is time to call `actionFn`.\n * actionFn - a function which performs the desired action.  This function may take a single argument, the timer itself.\n * checkInterval - an optional parameter indicating how often to repeat the `predicateFn` check. Defaults to 1 second.\n\nReturns:\n * a timer object\n\nNotes:\n * The timer is stopped before `actionFn` is called, but the timer is passed as an argument to `actionFn` so that the actionFn may restart the timer to be called again the next time predicateFn returns false.\n * See also `hs.timer.waitUntil`, which is essentially the opposite of this function"
    },
    "Converts weeks to seconds": {
        "prefix": "hs.timer.weeks(n) -> sec",
        "body": "hs.timer.weeks(${1:n})",
        "description": "Converts weeks to seconds\n\nParameters:\n * n - A number of weeks\n\nReturns:\n * The number of seconds in n weeks"
    },
    "Creates a new delayed timer.": {
        "prefix": "hs.timer.delayed.new(delay, fn) -> hs.timer.delayed object",
        "body": "hs.timer.${1:delay}ed.new(delay, ${2:fn})",
        "description": "Creates a new delayed timer.\n\nDelayed timers have specialized methods that behave differently from regular timers.\nWhen the `:start()` method is invoked, the timer will wait for `delay` seconds before calling `fn()`;\nthis is referred to as the callback countdown. If `:start()` is invoked again before `delay` has elapsed,\nthe countdown starts over again.\n\nYou can use a delayed timer to coalesce processing of unpredictable asynchronous events into a single\ncallback; for example, if you have an event stream that happens in \"bursts\" of dozens of events at once,\nset an appropriate `delay` to wait for things to settle down, and then your callback will run just once.\n\nParameters:\n * delay - number of seconds to wait for after a `:start()` invocation (the \"callback countdown\")\n * fn - a function to call after `delay` has fully elapsed without any further `:start()` invocations\n\nReturns:\n * a new `hs.timer.delayed` object\n\nNotes:\n  * these timers are meant to be long-lived: once instantiated, there's no way to remove them from the run loop;\n    create them once at the module level."
    },
    "Returns the time left in the callback countdown": {
        "prefix": "hs.timer.delayed:nextTrigger() -> number or nil",
        "body": "hs.timer.delayed:nextTrigger()",
        "description": "Returns the time left in the callback countdown\n\nParameters:\n  * None\n\nReturns:\n  * if the callback countdown is running, returns the number of seconds until it triggers; otherwise returns nil"
    },
    "Returns a boolean indicating whether the callback countdown is running": {
        "prefix": "hs.timer.delayed:running() -> boolean",
        "body": "hs.timer.delayed:running()",
        "description": "Returns a boolean indicating whether the callback countdown is running\n\nParameters:\n  * None\n\nReturns:\n  * a boolean"
    },
    "Changes the callback countdown duration": {
        "prefix": "hs.timer.delayed:setDelay(delay) -> hs.timer.delayed object",
        "body": "hs.timer.${1:delay}ed:setDelay(delay)",
        "description": "Changes the callback countdown duration\n\nParameters:\n  * None\n\nReturns:\n  * the delayed timer object\n\nNotes:\n  * if the callback countdown is running, calling this method will restart it"
    },
    "Starts or restarts the callback countdown": {
        "prefix": "hs.timer.delayed:start([delay]) -> hs.timer.delayed object",
        "body": "hs.timer.delayed:start(${1:[delay]})",
        "description": "Starts or restarts the callback countdown\n\nParameters:\n  * delay - (optional) if provided, sets the countdown duration to this number of seconds\n    for this time only; subsequent calls to `:start()` will revert to the original delay (or\n    to the delay set with `:setDelay(delay)`)\n\nReturns:\n  * the delayed timer object"
    },
    "Cancels the callback countdown, if running; the callback will therefore not be triggered": {
        "prefix": "hs.timer.delayed:stop() -> hs.timer.delayed object",
        "body": "hs.timer.delayed:stop()",
        "description": "Cancels the callback countdown, if running; the callback will therefore not be triggered\n\nParameters:\n  * None\n\nReturns:\n  * the delayed timer object"
    },
    "Gets the currently focused UI element": {
        "prefix": "hs.uielement.focusedElement() -> element or nil",
        "body": "hs.uielement.focusedElement()",
        "description": "Gets the currently focused UI element\n\nParameters:\n * None\n\nReturns:\n * An `hs.uielement` object or nil if no object could be found"
    },
    "Returns whether the UI element represents an application.": {
        "prefix": "hs.uielement:isApplication() -> bool",
        "body": "hs.uielement:isApplication()",
        "description": "Returns whether the UI element represents an application.\n\nParameters:\n * None\n\nReturns:\n * A boolean, true if the UI element is an application"
    },
    "Returns whether the UI element represents a window.": {
        "prefix": "hs.uielement:isWindow() -> bool",
        "body": "hs.uielement:isWindow()",
        "description": "Returns whether the UI element represents a window.\n\nParameters:\n * None\n\nReturns:\n * A boolean, true if the UI element is a window, otherwise false"
    },
    "Creates a new watcher": {
        "prefix": "hs.uielement:newWatcher(handler[, userData]) -> hs.uielement.watcher or nil",
        "body": "hs.uielement:newWatcher(${1:handler[}, ${2:userData]})",
        "description": "Creates a new watcher\n\nParameters:\n * A function to be called when a watched event occurs.  The function will be passed the following arguments:\n   * element: The element the event occurred on. Note this is not always the element being watched.\n   * event: The name of the event that occurred.\n   * watcher: The watcher object being created.\n   * userData: The userData you included, if any.\n * an optional userData object which will be included as the final argument to the callback function when it is called.\n\nReturns:\n * An `hs.uielement.watcher` object, or `nil` if an error occurred"
    },
    "Returns the role of the element.": {
        "prefix": "hs.uielement:role() -> string",
        "body": "hs.uielement:role()",
        "description": "Returns the role of the element.\n\nParameters:\n * None\n\nReturns:\n * A string containing the role of the UI element"
    },
    "Returns the selected text in the element": {
        "prefix": "hs.uielement:selectedText() -> string or nil",
        "body": "hs.uielement:selectedText()",
        "description": "Returns the selected text in the element\n\nParameters:\n * None\n\nReturns:\n * A string containing the selected text, or nil if none could be found\n\nNotes:\n * Many applications (e.g. Safari, Mail, Firefox) do not implement the necessary accessibility features for this to work in their web views"
    },
    "Returns the element the watcher is watching.": {
        "prefix": "hs.uielement.watcher:element() -> object",
        "body": "hs.uielement.watcher:element()",
        "description": "Returns the element the watcher is watching.\n\nParameters:\n * None\n\nReturns:\n * The element the watcher is watching."
    },
    "Returns the PID of the element being watched": {
        "prefix": "hs.uielement.watcher:pid() -> number",
        "body": "hs.uielement.watcher:pid()",
        "description": "Returns the PID of the element being watched\n\nParameters:\n * None\n\nReturns:\n * The PID of the element being watched"
    },
    "Tells the watcher to start watching for the given list of events.": {
        "prefix": "hs.uielement.watcher:start(events) -> hs.uielement.watcher",
        "body": "hs.uielement.watcher:start(${1:events})",
        "description": "Tells the watcher to start watching for the given list of events.\n\nParameters:\n * An array of events to be watched for.\n\nReturns:\n * hs.uielement.watcher\n\nNotes:\n * See hs.uielement.watcher for a list of events. You may also specify arbitrary event names as strings.\n * Does nothing if the watcher has already been started. To start with different events, stop it first."
    },
    "Tells the watcher to stop listening for events.": {
        "prefix": "hs.uielement.watcher:stop() -> hs.uielement.watcher",
        "body": "hs.uielement.watcher:stop()",
        "description": "Tells the watcher to stop listening for events.\n\nParameters:\n * None\n\nReturns:\n * hs.uielement.watcher\n\nNotes:\n * This is automatically called if the element is destroyed."
    },
    "Registers a callback for a hammerspoon:// URL event": {
        "prefix": "hs.urlevent.bind(eventName, callback)",
        "body": "hs.urlevent.bind(${1:eventName}, ${2:callback})",
        "description": "Registers a callback for a hammerspoon:// URL event\n\nParameters:\n * eventName - A string containing the name of an event\n * callback - A function that will be called when the specified event is received, or nil to remove an existing callback\n\nReturns:\n * None\n\nNotes:\n * The callback function should accept two parameters:\n  * eventName - A string containing the name of the event\n  * params - A table containing key/value string pairs containing any URL parameters that were specified in the URL\n * Given the URL `hammerspoon://doThingA?value=1` The event name is `doThingA` and the callback's `params` argument will be a table containing `{[\"value\"] = \"1\"}`"
    },
    "Gets all of the application bundle identifiers of applications able to handle a URL scheme": {
        "prefix": "hs.urlevent.getAllHandlersForScheme(scheme) -> table",
        "body": "hs.urlevent.getAllHandlersForScheme(${1:scheme})",
        "description": "Gets all of the application bundle identifiers of applications able to handle a URL scheme\n\nParameters:\n * scheme - A string containing a URL scheme (e.g. 'http')\n\nReturns:\n * A table containing the bundle identifiers of all applications that can handle the scheme"
    },
    "Gets the application bundle identifier of the application currently registered to handle a URL scheme": {
        "prefix": "hs.urlevent.getDefaultHandler(scheme) -> string",
        "body": "hs.urlevent.getDefaultHandler(${1:scheme})",
        "description": "Gets the application bundle identifier of the application currently registered to handle a URL scheme\n\nParameters:\n * scheme - A string containing a URL scheme (e.g. 'http')\n\nReturns:\n * A string containing the bundle identifier of the current default application"
    },
    "A function that should handle http:// and https:// URL events": {
        "prefix": "hs.urlevent.httpCallback",
        "body": "hs.urlevent.httpCallback",
        "description": "A function that should handle http:// and https:// URL events\n\nNotes:\n * The function should handle four arguments:\n  * scheme - A string containing the URL scheme (i.e. \"http\")\n  * host - A string containing the host requested (e.g. \"www.hammerspoon.org\")\n  * params - A table containing the key/value pairs of all the URL parameters\n  * fullURL - A string containing the full, original URL"
    },
    "Opens a URL with the default application": {
        "prefix": "hs.urlevent.openURL(url)",
        "body": "hs.${1:url}event.openURL(url)",
        "description": "Opens a URL with the default application\n\nParameters:\n * url - A string containing a URL, which must contain a scheme and '://'\n\nReturns:\n * A boolean, true if the URL was opened successfully, otherwise false"
    },
    "Opens a URL with a specified application": {
        "prefix": "hs.urlevent.openURLWithBundle(url, bundleID) -> boolean",
        "body": "hs.${1:url}event.openURLWithBundle(url, ${2:bundleID})",
        "description": "Opens a URL with a specified application\n\nParameters:\n * url - A string containing a URL\n * bundleID - A string containing an application bundle identifier (e.g. \"com.apple.Safari\")\n\nReturns:\n * True if the application was launched successfully, otherwise false"
    },
    "Sets the default system handler for URLs of a given scheme": {
        "prefix": "hs.urlevent.setDefaultHandler(scheme[, bundleID])",
        "body": "hs.urlevent.setDefaultHandler(${1:scheme[}, ${2:bundleID]})",
        "description": "Sets the default system handler for URLs of a given scheme\n\nParameters:\n * scheme - A string containing the URL scheme to change. This must be 'http' or 'https' (although entering either will change the handler for both)\n * bundleID - An optional string containing an application bundle identifier for the application to set as the default handler. Defaults to `org.hammerspoon.Hammerspoon`.\n\nReturns:\n * None\n\nNotes:\n * Changing the default handler for http/https URLs will display a system prompt asking the user to confirm the change"
    },
    "Stores a URL handler that will be restored when Hammerspoon or reloads its config": {
        "prefix": "hs.urlevent.setRestoreHandler(scheme, bundleID)",
        "body": "hs.urlevent.setRestoreHandler(${1:scheme}, ${2:bundleID})",
        "description": "Stores a URL handler that will be restored when Hammerspoon or reloads its config\n\nParameters:\n * scheme - A string containing the URL scheme to change. This must be 'http' (although both http:// and https:// URLs will be affected)\n * bundleID - A string containing an application bundle identifier (e.g. 'com.apple.Safari') for the application to set as the default handler when Hammerspoon exits or reloads its config\n\nReturns:\n * None\n\nNotes:\n * You don't have to call this function if you want Hammerspoon to permanently be your default handler. Only use this if you want the handler to be automatically reverted to something else when Hammerspoon exits/reloads."
    },
    "Gets details about currently attached USB devices": {
        "prefix": "hs.usb.attachedDevices() -> table or nil",
        "body": "hs.usb.attachedDevices()",
        "description": "Gets details about currently attached USB devices\n\nParameters:\n * None\n\nReturns:\n * A table containing information about currently attached USB devices, or nil if an error occurred. The table contains a sub-table for each USB device, the keys of which are:\n  * productName - A string containing the name of the device\n  * vendorName - A string containing the name of the device vendor\n  * vendorID - A number containing the Vendor ID of the device\n  * productID - A number containing the Product ID of the device"
    },
    "Creates a new watcher for USB device events": {
        "prefix": "hs.usb.watcher.new(fn) -> watcher",
        "body": "hs.usb.watcher.new(${1:fn})",
        "description": "Creates a new watcher for USB device events\n\nParameters:\n * fn - A function that will be called when a USB device is inserted or removed. The function should accept a single parameter, which is a table containing the following keys:\n  * eventType - A string containing either \"added\" or \"removed\" depending on whether the USB device was connected or disconnected\n  * productName - A string containing the name of the device\n  * vendorName - A string containing the name of the device vendor\n  * vendorID - A number containing the Vendor ID of the device\n  * productID - A number containing the Product ID of the device\n\nReturns:\n * A `hs.usb.watcher` object"
    },
    "Starts the USB watcher": {
        "prefix": "hs.usb.watcher:start() -> watcher",
        "body": "hs.usb.watcher:start()",
        "description": "Starts the USB watcher\n\nParameters:\n * None\n\nReturns:\n * The `hs.usb.watcher` object"
    },
    "Stops the USB watcher": {
        "prefix": "hs.usb.watcher:stop() -> watcher",
        "body": "hs.usb.watcher:stop()",
        "description": "Stops the USB watcher\n\nParameters:\n * None\n\nReturns:\n * The `hs.usb.watcher` object"
    },
    "Returns the provided string with all non-printable ascii characters escaped, except Return, Linefeed, and Tab.": {
        "prefix": "hs.utf8.asciiOnly(string[, all]) -> string",
        "body": "hs.utf8.asciiOnly(${1:string[}, ${2:all]})",
        "description": "Returns the provided string with all non-printable ascii characters escaped, except Return, Linefeed, and Tab.\n\nParameters:\n * string - The input string which is to have all non-printable ascii characters escaped as \\x## (a single byte hexadecimal number).\n * all    - an optional boolean parameter (default false) indicating whether or not Return, Linefeed, and Tab should also be considered \"non-printable\"\n\nReturns:\n * The cleaned up string, with non-printable characters escaped.\n\nNotes:\n * Because Unicode characters outside of the basic ascii alphabet are multi-byte characters, any UTF8 or other Unicode encoded character will be broken up into their individual bytes and likely escaped by this function.\n * This function is useful for displaying binary data in a human readable way that might otherwise be inexpressible in the Hammerspoon console or other destination.  For example:\n   * `utf8.charpattern`, which contains the regular expression for matching valid UTF8 encoded sequences, results in `(null)` in the Hammerspoon console, but `hs.utf8.asciiOnly(utf8.charpattern)` will display `[\\x00-\\x7F\\xC2-\\xF4][\\x80-\\xBF]*`."
    },
    "Wrapper to `utf8.char(...)` which ensures that all codepoints return valid UTF8 characters.": {
        "prefix": "hs.utf8.codepointToUTF8(...) -> string",
        "body": "hs.utf8.codepointToUTF8(${1:...})",
        "description": "Wrapper to `utf8.char(...)` which ensures that all codepoints return valid UTF8 characters.\n\nParameters:\n * codepoints - A series of numeric Unicode code points to be converted to a UTF-8 byte sequences.  If a codepoint is a string (and does not start with U+, it is used as a key for lookup in `hs.utf8.registeredKeys[]`\n\nReturns:\n * A string containing the UTF-8 byte sequences corresponding to provided codepoints as a combined string.\n\nNotes:\n * Valid codepoint values are from 0x0000 - 0x10FFFF (0 - 1114111)\n * If the codepoint provided is a string that starts with U+, then the 'U+' is converted to a '0x' so that lua can properly treat the value as numeric.\n * Invalid codepoints are returned as the Unicode Replacement Character (U+FFFD)\n   * This includes out of range codepoints as well as the Unicode Surrogate codepoints (U+D800 - U+DFFF)"
    },
    "Replace invalid UTF8 character sequences in `inString` with `replacementChar` so it can be safely displayed in the console or other destination which requires valid UTF8 encoding.": {
        "prefix": "hs.utf8.fixUTF8(inString[, replacementChar]) -> outString, posTable",
        "body": "hs.utf8.fixUTF8(${1:inString[}, ${2:replacementChar]})",
        "description": "Replace invalid UTF8 character sequences in `inString` with `replacementChar` so it can be safely displayed in the console or other destination which requires valid UTF8 encoding.\n\nParameters:\n * inString - String of characters which may contain invalid UTF8 byte sequences\n * replacementChar - optional parameter to replace invalid byte sequences in `inString`.  If this parameter is not provided, the default UTF8 replacement character, U+FFFD, is used.\n\nReturns:\n * outString - The contents of `inString` with all invalid UTF8 byte sequences replaced by the `replacementChar`.\n * posTable - a table of indexes in `outString` corresponding indicating where `replacementChar` has been used.\n\nNotes:\n * This function is a slight modification to code found at http://notebook.kulchenko.com/programming/fixing-malformed-utf8-in-lua.\n * If `replacementChar` is a multi-byte character (like U+FFFD) or multi character string, then the string length of `outString` will be longer than the string length of `inString`.  The character positions in `posTable` will reflect these new positions in `outString`.\n * To calculate the character position of the invalid characters in `inString`, use something like the following:\n\n      outString, outErrors = hs.utf8.fixUTF8(inString, replacement)\n      inErrors = {}\n      for i,p in ipairs(outErrors) do\n          table.insert(inErrors, p - ((i - 1) * string.length(replacement) - 1))\n      end\n\n   Where replacement is `utf8.char(0xFFFD)`, if you leave it out of the `hs.utf8.fixUTF8` function in the first line.\n"
    },
    "Returns a hex dump of the provided string.  This is primarily useful for examining the exact makeup of binary data contained in a Lua String as individual bytes for debugging purposes.": {
        "prefix": "hs.utf8.hexDump(inputString [, count]) -> string",
        "body": "hs.utf8.hexDump(${1:inputString [}, ${2:count]})",
        "description": "Returns a hex dump of the provided string.  This is primarily useful for examining the exact makeup of binary data contained in a Lua String as individual bytes for debugging purposes.\n\nParameters:\n * inputString - the data to be rendered as individual hexadecimal bytes for examination.\n * count - an optional parameter specifying the number of bytes to display per line (default 16)\n\nReturns:\n * a string containing the hex dump of the input string.\n\nNotes:\n * Like hs.utf8.asciiOnly, this function will break up Unicode characters into their individual bytes.\n * As an example:\n     `hs.utf8.hexDump(utf8.charpattern)` will return\n     `00 : 5B 00 2D 7F C2 2D F4 5D 5B 80 2D BF 5D 2A        : [.-..-.][.-.]*`"
    },
    "Registers a Unicode codepoint under the given label as a UTF-8 string of bytes which can be referenced by the label later in your code as `hs.utf8.registeredKeys[label]` for convenience and readability.": {
        "prefix": "hs.utf8.registerCodepoint(label, codepoint) -> string",
        "body": "hs.utf8.registerCodepoint(${1:label}, ${2:codepoint})",
        "description": "Registers a Unicode codepoint under the given label as a UTF-8 string of bytes which can be referenced by the label later in your code as `hs.utf8.registeredKeys[label]` for convenience and readability.\n\nParameters:\n * label - a string label to use as a human-readable reference when getting the UTF-8 byte sequence for use in other strings and output functions.\n * codepoint - a Unicode codepoint in numeric or `U+xxxx` format to register with the given label.\n\nReturns:\n * Returns the UTF-8 byte sequence for the Unicode codepoint registered.\n\nNotes:\n * If a codepoint label was previously registered, this will overwrite the previous value with a new one.  Because many of the special keys you may want to register have different variants, this allows you to easily modify the existing predefined defaults to suite your preferences.\n * The return value is merely syntactic sugar and you do not need to save it locally; it can be safely ignored -- future access to the pre-converted codepoint should be retrieved as `hs.utf8.registeredKeys[label]` in your code.  It looks good when invoked from the console, though \u263a."
    },
    "A collection of UTF-8 characters already converted from codepoint and available as convient key-value pairs.  UTF-8 printable versions of common Apple and OS X special keys are predefined and others can be added with `hs.utf8.registerCodepoint(label, codepoint)` for your own use.": {
        "prefix": "hs.utf8.registeredKeys[]",
        "body": "hs.utf8.registeredKeys",
        "description": "A collection of UTF-8 characters already converted from codepoint and available as convient key-value pairs.  UTF-8 printable versions of common Apple and OS X special keys are predefined and others can be added with `hs.utf8.registerCodepoint(label, codepoint)` for your own use.\n\nPredefined keys include:\n\n    (U+2325) alt              \u2325\n    (U+F8FF) apple            \uf8ff\n    (U+21E4) backtab          \u21e4\n    (U+21EA) capslock         \u21ea\n    (U+2713) checkMark        \u2713\n    (U+2318) cmd              \u2318\n    (U+27E1) concaveDiamond   \u2727\n    (U+00A9) copyrightSign    \u00a9\n    (U+2303) ctrl             \u2303\n    (U+232B) delete           \u232b\n    (U+2193) down             \u2193\n    (U+21E3) down2            \u21e3\n    (U+23CF) eject            \u23cf\n    (U+21F2) end              \u21f2\n    (U+2198) end2             \u2198\n    (U+238B) escape           \u238b\n    (U+2326) forwarddelete    \u2326\n    (U+FE56) help             \ufe56\n    (U+21F1) home             \u21f1\n    (U+2196) home2            \u2196\n    (U+21B8) home3            \u21b8\n    (U+2190) left             \u2190\n    (U+21E0) left2            \u21e0\n    (U+201C) leftDoubleQuote  \u201c\n    (U+2018) leftSingleQuote  \u2018\n    (U+00B7) middleDot        \u00b7\n    (U+21ED) numlock          \u21ed\n    (U+2325) option           \u2325\n    (U+2327) padclear         \u2327\n    (U+2324) padenter         \u2324\n    (U+2386) padenter2        \u2386\n    (U+21A9) padenter3        \u21a9\n    (U+21DF) pagedown         \u21df\n    (U+21DE) pageup           \u21de\n    (U+233D) power            \u233d\n    (U+00AE) registeredSign   \u00ae\n    (U+23CE) return           \u23ce\n    (U+21A9) return2          \u21a9\n    (U+2192) right            \u2192\n    (U+21E2) right2           \u21e2\n    (U+201D) rightDoubleQuote  \u201d\n    (U+2019) rightSingleQuote  \u2019\n    (U+00A7) sectionSign      \u00a7\n    (U+21E7) shift            \u21e7\n    (U+2423) space            \u2423\n    (U+21E5) tab              \u21e5\n    (U+2191) up               \u2191\n    (U+21E1) up2              \u21e1\n\nNotes:\n * This table has a __tostring() metamethod which allows listing it's contents in the Hammerspoon console by typing `hs.utf8.registeredKeys`.\n * For parity with `hs.utf8.registeredLabels`, this can also invoked as a function, i.e. `hs.utf8.registeredKeys[\"cmd\"]` is equivalent to `hs.utf8.registeredKeys(\"cmd\")`"
    },
    "Returns the label name for a UTF8 character, as it is registered in `hs.utf8.registeredKeys[]`.": {
        "prefix": "hs.utf8.registeredLabels(utf8char) -> string",
        "body": "hs.utf8.registeredLabels(${1:utf8char})",
        "description": "Returns the label name for a UTF8 character, as it is registered in `hs.utf8.registeredKeys[]`.\n\nParameters:\n * utf8char -- the character to lookup in `hs.utf8.registeredKeys[]`\n\nReturns:\n * The string label for the UTF8 character or a string in the format of \"U+XXXX\", if it is not defined in `hs.utf8.registeredKeys[]`, or nil, if utf8char is not a valid UTF8 character.\n\nNotes:\n * For parity with `hs.utf8.registeredKeys`, this can also be invoked as if it were an array: i.e. `hs.utf8.registeredLabels(char)` is equivalent to `hs.utf8.registeredLabels[char]`"
    },
    "Add media URL to current list": {
        "prefix": "hs.vox.addurl(url)",
        "body": "hs.vox.add${1:url}(url)",
        "description": "Add media URL to current list\n\nParameters:\n * url {string}\n\nReturns:\n * None"
    },
    "Skips the playback position backwards by about 7 seconds": {
        "prefix": "hs.vox.backward()",
        "body": "hs.vox.backward()",
        "description": "Skips the playback position backwards by about 7 seconds\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Decreases the player volume": {
        "prefix": "hs.vox.decreaseVolume()",
        "body": "hs.vox.decreaseVolume()",
        "description": "Decreases the player volume\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Skips the playback position backwards by about 14 seconds": {
        "prefix": "hs.vox.fastBackward()",
        "body": "hs.vox.fastBackward()",
        "description": "Skips the playback position backwards by about 14 seconds\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Skips the playback position forwards by about 17 seconds": {
        "prefix": "hs.vox.fastForward()",
        "body": "hs.vox.fastForward()",
        "description": "Skips the playback position forwards by about 17 seconds\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Skips the playback position forwards by about 7 seconds": {
        "prefix": "hs.vox.forward()",
        "body": "hs.vox.forward()",
        "description": "Skips the playback position forwards by about 7 seconds\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Gets the artist of current Album": {
        "prefix": "hs.vox.getAlbumArtist()",
        "body": "hs.vox.getAlbumArtist()",
        "description": "Gets the artist of current Album\n\nParameters:\n * None\n\nReturns:\n * A string containing the artist of current Album, or nil if an error occurred"
    },
    "Gets the current playback state of vox": {
        "prefix": "hs.vox.getPlayerState()",
        "body": "hs.vox.getPlayerState()",
        "description": "Gets the current playback state of vox\n\nParameters:\n * None\n\nReturns:\n * 0 for paused\n * 1 for playing"
    },
    "Gets the uniqueID of the current track": {
        "prefix": "hs.vox.getUniqueID()",
        "body": "hs.vox.getUniqueID()",
        "description": "Gets the uniqueID of the current track\n\nParameters:\n * None\n\nReturns:\n * A string containing the name of the current track, or nil if an error occurred"
    },
    "Increases the palyer volume": {
        "prefix": "hs.vox.increaseVolume()",
        "body": "hs.vox.increaseVolume()",
        "description": "Increases the palyer volume\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Returns whether VOX is currently open": {
        "prefix": "hs.vox.isRunning()",
        "body": "hs.vox.isRunning()",
        "description": "Returns whether VOX is currently open\n\nParameters:\n * None\n\nReturns:\n * A boolean value indicating whether the vox application is running"
    },
    "Skips to the next track": {
        "prefix": "hs.vox.next()",
        "body": "hs.vox.next()",
        "description": "Skips to the next track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Pauses the current vox track": {
        "prefix": "hs.vox.pause()",
        "body": "hs.vox.pause()",
        "description": "Pauses the current vox track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Plays the current vox track": {
        "prefix": "hs.vox.play()",
        "body": "hs.vox.play()",
        "description": "Plays the current vox track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Toggles play/pause of current vox track": {
        "prefix": "hs.vox.playpause()",
        "body": "hs.vox.playpause()",
        "description": "Toggles play/pause of current vox track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Play media from the given URL": {
        "prefix": "hs.vox.playurl(url)",
        "body": "hs.vox.play${1:url}(url)",
        "description": "Play media from the given URL\n\nParameters:\n * url {string}\n\nReturns:\n * None"
    },
    "Skips to previous track": {
        "prefix": "hs.vox.previous()",
        "body": "hs.vox.previous()",
        "description": "Skips to previous track\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Toggle shuffle state of current list": {
        "prefix": "hs.vox.shuffle()",
        "body": "hs.vox.shuffle()",
        "description": "Toggle shuffle state of current list\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Toggle playlist": {
        "prefix": "hs.vox.togglePlaylist()",
        "body": "hs.vox.togglePlaylist()",
        "description": "Toggle playlist\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Change or remove the callback function for the watchableObject.": {
        "prefix": "hs.watchable:callback(fn | nil) -> watchableObject",
        "body": "hs.watchable:callback(${1:fn | nil})",
        "description": "Change or remove the callback function for the watchableObject.\n\nParameters:\n * `fn` - a function, or an explicit nil to remove, specifying the new callback function to receive notifications for this watchableObject\n\nReturns:\n * the watchableObject\n\nNotes:\n * see [hs.watchable.watch](#watch) for a description of the arguments the callback function should expect."
    },
    "Externally change the value of the key-value pair being watched by the watchableObject": {
        "prefix": "hs.watchable:change([key], value) -> watchableObject",
        "body": "hs.watchable:change(${1:[key]}, ${2:value})",
        "description": "Externally change the value of the key-value pair being watched by the watchableObject\n\nParameters:\n * `key`   - if the watchableObject was defined with a key of \"*\", this argument is required and specifies the specific key of the watched table to change the value of.  If a specific key was specified when the watchableObject was defined, this argument must not be provided.\n * `value` - the new value for the key.\n\nReturns:\n * the watchableObject\n\nNotes:\n * if external changes are not allowed for the specified path, this method generates an error"
    },
    "Creates a table that can be watched by other modules for key changes": {
        "prefix": "hs.watchable.new(path, [externalChanges]) -> table",
        "body": "hs.watchable.new(${1:path}, ${2:[externalChanges]})",
        "description": "Creates a table that can be watched by other modules for key changes\n\nParameters:\n * `path`            - the global name for this internal table that external code can refer to the table as.\n * `externalChanges` - an optional boolean, default false, specifying whether external code can make changes to keys within this table (bi-directional communication).\n\nReturns:\n * a table with metamethods which will notify external code which is registered to watch this table for key-value changes.\n\nNotes:\n * This constructor is used by code which wishes to share state information which other code may register to watch.\n\n * You may specify any string name as a path, but it must be unique -- an error will occur if the path name has already been registered.\n * All key-value pairs stored within this table are potentially watchable by external code -- if you wish to keep some data private, do not store it in this table.\n * `externalChanges` will apply to *all* keys within this table -- if you wish to only allow some keys to be externally modifiable, you will need to register separate paths.\n * If external changes are enabled, you will need to register your own watcher with [hs.watchable.watch](#watch) if action is required when external changes occur."
    },
    "Temporarily stop notifications about the key-value pair(s) watched by this watchableObject.": {
        "prefix": "hs.watchable:pause() -> watchableObject",
        "body": "hs.watchable:pause()",
        "description": "Temporarily stop notifications about the key-value pair(s) watched by this watchableObject.\n\nParameters:\n * None\n\nReturns:\n * the watchableObject"
    },
    "Removes the watchableObject so that key-value pairs watched by this object no longer generate notifications.": {
        "prefix": "hs.watchable:release() -> nil",
        "body": "hs.watchable:release()",
        "description": "Removes the watchableObject so that key-value pairs watched by this object no longer generate notifications.\n\nParameters:\n * None\n\nReturns:\n * nil"
    },
    "Resume notifications about the key-value pair(s) watched by this watchableObject which were previously paused.": {
        "prefix": "hs.watchable:resume() -> watchableObject",
        "body": "hs.watchable:resume()",
        "description": "Resume notifications about the key-value pair(s) watched by this watchableObject which were previously paused.\n\nParameters:\n * None\n\nReturns:\n * the watchableObject"
    },
    "Get the current value for the key-value pair being watched by the watchableObject": {
        "prefix": "hs.watchable:value([key]) -> currentValue",
        "body": "hs.watchable:value(${1:[key]})",
        "description": "Get the current value for the key-value pair being watched by the watchableObject\n\nParameters:\n * `key` - if the watchableObject was defined with a key of \"*\", this argument is required and specifies the specific key of the watched table to retrieve the value for.  If a specific key was specified when the watchableObject was defined, this argument is ignored.\n\nReturns:\n * The current value for the key-value pair being watched by the watchableObject. May be nil."
    },
    "Creates a watcher that will be invoked when the specified key in the specified path is modified.": {
        "prefix": "hs.watchable.watch(path, [key], callback) -> watchableObject",
        "body": "hs.watchable.watch(${1:path}, ${2:[key]}, ${3:callback})",
        "description": "Creates a watcher that will be invoked when the specified key in the specified path is modified.\n\nParameters:\n * `path`     - a string specifying the path to watch.  If `key` is not provided, then this should be a string of the form \"path.key\" where the key will be identified as the string after the last \".\"\n * `key`      - if provided, a string specifying the specific key within the path to watch.\n * `callback` - an optional function which will be invoked when changes occur to the key specified within the path.  The function should expect the following arguments:\n   * `watcher` - the watcher object itself\n   * `path`    - the path being watched\n   * `key`     - the specific key within the path which invoked this callback\n   * `old`     - the old value for this key, may be nil\n   * `new`     - the new value for this key, may be nil\n\nReturns:\n * a watchableObject\n\nNotes:\n * This constructor is used by code which wishes to watch state information which is being shared by other code.\n\n * The callback function is invoked after the new value has already been set -- the callback is a \"didChange\" notification, not a \"willChange\" notification.\n\n * If the key (specified as a separate argument or as the final component of path) is \"*\", then all key-value pair changes that occur for the table specified by the path will invoke a callback.  This is a shortcut for watching an entire table, rather than just a specific key-value pair of the table.\n * It is possible to register a watcher for a path that has not been registered with [hs.watchable.new](#new) yet. Retrieving the current value with [hs.watchable:value](#value) in such a case will return nil."
    },
    "Closes a websocket connection.": {
        "prefix": "hs.websocket:close() -> object",
        "body": "hs.websocket:close()",
        "description": "Closes a websocket connection.\n\nParameters:\n * None\n\nReturns:\n * The `hs.websocket` object"
    },
    "Creates a new websocket connection.": {
        "prefix": "hs.websocket.new(url, callback) -> object",
        "body": "hs.websocket.new(${1:url}, ${2:callback})",
        "description": "Creates a new websocket connection.\n\nParameters:\n * url - The URL to the websocket\n * callback - A function that's triggered by websocket actions.\n\nReturns:\n * The `hs.websocket` object\n\nNotes:\n * The callback should accept two parameters.\n * The first paramater is a string with the following possible options:\n  * open - The websocket connection has been opened\n  * closed - The websocket connection has been closed\n  * fail - The websocket connection has failed\n  * received - The websocket has received a message\n  * pong - A pong request has been received\n * The second parameter is a string with the recieved message or an error message.\n * Given a path '/mysock' and a port of 8000, the websocket URL is as follows:\n  * ws://localhost:8000/mysock\n  * wss://localhost:8000/mysock (if SSL enabled)"
    },
    "Sends a message to the websocket client.": {
        "prefix": "hs.websocket:send(message[, isData]) -> object",
        "body": "hs.websocket:send(${1:message[}, ${2:isData]})",
        "description": "Sends a message to the websocket client.\n\nParameters:\n * message - A string containing the message to send.\n * isData - An optional boolean that sends the message as binary data (defaults to true).\n\nReturns:\n * The `hs.websocket` object\n\nNotes:\n * Forcing a text representation by setting isData to `false` may alter the data if it\n  contains invalid UTF8 character sequences (the default string behavior is to make\n  sure everything is \"printable\" by converting invalid sequences into the Unicode\n  Invalid Character sequence)."
    },
    "Gets the status of a websocket.": {
        "prefix": "hs.websocket:status() -> string",
        "body": "hs.websocket:status()",
        "description": "Gets the status of a websocket.\n\nParameters:\n * None\n\nReturns:\n * A string containing one of the following options:\n  * connecting\n  * open\n  * closing\n  * closed\n  * unknown"
    },
    "Get or set whether or not the webview will respond to gestures from a trackpad or magic mouse.  Default is false.": {
        "prefix": "hs.webview:allowGestures([value]) -> webviewObject | current value",
        "body": "hs.webview:allowGestures(${1:[value]})",
        "description": "Get or set whether or not the webview will respond to gestures from a trackpad or magic mouse.  Default is false.\n\nParameters:\n * value - an optional boolean value indicating whether or not the webview should respond gestures.\n\nReturns:\n * If a value is provided, then this method returns the webview object; otherwise the current value\n\nNotes:\n * This is a shorthand method for getting or setting both `hs.webview:allowMagnificationGestures` and `hs.webview:allowNavigationGestures`.\n * This method will set both types of gestures to true or false, if given an argument, but will only return true if *both* gesture types are currently true; if either or both gesture methods are false, then this method will return false."
    },
    "Get or set whether or not the webview will respond to magnification gestures from a trackpad or magic mouse.  Default is false.": {
        "prefix": "hs.webview:allowMagnificationGestures([value]) -> webviewObject | current value",
        "body": "hs.webview:allowMagnificationGestures(${1:[value]})",
        "description": "Get or set whether or not the webview will respond to magnification gestures from a trackpad or magic mouse.  Default is false.\n\nParameters:\n * `value` - an optional boolean value indicating whether or not the webview should respond to magnification gestures.\n\nReturns:\n * If a value is provided, then this method returns the webview object; otherwise the current value"
    },
    "Get or set whether or not the webview will respond to the navigation gestures from a trackpad or magic mouse.  Default is false.": {
        "prefix": "hs.webview:allowNavigationGestures([value]) -> webviewObject | current value",
        "body": "hs.webview:allowNavigationGestures(${1:[value]})",
        "description": "Get or set whether or not the webview will respond to the navigation gestures from a trackpad or magic mouse.  Default is false.\n\nParameters:\n * `value` - an optional boolean value indicating whether or not the webview should respond to navigation gestures.\n\nReturns:\n * If a value is provided, then this method returns the webview object; otherwise the current value"
    },
    "Get or set whether or not the webview allows new windows to be opened from it by any method.  Defaults to true.": {
        "prefix": "hs.webview:allowNewWindows([value]) -> webviewObject | current value",
        "body": "hs.webview:allowNewWindows(${1:[value]})",
        "description": "Get or set whether or not the webview allows new windows to be opened from it by any method.  Defaults to true.\n\nParameters:\n * `value` - an optional boolean value indicating whether or not the webview should allow new windows to be opened from it.\n\nReturns:\n * If a value is provided, then this method returns the webview object; otherwise the current value\n\nNotes:\n * This method allows you to prevent a webview from being able to open a new window by any method.   This includes right-clicking on a link and selecting \"Open in a New Window\", JavaScript pop-ups, links with the target of \"__blank\", etc.\n * If you just want to prevent automatic JavaScript windows, set the preference value javaScriptCanOpenWindowsAutomatically to false when creating the web view - this method blocks *all* methods."
    },
    "Get or set whether or not the webview can accept keyboard for web form entry. Defaults to false.": {
        "prefix": "hs.webview:allowTextEntry([value]) -> webviewObject | current value",
        "body": "hs.webview:allowTextEntry(${1:[value]})",
        "description": "Get or set whether or not the webview can accept keyboard for web form entry. Defaults to false.\n\nParameters:\n * `value` - an optional boolean value which sets whether or not the webview will accept keyboard input.\n\nReturns:\n * If a value is provided, then this method returns the webview object; otherwise the current value"
    },
    "Get or set the alpha level of the window containing the hs.webview object.": {
        "prefix": "hs.webview:alpha([alpha]) -> webviewObject | currentValue",
        "body": "hs.webview:alpha(${1:[alpha]})",
        "description": "Get or set the alpha level of the window containing the hs.webview object.\n\nParameters:\n * `alpha` - an optional number between 0.0 and 1.0 specifying the new alpha level for the webview.\n\nReturns:\n * If a parameter is provided, returns the webview object; otherwise returns the current value."
    },
    "Because use of this method can easily lead to a crash, useful methods from `hs.drawing` have been added to the `hs.webview` module itself.  If you believe that a useful method has been overlooked, please submit an issue.": {
        "prefix": "hs.webview:asHSDrawing() -> hs.drawing object",
        "body": "hs.webview:asHSDrawing()",
        "description": "Because use of this method can easily lead to a crash, useful methods from `hs.drawing` have been added to the `hs.webview` module itself.  If you believe that a useful method has been overlooked, please submit an issue.\n\nParameters:\n * None\n\nReturns:\n * a placeholder object"
    },
    "Returns an hs.window object for the webview so that you can use hs.window methods on it.": {
        "prefix": "hs.webview:hswindow() -> hs.window object",
        "body": "hs.webview:hswindow()",
        "description": "Returns an hs.window object for the webview so that you can use hs.window methods on it.\n\nParameters:\n * None\n\nReturns:\n * an hs.window object\n\nNotes:\n * hs.window:minimize only works if the webview is minimizable (see `hs.webview.windowStyle`)\n * hs.window:setSize only works if the webview is resizable (see `hs.webview.windowStyle`)\n * hs.window:close only works if the webview is closable (see `hs.webview.windowStyle`)\n * hs.window:maximize will reposition the webview to the upper left corner of your screen, but will only resize the webview if the webview is resizable (see `hs.webview.windowStyle`)"
    },
    "Get or attach/detach a toolbar to/from the webview.": {
        "prefix": "hs.webview:attachedToolbar([toolbar | nil]) -> webviewObject | currentValue",
        "body": "hs.webview:attachedToolbar(${1:[toolbar | nil]})",
        "description": "Get or attach/detach a toolbar to/from the webview.\n\nParameters:\n * `toolbar` - if an `hs.webview.toolbar` object is specified, it will be attached to the webview.  If an explicit nil is specified, the current toolbar will be removed from the webview.\n\nReturns:\n * if a toolbarObject or explicit nil is specified, returns the webviewObject; otherwise returns the current toolbarObject or nil, if no toolbar is attached to the webview.\n\nNotes:\n * this method is a convenience wrapper for the `hs.webview.toolbar.attachToolbar` function.\n\n * If the toolbarObject is currently attached to another window when this method is called, it will be detached from the original window and attached to the webview.  If you wish to attach the same toolbar to multiple webviews, see `hs.webview.toolbar:copy`."
    },
    "Get or set the window behavior settings for the webview object.": {
        "prefix": "hs.webview:behavior([behavior]) -> webviewObject | currentValue",
        "body": "hs.webview:behavior(${1:[behavior]})",
        "description": "Get or set the window behavior settings for the webview object.\n\nParameters:\n * `behavior` - an optional number representing the desired window behaviors for the webview object.\n\nReturns:\n * If an argument is provided, the webview object; otherwise the current value.\n\nNotes:\n * Window behaviors determine how the webview object is handled by Spaces and Expos\u00e9. See `hs.drawing.windowBehaviors` for more information."
    },
    "Get or set the window behavior settings for the webview object using labels defined in `hs.drawing.windowBehaviors`.": {
        "prefix": "hs.webview:behaviorAsLabels(behaviorTable) -> webviewObject | currentValue",
        "body": "hs.webview:behaviorAsLabels(${1:behaviorTable})",
        "description": "Get or set the window behavior settings for the webview object using labels defined in `hs.drawing.windowBehaviors`.\n\nParameters:\n * behaviorTable - an optional table of strings and/or numbers specifying the desired window behavior for the webview object.\n\nReturns:\n * If an argument is provided, the webview object; otherwise the current value.\n\nNotes:\n * Window behaviors determine how the webview object is handled by Spaces and Expos\u00e9. See `hs.drawing.windowBehaviors` for more information."
    },
    "Returns the certificate chain for the most recently committed navigation of the webview.": {
        "prefix": "hs.webview:certificateChain() -> table | nil",
        "body": "hs.webview:certificateChain()",
        "description": "Returns the certificate chain for the most recently committed navigation of the webview.\n\nParameters:\n * None\n\nReturns:\n * a table containing the certificates that make up the SSL certificate chain securing the most recent committed navigation.  Each certificate is described in a table with the following keys:\n   * `commonName` - the common name for the certificate; most commonly this will be a string matching the server portion of the URL request or other descriptor of the certificate's purpose.\n   * `values`     - a table containing key-value pairs describing the certificate.  The keys will be certificate OIDs.  Common OIDs and their meaning can be found in [hs.webview.certificateOIDs](#certificateOIDs). The value for each key will be a table with the following keys:\n     * `label`           - a description or label for the entry\n     * `localized label` - a localized version of `label`\n     * `type`            - a description of the data type for this value\n     * `value`           - the value\n\nNotes:\n * This method is only supported by OS X 10.11 and newer\n * A navigation which was performed via HTTP instead of HTTPS will return an empty array.\n\n * For OIDs which specify a type of \"date\" -- e.g. \"2.5.29.24\" (invalidityDate) -- the number provided represents the number of seconds since 12:00:00 AM, January 1, 1970 and can be used directly with the Lua `os.date` command.\n * For OIDs which are known to represent a date, but specify its type as a \"number\" -- e.g. \"2.16.840.1.113741.2.1.1.1.7\" (X509V1ValidityNotAfter) or \"2.16.840.1.113741.2.1.1.1.6\" (X509V1ValidityNotBefore) -- the epoch is 12:00:00 AM, Jan 1, 2001.  To convert these dates into a format usable by Lua, you will need to do something similar to the following:  `os.date(\"%c\", value + os.time({year=2001,month=1,day=1,hour=0,min=0,sec=0})`"
    },
    "A table of common OID values found in SSL certificates.  SSL certificates provided to the callback function for [hs.webview:sslCallback](#sslCallback) or in the results of [hs.webview:certificateChain](#certificateChain) use OID strings as the keys which describe the properties of the certificate and this table can be used to get a more common name for the keys you are most likely to see.": {
        "prefix": "hs.webview.certificateOIDs[]",
        "body": "hs.webview.certificateOIDs",
        "description": "A table of common OID values found in SSL certificates.  SSL certificates provided to the callback function for [hs.webview:sslCallback](#sslCallback) or in the results of [hs.webview:certificateChain](#certificateChain) use OID strings as the keys which describe the properties of the certificate and this table can be used to get a more common name for the keys you are most likely to see.\n\nThis list is based on the contents of OS X's /System/Library/Frameworks/Security.framework/Headers/SecCertificateOIDs.h."
    },
    "Returns an array of webview objects which have been opened as children of this webview.": {
        "prefix": "hs.webview:children() -> array",
        "body": "hs.webview:children()",
        "description": "Returns an array of webview objects which have been opened as children of this webview.\n\nParameters:\n * None\n\nReturns:\n * an array containing the webview objects of all child windows opened from this webview."
    },
    "If the webview is closable, this will get or set whether or not the Escape key is allowed to close the webview window.": {
        "prefix": "hs.webview:closeOnEscape([flag]) -> webviewObject | current value",
        "body": "hs.webview:closeOnEscape(${1:[flag]})",
        "description": "If the webview is closable, this will get or set whether or not the Escape key is allowed to close the webview window.\n\nParameters:\n * `flag` - an optional boolean value which indicates whether a webview, when it's style includes Closable (see `hs.webview:windowStyle`), should allow the Escape key to be a shortcut for closing the webview window.  Defaults to false.\n\nReturns:\n * If a value is provided, then this method returns the webview object; otherwise the current value\n\nNotes:\n * If this is set to true, Escape will only close the window if no other element responds to the Escape key first (e.g. if you are editing a text input field, the Escape will be captured by the text field, not by the webview Window.)"
    },
    "Set or display whether or not the `hs.webview` window should display in dark mode.": {
        "prefix": "hs.webview:darkMode([state]) -> bool",
        "body": "hs.webview:darkMode(${1:[state]})",
        "description": "Set or display whether or not the `hs.webview` window should display in dark mode.\n\nParameters:\n * `state` - an optional boolean which will set whether or not the `hs.webview` window should display in dark mode.\n\nReturns:\n * A boolean, `true` if dark mode is enabled otherwise `false`."
    },
    "Destroys the webview object, optionally fading it out first (if currently visible).": {
        "prefix": "hs.webview:delete([propagate], [fadeOutTime]) -> none",
        "body": "hs.webview:delete(${1:[propagate]}, ${2:[fadeOutTime]})",
        "description": "Destroys the webview object, optionally fading it out first (if currently visible).\n\nParameters:\n * `propagate`   - an optional boolean, default false, which indicates whether or not the child windows of this webview should also be deleted.\n * `fadeOutTime` - an optional number of seconds over which to fade out the webview object. Defaults to zero.\n\nReturns:\n * None\n\nNotes:\n * This method is automatically called during garbage collection, notably during a Hammerspoon termination or reload, with a fade time of 0."
    },
    "Get or set whether or not the webview should delete itself when its window is closed.": {
        "prefix": "hs.webview:deleteOnClose([value]) -> webviewObject | current value",
        "body": "hs.webview:deleteOnClose(${1:[value]})",
        "description": "Get or set whether or not the webview should delete itself when its window is closed.\n\nParameters:\n * `value` - an optional boolean value which sets whether or not the webview will delete itself when its window is closed by any method.  Defaults to false for a window created with `hs.webview.new` and true for any webview windows created by the main webview (user selects \"Open Link in New Window\", etc.)\n\nReturns:\n * If a value is provided, then this method returns the webview object; otherwise the current value\n\nNotes:\n * If set to true, a webview object will be deleted when the user clicks on the close button of a titled and closable webview (see `hs.webview.windowStyle`).\n * Children of an explicitly created webview automatically have this attribute set to true.  To cause closed children to remain after the user closes the parent, you can set this to false with a policy callback function when it receives the \"newWindow\" action."
    },
    "Returns the estimated percentage of expected content that has been loaded.  Will equal 1.0 when all content has been loaded.": {
        "prefix": "hs.webview:estimatedProgress() -> number",
        "body": "hs.webview:estimatedProgress()",
        "description": "Returns the estimated percentage of expected content that has been loaded.  Will equal 1.0 when all content has been loaded.\n\nParameters:\n * None\n\nReturns:\n * a numerical value between 0.0 and 1.0 indicating the percentage of expected content which has been loaded."
    },
    "Execute JavaScript within the context of the current webview and optionally receive its result or error in a callback function.": {
        "prefix": "hs.webview:evaluateJavaScript(script, [callback]) -> webviewObject",
        "body": "hs.webview:evaluateJavaScript(${1:script}, ${2:[callback]})",
        "description": "Execute JavaScript within the context of the current webview and optionally receive its result or error in a callback function.\n\nParameters:\n * `script` - the JavaScript to execute within the context of the current webview's display\n * `callback` - an optional function which should accept two parameters as the result of the executed JavaScript.  The function parameters are as follows:\n   * `result` - the result of the executed JavaScript code or nil if there was no result or an error occurred.\n   * `error`  - an NSError table describing any error that occurred during the JavaScript execution or nil if no error occurred.\n\nReturns:\n * the webview object"
    },
    "Get or set whether or not invalid SSL server certificates that are approved by the ssl callback function are accepted as valid for browsing with the webview.": {
        "prefix": "hs.webview:examineInvalidCertificates([flag]) -> webviewObject | current value",
        "body": "hs.webview:examineInvalidCertificates(${1:[flag]})",
        "description": "Get or set whether or not invalid SSL server certificates that are approved by the ssl callback function are accepted as valid for browsing with the webview.\n\nParameters:\n* `flag` - an optional boolean, default false, specifying whether or not an invalid SSL server certificate should be  accepted if it is approved by the ssl callback function.\n\nReturns:\n * If a value is provided, then this method returns the webview object; otherwise the current value\n\nNotes:\n * In order for this setting to have any effect, you must also register an ssl callback function with [hs.webview:sslCallback](#sslCallback) which should return true if the certificate should be granted an exception or false if it should not.  For a certificate to be granted an exception, both this method and the result of the callback *must* be true.\n\n * A server certificate may be invalid for a variety of reasons:\n   * it is not signed by a recognized certificate authority - most commonly this means the certificate is self-signed.\n   * the certificate has expired\n   * the certificate has a common name (web site server name) other than the one requested (e.g. the certificate's common name is www.site.com, but it is being used for something else, possibly just https://site.com, possibly something else entirely\n   * some corporate proxy servers don't handle SSL properly and can cause a certificate to appear invalid even when they are valid (this is less common then it used to be, but does still occur occasionally)\n   * potentially nefarious reasons including man-in-the-middle attacks or phishing scams.\n\n * The Hammerspoon server provided by `hs.httpserver` uses a self-signed certificate when set to use SSL, so it will be considered invalid for reason 1 above.\n\n* If the certificate has been granted an exception in another application which registers the exception in the user's keychain (e.g. Safari), then the certificate is no longer considered invalid and this setting has no effect for that certificate."
    },
    "Get or set the frame of the webview window.": {
        "prefix": "hs.webview:frame([rect]) -> webviewObject | currentValue",
        "body": "hs.webview:frame(${1:[rect]})",
        "description": "Get or set the frame of the webview window.\n\nParameters:\n * rect - An optional rect-table containing the co-ordinates and size the webview window should be moved and set to\n\nReturns:\n * If an argument is provided, the webview object; otherwise the current value.\n\nNotes:\n * a rect-table is a table with key-value pairs specifying the new top-left coordinate on the screen of the webview window (keys `x`  and `y`) and the new size (keys `h` and `w`).  The table may be crafted by any method which includes these keys, including the use of an `hs.geometry` object."
    },
    "Move to the previous page in the webview's history, if possible.": {
        "prefix": "hs.webview:goBack() -> webviewObject",
        "body": "hs.webview:goBack()",
        "description": "Move to the previous page in the webview's history, if possible.\n\nParameters:\n * None\n\nReturns:\n * The webview Object"
    },
    "Move to the next page in the webview's history, if possible.": {
        "prefix": "hs.webview:goForward() -> webviewObject",
        "body": "hs.webview:goForward()",
        "description": "Move to the next page in the webview's history, if possible.\n\nParameters:\n * None\n\nReturns:\n * The webview Object"
    },
    "Hides the webview object": {
        "prefix": "hs.webview:hide([fadeOutTime]) -> webviewObject",
        "body": "hs.webview:hide(${1:[fadeOutTime]})",
        "description": "Hides the webview object\n\nParameters:\n * `fadeOutTime` - An optional number of seconds over which to fade out the webview. Defaults to zero\n\nReturns:\n * The webview object"
    },
    "Returns the URL history for the current webview as an array.": {
        "prefix": "hs.webview:historyList() -> historyTable",
        "body": "hs.webview:historyList()",
        "description": "Returns the URL history for the current webview as an array.\n\nParameters:\n * None\n\nReturns:\n * A table which is an array of the URLs viewed within this webview and a key named `current` which is equal to the index corresponding to the currently visible entry.  Each array element will be a table with the following keys:\n   * `URL`        - the URL of the web page\n   * `initialURL` - the URL of the initial request that led to this item\n   * `title`      - the web page title"
    },
    "Render the given HTML in the webview with an optional base URL for relative links.": {
        "prefix": "hs.webview:html(html,[baseURL]) -> webviewObject, navigationIdentifier",
        "body": "hs.webview:${1:html}(html,${2:[baseURL]})",
        "description": "Render the given HTML in the webview with an optional base URL for relative links.\n\nParameters:\n * `html`    - the html to be rendered in the webview\n * `baseURL` - an optional Base URL to use as the starting point for any relative links within the provided html.\n\nReturns:\n * The webview Object\n\nNotes:\n * Web Pages generated in this manner are not added to the webview history list"
    },
    "Returns a boolean value indicating if all content current displayed in the webview was loaded over securely encrypted connections.": {
        "prefix": "hs.webview:isOnlySecureContent() -> bool",
        "body": "hs.webview:isOnlySecureContent()",
        "description": "Returns a boolean value indicating if all content current displayed in the webview was loaded over securely encrypted connections.\n\nParameters:\n * None\n\nReturns:\n * true if all content current displayed in the web view was loaded over securely encrypted connections; otherwise false."
    },
    "Checks to see if a webview window is visible or not.": {
        "prefix": "hs.webview:isVisible() -> boolean",
        "body": "hs.webview:isVisible()",
        "description": "Checks to see if a webview window is visible or not.\n\nParameters:\n * None\n\nReturns:\n * `true` if the webview window is visible, otherwise `false`"
    },
    "Get or set the window level": {
        "prefix": "hs.webview:level([theLevel]) -> drawingObject | currentValue",
        "body": "hs.webview:level(${1:[theLevel]})",
        "description": "Get or set the window level\n\nParameters:\n * `theLevel` - an optional parameter specifying the desired level as an integer, which can be obtained from `hs.drawing.windowLevels`.\n\nReturns:\n * if a parameter is specified, returns the webview object, otherwise the current value\n\nNotes:\n * see the notes for `hs.drawing.windowLevels`"
    },
    "Returns a boolean value indicating whether or not the vebview is still loading content.": {
        "prefix": "hs.webview:loading() -> boolean",
        "body": "hs.webview:loading()",
        "description": "Returns a boolean value indicating whether or not the vebview is still loading content.\n\nParameters:\n * None\n\nReturns:\n * true if the content is still being loaded, or false if it has completed."
    },
    "Get or set the webviews current magnification level. Default is 1.0.": {
        "prefix": "hs.webview:magnification([value]) -> webviewObject | current value",
        "body": "hs.webview:magnification(${1:[value]})",
        "description": "Get or set the webviews current magnification level. Default is 1.0.\n\nParameters:\n * `value` - an optional number specifying the webviews magnification level.\n\nReturns:\n * If a value is provided, then this method returns the webview object; otherwise the current value"
    },
    "Sets a callback for tracking a webview's navigation process.": {
        "prefix": "hs.webview:navigationCallback(fn) -> webviewObject",
        "body": "hs.webview:navigationCallback(${1:fn})",
        "description": "Sets a callback for tracking a webview's navigation process.\n\nParameters:\n * `fn` - the function to be called when the navigation status of a webview cahnges.  To disable the callback function, explicitly specify nil.  The function should expect 3 or 4 arguments and may optionally return 1.  The function arguments are defined as follows:\n   * `action`  - a string indicating the webview's current status.  It will be one of the following:\n     * `didStartProvisionalNavigation`                    - a request or action to change the contents of the main frame has occurred\n     * `didReceiveServerRedirectForProvisionalNavigation` - a server redirect was received for the main frame\n     * `didCommitNavigation`                              - content has started arriving for the main frame\n     * `didFinishNavigation`                              - the webview's main frame has completed loading.\n     * `didFailNavigation`                                - an error has occurred after content started arriving\n     * `didFailProvisionalNavigation`                     - an error has occurred as or before content has started arriving\n   * `webView` - the webview object the navigation is occurring for.\n   * `navID`   - a navigation identifier which can be used to link this event back to a specific request made by a `hs.webview:url`, `hs.webview:html`, or `hs.webview:reload` method.\n   * `error`   - a table which will only be provided when `action` is equal to `didFailNavigation` or `didFailProvisionalNavigation`.  If provided, it will contain at leas some of the following keys, possibly others as well:\n     * `code`        - a numerical value indicating the type of error code.  This will mostly be of use to developers or in debugging and may be removed in the future.\n     * `domain`      - a string indcating the error domain of the error.  This will mostly be of use to developers or in debugging and may be removed in the future.\n     * `description` - a string describing the condition or problem that has occurred.\n     * `reason`      - if available, more information about what may have caused the problem to occur.\n\nReturns:\n * The webview object\n\nNotes:\n * The return value of the callback function is ignored except when the `action` argument is equal to `didFailNavigation` or `didFailProvisionalNavigation`.  If the return value when the action argument is one of these values is a string, it will be treated as html and displayed in the webview as the error message.  If the return value is the boolean value true, then no change will be made to the webview (it will continue to display the previous web page).  All other return values or no return value at all, if these navigation actions occur, will cause a default error page to be displayed in the webview."
    },
    "Get the most recent navigation identifier for the specified webview.": {
        "prefix": "hs.webview:navigationID() -> navigationID",
        "body": "hs.webview:navigationID()",
        "description": "Get the most recent navigation identifier for the specified webview.\n\nParameters:\n * None\n\nReturns:\n * the navigation identifier\n\nNotes:\n * This navigation identifier can be used to track the progress of a webview with the navigation callback function - see `hs.webview.navigationCallback`."
    },
    "Create a webviewObject and optionally modify its preferences.": {
        "prefix": "hs.webview.new(rect, [preferencesTable], [userContentController]) -> webviewObject",
        "body": "hs.webview.new(${1:rect}, ${2:[preferencesTable]}, ${3:[userContentController]})",
        "description": "Create a webviewObject and optionally modify its preferences.\n\nParameters:\n * `rect` - a rectangle specifying where the webviewObject should be displayed.\n * `preferencesTable` - an optional table which can include one of more of the following keys:\n  * `javaEnabled`                           - java is enabled (default false)\n  * `javaScriptEnabled`                     - JavaScript is enabled (default true)\n  * `javaScriptCanOpenWindowsAutomatically` - can JavaScript open windows without user intervention (default true)\n  * `minimumFontSize`                       - minimum font size (default 0.0)\n  * `plugInsEnabled`                        - plug-ins are enabled (default false)\n  * `developerExtrasEnabled`                - include \"Inspect Element\" in the context menu\n  * `suppressesIncrementalRendering`        - suppresses content rendering until fully loaded into memory (default false)\n\n  * The following additional preferences may also be set under OS X 10.11 or later (they will be ignored with a warning printed if used under OS X 10.10):\n    * `applicationName`                       - a string specifying an application name to be listed at the end of the browser's USER-AGENT header.  Note that this is only appended to the default user agent string; if you set a custom one with [hs.webview:userAgent](#userAgent), this value is ignored.\n    * `allowsAirPlay`                         - a boolean specifying whether media playback within the webview can play through AirPlay devices.\n    * `datastore`                             - an `hs.webview.datastore` object specifying where website data such as cookies, cacheable content, etc. is to be stored.\n    * `privateBrowsing`                       - a boolean (default false) specifying that the datastore should be set to a new, empty and non-persistent datastore.  Note that this will override the `datastore` key if both are specified and this is set to true.\n * `userContentController` - an optional `hs.webview.usercontent` object to provide script injection and JavaScript messaging with Hammerspoon from the webview.\n\nReturns:\n * The webview object\n\nNotes:\n * To set the initial URL, use the `hs.webview:url` method before showing the webview object.\n * Preferences can only be set when the webview object is created.  To change the preferences of an open webview, you will need to close it and recreate it with this method.\n\n * developerExtrasEnabled is not listed in Apple's documentation, but is included in the WebKit2 documentation."
    },
    "Create a webviewObject with some presets common to an interactive web browser.": {
        "prefix": "hs.webview.newBrowser(rect, [preferencesTable], [userContentController]) -> webviewObject",
        "body": "hs.webview.newBrowser(${1:rect}, ${2:[preferencesTable]}, ${3:[userContentController]})",
        "description": "Create a webviewObject with some presets common to an interactive web browser.\n\nParameters:\n * The parameters are the same as for [hs.webview.new](#new) -- check there for more details\n   * `rect`                  - a rectangle specifying where the webviewObject should be displayed.\n   * `preferencesTable`      - an optional table which specifies special settings for the webview object.\n   * `userContentController` - an optional `hs.webview.usercontent` object to provide script injection and JavaScript messaging with Hammerspoon from the webview.\n\nReturns:\n * The webview object\n\nNotes:\n * This constructor is just a short-hand for `hs.webview.new(...):allowTextEntry(true):allowGestures(true):windowStyle(15)`, which specifies a webview with a title bar, title bar buttons (zoom, close, minimize), and allows form entry and gesture support for previous and next pages.\n\n* See [hs.webview.new](#new) and the following for more details:\n  * [hs.webview:allowGestures](#allowGestures)\n  * [hs.webview:allowTextEntry](#allowTextEntry)\n  * [hs.webview:windowStyle](#windowStyle)\n  * [hs.webview.windowMasks](#windowMasks)"
    },
    "Moves webview object above webview2, or all webview objects in the same presentation level, if webview2 is not given.": {
        "prefix": "hs.webview:orderAbove([webview2]) -> webviewObject",
        "body": "hs.webview:orderAbove(${1:[webview2]})",
        "description": "Moves webview object above webview2, or all webview objects in the same presentation level, if webview2 is not given.\n\nParameters:\n * `webview2` -An optional webview object to place the webview object above.\n\nReturns:\n * The webview object\n\nNotes:\n * If the webview object and webview2 are not at the same presentation level, this method will will move the webview object as close to the desired relationship without changing the webview object's presentation level. See [hs.webview.level](#level)."
    },
    "Moves webview object below webview2, or all webview objects in the same presentation level, if webview2 is not given.": {
        "prefix": "hs.webview:orderBelow([webview2]) -> webviewObject",
        "body": "hs.webview:orderBelow(${1:[webview2]})",
        "description": "Moves webview object below webview2, or all webview objects in the same presentation level, if webview2 is not given.\n\nParameters:\n * `webview2` -An optional webview object to place the webview object below.\n\nReturns:\n * The webview object\n\nNotes:\n * If the webview object and webview2 are not at the same presentation level, this method will will move the webview object as close to the desired relationship without changing the webview object's presentation level. See [hs.webview.level](#level)."
    },
    "Get the parent webview object for the calling webview object, or nil if the webview has no parent.": {
        "prefix": "hs.webview:parent() -> webviewObject | nil",
        "body": "hs.webview:parent()",
        "description": "Get the parent webview object for the calling webview object, or nil if the webview has no parent.\n\nParameters:\n * None\n\nReturns:\n * the parent webview object for the calling webview object, or nil if the webview has no parent"
    },
    "Sets a callback to approve or deny web navigation activity.": {
        "prefix": "hs.webview:policyCallback(fn) -> webviewObject",
        "body": "hs.webview:policyCallback(${1:fn})",
        "description": "Sets a callback to approve or deny web navigation activity.\n\nParameters:\n * `fn` - the function to be called to approve or deny web navigation activity.  To disable the callback function, explicitly specify nil.  The callback function will accept three or four arguments and must return 1 argument which will determine if the action is approved or denied.  The first argument will specify the type of policy request and will determine the second and third arguments as follows:\n\n   * `navigationAction`: This applies to any connection to a server or service which supplies content for the webview and occurs before any connection has actually been made.\n     * the second argument will be the webview this request originates from.\n     * the third argument will be a table about the navigation action requested and may contain any of the following keys:\n       * `request`        - a table containing the request for that generated this policy action request.  See `hs.webview.url` for details on what keys may be present in this table.\n       * `sourceFrame`    - a table describing the frame in which the request occurred containing the following keys:\n         * `mainFrame`      - a boolean value indicating if this is the main view frame of the webview or not\n         * `request`        - a table containing the request for this frame.  See `hs.webview.url` for details on what keys may be present in this table.\n       * `targetFrame`    - a table with the same keys as `sourceFrame`, but describing the target of the request, if it differs.\n       * `buttonNumber`   - a number indicating the mouse button pressed that initiated this action or 0 if no mouse button was involved (for example, a url specified via `hs.webview.url` or a request for an image, etc. as part of rendering an earlier request).\n       * `modifierFlags`  - a table containing keys for the keyboard modifiers which were pressed when the navigation generating this policy request was generated.\n       * `navigationType` - a string indicating how the navigation was requested: `linkActivated`, `formSubmitted`, `backForward`, `reload`, `formResubmitted`, or `other`\n   * The callback function should return `true` if the navigation should proceed or false if it should be denied.\n\n   * `navigationResponse`: This applies to any connection to a server or service which supplies content for the webview and occurs after the connection has been made but before it has been rendered in the webview.\n     * the second argument will be the webview this request originates from.\n     * the third argument will be a table about the response received and may contain any of the following keys:\n       * `canShowMIMEType` - a boolean indicating whether or not the webview can display the content either natively or with a plugin.  If this value is false, it is likely the content either cannot be displayed at all or will appear as gibberish in the webview.\n       * `forMainFrame`    - a boolean indicating if the response is for a navigation of the main frames primary content (i.e. not an image or sub-frame, etc.)\n       * `response`        - a table describing the response to the URL request and may contain any of the following keys:\n         * `expectedContentLength` - the expected length of the response content\n         * `suggestedFileName`     - a suggested filename for the response data\n         * `MIMEType`              - the MIME type of the response data\n         * `textEncodingName`      - if the response is text, then this will contain the encoding type used\n         * `URL`                   - the URL of the actual response.  Note that this may differ from the original request due to redirects, etc.\n         * `statusCode`            - the HTTP response code for the request\n         * `statusCodeDescription` - a localized description of the response code\n         * `allHeaderFields`       - a table containing the header fields and values provided in the response\n   * The callback function should return `true` if the navigation should proceed or false if it should be denied.\n\n   * `newWindow`: This applies to any request to create a new window from a webview.  This includes JavaScript, the user selecting \"Open in a new window\", etc.\n     * the second argument will be the new webview this request is generating.\n     * the third argument will be a table about the navigation action requested.  See the description above for `navigationAction` for details about this parameter.\n     * the fourth argument will be a table containing features requested for the new window (none of these will be addressed by default -- you can choose to honor or disregard the feature requests in the callback yourself) and may contain any of the following keys:\n       * `menuBarVisibility`   - Whether the menu bar should be visible. (Not a feature provided for windows under OS X)\n       * `statusBarVisibility` - Whether the status bar should be visible. (Not currently supported by this module)\n       * `toolbarsVisibility`  - Whether toolbars should be visible.\n       * `allowsResizing`      - Whether the new window should be resizable.\n       * `x`                   - The x coordinate of the new window.\n       * `y`                   - The y coordinate of the new window.\n       * `h`                   - The height coordinate of the new window.\n       * `w`                   - The width coordinate of the new window.\n   * The callback function should return `true` if the new window should be created or false if it should not.\n\n   * `authenticationChallenge`:  This applies to a web page which requires a log in credential for HTTPBasic or HTTPDigest authentication.\n     * the second argument will be the webview this request originates from.\n     * the third argument will be a table containing the challenge details and may contain any of the following keys:\n       * `previousFailureCount` - an integer indicating the number of previously failed login attempts.  This will be 0 for the first try.\n       * `failureResponse`      - the response data as described for `navigationResponse` above for the last authentication failureResponse\n       * `proposedCredential`   - a table containing the previously failed credential containing any of the following keys:\n         * `hasPassword`          - a boolean value indicating if a password was provided with this credential\n         * `persistence`          - a string value identifying the persistence of this credential.  This value will be one of the following:\n           * None                 - the credential is for this URL request only and no other\n           * `session`              - the credential is for this session and will be forgotten once the webview is deleted\n           * `permanent`            - the credential is stored in the user's keychain\n           * `synchronized`         - the credential is stored in the user's keychain and may be shared with other devices with the same owning Apple ID.\n         * `user`                 - the username of the failed credential\n         * `password`             - the password of the failed credential\n       * `protectionSpace`      - a table describing the realm for the authentication and may contain any of the following keys:\n         * `port`                       - the port of the server with which communication for this request is occurring\n         * `receivesCredentialSecurely` - a boolean value indicating whether or not the credential can be sent to the server securely\n         * `authenticationMethod`       - a string indicating the authentication type: default, HTTPBasic, or HTTPDigest.  Other types exists but are not currently supported with this module or do not apply to webview activities.\n         * `host`                       - the host name of the server with which communication for this request is occurring\n         * `protocol`                   - the protocol for which the authentication is occurring\n         * `isProxy`                    - a boolean indicating whether or not the authentication is occurring with a proxy server\n         * `proxyType`                  - a string representing the type of proxy server: http, https, ftp, or socks.\n         * `realm`                      - a string representing the realm name for the authentication.\n   * The callback function should return true if the user should be prompted for the username and password credentials, a table with the keys `user` and `password` containing the username and password to log in with, or false if the login request should be cancelled.  Note that if your function returns a table and fails to authenticate three times, the user will be prompted anyways to prevent loops.\n\nReturns:\n * The webview object\n\nNotes:\n * With the `newWindow` action, the navigationCallback and policyCallback are automatically replicated for the new window from its parent.  If you wish to disable these for the new window or assign a different set of callback functions, you can do so before returning true in the callback function with the webview argument provided."
    },
    "Returns whether or not the webview browser is set up for private browsing (i.e. uses a non-persistent datastore)": {
        "prefix": "hs.webview:privateBrowsing() -> boolean",
        "body": "hs.webview:privateBrowsing()",
        "description": "Returns whether or not the webview browser is set up for private browsing (i.e. uses a non-persistent datastore)\n\nParameters:\n * None\n\nReturns:\n * a boolean value indicating whether or not the datastore is non-persistent.\n\nNotes:\n * This method is only supported by OS X 10.11 and newer\n\n * See `hs.webview.datastore` and [hs.webview.new](#new) for more information."
    },
    "Reload the page in the webview, optionally performing end-to-end revalidation using cache-validating conditionals if possible.": {
        "prefix": "hs.webview:reload([validate]) -> webviewObject, navigationIdentifier",
        "body": "hs.webview:reload(${1:[validate]})",
        "description": "Reload the page in the webview, optionally performing end-to-end revalidation using cache-validating conditionals if possible.\n\nParameters:\n * `validate` - an optional boolean indicating whether or not an attempt to perform end-to-end revalidation of cached data should be performed.  Defaults to false.\n\nReturns:\n * The webview Object"
    },
    "Places the webview object behind normal windows, between the desktop wallpaper and desktop icons": {
        "prefix": "hs.webview:sendToBack() -> webviewObject",
        "body": "hs.webview:sendToBack()",
        "description": "Places the webview object behind normal windows, between the desktop wallpaper and desktop icons\n\nParameters:\n * None\n\nReturns:\n * The drawing object"
    },
    "Deprecated; you should use [hs.webview:level](#level) instead.": {
        "prefix": "hs.webview:setLevel(theLevel) -> drawingObject",
        "body": "hs.webview:setLevel(${1:theLevel})",
        "description": "Deprecated; you should use [hs.webview:level](#level) instead.\n\nParameters:\n * `theLevel` - the level specified as a number, which can be obtained from `hs.drawing.windowLevels`.\n\nReturns:\n * the webview object\n\nNotes:\n * see the notes for `hs.drawing.windowLevels`"
    },
    "Get or set whether or not the webview window has shadows. Default to false.": {
        "prefix": "hs.webview:shadow([value]) -> webviewObject | current value",
        "body": "hs.webview:shadow(${1:[value]})",
        "description": "Get or set whether or not the webview window has shadows. Default to false.\n\nParameters:\n * `value` - an optional boolean value indicating whether or not the webview should have shadows.\n\nReturns:\n * If a value is provided, then this method returns the webview object; otherwise the current value"
    },
    "Displays the webview object": {
        "prefix": "hs.webview:show([fadeInTime]) -> webviewObject",
        "body": "hs.webview:show(${1:[fadeInTime]})",
        "description": "Displays the webview object\n\nParameters:\n * `fadeInTime` - An optional number of seconds over which to fade in the webview. Defaults to zero\n\nReturns:\n * The webview object"
    },
    "Get or set the size of a webview window": {
        "prefix": "hs.webview:size([size]) -> webviewObject | currentValue",
        "body": "hs.webview:size(${1:[size]})",
        "description": "Get or set the size of a webview window\n\nParameters:\n * `size` - An optional size-table specifying the width and height the webview window should be resized to\n\nReturns:\n * If an argument is provided, the webview object; otherwise the current value.\n\nNotes:\n * a size-table is a table with key-value pairs specifying the size (keys `h` and `w`) the webview should be resized to. The table may be crafted by any method which includes these keys, including the use of an `hs.geometry` object."
    },
    "Sets a callback to examine an invalid SSL certificate and determine if an exception should be granted.": {
        "prefix": "hs.webview:sslCallback(fn) -> webviewObject",
        "body": "hs.webview:sslCallback(${1:fn})",
        "description": "Sets a callback to examine an invalid SSL certificate and determine if an exception should be granted.\n\nParameters:\n * `fn` - the function to be called to examine the SSL certificate to determine if an exception should be granted.  To disable the callback function, explicitly specify nil.  The callback function will accept two arguments and must return 1 argument which will determine if the action is approved or denied.  The first argument will be the webview this request originates from.  The second argument will be a table containing the protection space details and may include the following keys:\n\n   * `port`                       - the port of the server with which communication for this request is occurring\n   * `receivesCredentialSecurely` - a boolean value indicating whether or not the credential can be sent to the server securely\n   * `authenticationMethod`       - a string indicating the authentication type, in this case \"serverTrust\".\n   * `host`                       - the host name of the server with which communication for this request is occurring\n   * `protocol`                   - the protocol for which the authentication is occurring\n   * `isProxy`                    - a boolean indicating whether or not the authentication is occurring with a proxy server\n   * `proxyType`                  - a string representing the type of proxy server: http, https, ftp, or socks.\n   * `realm`                      - a string representing the realm name for the authentication.\n   * `certificates` - an array of tables, each table describing a certificate in the SSL certificate chain provided by the server responding to the webview's request.  Each table will contain the following keys:\n     * `commonName` - the common name for the certificate; most commonly this will be a string matching the server portion of the URL request or other descriptor of the certificate's purpose.\n     * `values`     - a table containing key-value pairs describing the certificate.  The keys will be certificate OIDs.  Common OIDs and their meaning can be found in [hs.webview.certificateOIDs](#certificateOIDs). The value for each key will be a table with the following keys:\n       * `label`           - a description or label for the entry\n       * `localized label` - a localized version of `label`\n       * `type`            - a description of the data type for this value\n       * `value`           - the value\n\n * The callback function should return true if an exception should be granted for this certificate or false if it should be rejected.\n\nReturns:\n * The webview object\n\nNotes:\n * even if this callback returns `true`, the certificate will only be granted an exception if [hs.webview:examineInvalidCertificates](#examineInvalidCertificates) has also been set to `true`.\n * once an invalid certificate has been granted an exception, the exception will remain in effect until the webview object is deleted.\n * the callback is only invoked for invalid certificates -- if a certificate is valid, or once an exception has been granted, the callback will not (no longer) be called for that certificate.\n\n* If the certificate has been granted an exception in another application which registers the exception in the user's keychain (e.g. Safari), then the certificate is no longer considered invalid and this callback will not be invoked."
    },
    "Stop loading additional content for the webview.": {
        "prefix": "hs.webview:stopLoading() -> webviewObject",
        "body": "hs.webview:stopLoading()",
        "description": "Stop loading additional content for the webview.\n\nParameters:\n * None\n\nReturns:\n * The webview object\n\nNotes:\n * this method does not stop the loading of the primary content for the page at the specified URL\n * if [hs.webview:loading](#loading) would return true, this method does nothing -- see notes:\n   * The documentation from Apple is unclear and experimentation has shown that if this method is applied before the content of the specified URL has loaded, it can cause the webview to lock up; however it appears to stop the loading of addiional resources specified for the content (external script files, external style files, AJAX queries, etc.) and should be used in this context."
    },
    "Get the title of the page displayed in the webview.": {
        "prefix": "hs.webview:title() -> title",
        "body": "hs.webview:title()",
        "description": "Get the title of the page displayed in the webview.\n\nParameters:\n * None\n\nReturns:\n * the title"
    },
    "Get or set whether or not the title text appears in the webview window.": {
        "prefix": "hs.webview:titleVisibility([state]) -> webviewObject | string",
        "body": "hs.webview:titleVisibility(${1:[state]})",
        "description": "Get or set whether or not the title text appears in the webview window.\n\nParameters:\n * `state` - an optional string containing the text \"visible\" or \"hidden\", specifying whether or not the webview's title text appears when webview's window style includes \"titled\".\n\nReturns:\n * if a value is provided, returns the webview object; otherwise returns the current value.\n\nNotes:\n * See also [hs.webview:windowStyle](#windowStyle) and [hs.webview.windowMasks](#windowMasks).\n\n * When a toolbar is attached to the webview, this function can be used to specify whether the Toolbar appears underneath the webview window's title (\"visible\") or in the window's title bar itself, as seen in applications like Safari (\"hidden\"). When the title is hidden, the toolbar will only display the toolbar items as icons without labels, and ignores changes made with `hs.webview.toolbar:displayMode`.\n\n * If a toolbar is attached to the webview, you can achieve the same effect as this method with `hs.webview:attachedToolbar():inTitleBar(boolean)`"
    },
    "Get or set the top-left coordinate of the webview window": {
        "prefix": "hs.webview:topLeft([point]) -> webviewObject | currentValue",
        "body": "hs.webview:topLeft(${1:[point]})",
        "description": "Get or set the top-left coordinate of the webview window\n\nParameters:\n * `point` - An optional point-table specifying the new coordinate the top-left of the webview window should be moved to\n\nReturns:\n * If an argument is provided, the webview object; otherwise the current value.\n\nNotes:\n * a point-table is a table with key-value pairs specifying the new top-left coordinate on the screen of the webview (keys `x`  and `y`). The table may be crafted by any method which includes these keys, including the use of an `hs.geometry` object."
    },
    "Get or set whether or not the webview background is transparent.  Default is false.": {
        "prefix": "hs.webview:transparent([value]) -> webviewObject | current value",
        "body": "hs.webview:transparent(${1:[value]})",
        "description": "Get or set whether or not the webview background is transparent.  Default is false.\n\nParameters:\n * `value` - an optional boolean value indicating whether or not the webview should be transparent.\n\nReturns:\n * If a value is provided, then this method returns the webview object; otherwise the current value\n\nNotes:\n * When enabled, the webview's background color is equal to the body's `background-color` (transparent by default)\n * Setting `background-color:rgba(0, 225, 0, 0.3)` on `<body>` will give a translucent green webview background"
    },
    "Get or set the URL to render for the webview.": {
        "prefix": "hs.webview:url([URL]) -> webviewObject, navigationIdentifier | url",
        "body": "hs.webview:url(${1:[URL]})",
        "description": "Get or set the URL to render for the webview.\n\nParameters:\n * `URL` - an optional string or table representing the URL to display.  If you provide a table, it should contain one or more of the following keys (note that URL is the only required key):\n   * `URL`                     - the URL of the desired content\n   * `mainDocumentURL`         - the URL of the main document, if it differs.  This usually only matters for cookie negotiation and currently has no effect in this module.\n   * `HTTPBody`                - the message body of the request, as in an HTTP POST request\n   * `HTTPMethod`              - the HTTP Method of the request, default GET.\n   * `timeoutInterval`         - the timeout interval for the request in seconds, default 60.0.\n   * `HTTPShouldHandleCookies` - whether or not cookies should be managed automatically, default true.  Currently there is no support for the manual handling of cookies, though this may change in the future.\n   * `HTTPShouldUsePipelining` - whether or not the request can continue to transmit data before receiving a response from the remote server.  Default false.\n   * `cachePolicy`             - a string value representing the cache policy for the request.  It should match one of the following:\n     * `protocolCachePolicy`     - (default) the cache policy defined as the default for the protocol of the URL request\n     * `ignoreLocalCache`        - ignore any locally cached content and request all content from the remote server\n     * `returnCacheOrLoad`       - return cached data, regardless of its age or expiration date. If there is no existing data in the cache corresponding to the request, load data from the originating source.\n     * `returnCacheDontLoad`     - treat the request as if offline - return cached data, regardless of its age or expiration date. If there is no existing data in the cache corresponding to the request, the load is considered to have failed.\n   * `networkServiceType`      - a string value representing the network service type of the request.  It should match one of the following:\n     * `default`                 - (default) standard network traffic.  You should rarely use a value other than this as it can affect the responsiveness of your computer and other applications.\n     * `VoIP`                    - with the VoIP service type, the kernel continues to listen for incoming traffic while your app is in the background, then wakes up your app whenever new data arrives. This should be used only for connections that are used to communicate with a VoIP service.\n     * `video`                   - specifies that this is video traffic\n     * `background`              - use this for data if your are performing a download that was not requested by the user \u2014 for example, prefetching content so that it will be available when the user chooses to view it.\n     * `voice`                   - specifies that this is voice traffic\n   * `HTTPHeaderFields`        - a table containing key-value pairs corresponding to additional headers you wish to include in your request.  Because the HTTP specification requires that both keys and values are strings, any key which is not a string is ignored, and any value which is not a string or number is also ignored.  In addition, the following keys are handled automatically behind the scenes and will be ignored if you specify them:\n     * `Authorization`\n     * `Connection`\n     * `Host`\n     * `WWW-Authenticate`\n     * `Content-Length`\n\nReturns:\n * If a URL is specified, then this method returns the webview Object; otherwise it returns the current url being displayed.\n\nNotes:\n * The networkServiceType field of the URL request table is a hint to the operating system about what the underlying traffic is used for. This hint enhances the system's ability to prioritize traffic, determine how quickly it needs to wake up the Wi-Fi radio, and so on. By providing accurate information, you improve the ability of the system to optimally balance battery life, performance, and other considerations.  Likewise, inaccurate information can have a deleterious effect on your system performance and battery life."
    },
    "Returns a table of keys containing the individual components of the URL for the webview.": {
        "prefix": "hs.webview:urlParts() -> table",
        "body": "hs.webview:urlParts()",
        "description": "Returns a table of keys containing the individual components of the URL for the webview.\n\nParameters:\n * None\n\nReturns:\n * a table containing the keys for the webview's URL.  See the function `hs.http.urlParts` for a description of the possible keys returned in the table.\n\nNotes:\n * This method is a wrapper to the `hs.http.urlParts` function wich uses the OS X APIs, based on RFC 1808.\n * You may also want to consider the `hs.httpserver.hsminweb.urlParts` function for a version more consistent with RFC 3986."
    },
    "Get or set the webview's user agent string": {
        "prefix": "hs.webview:userAgent([agent]) -> webviewObject | current value",
        "body": "hs.webview:userAgent(${1:[agent]})",
        "description": "Get or set the webview's user agent string\n\nParameters:\n * `agent` - an options string specifying the user agent string to include in all URL requests made by the webview object.\n\nReturns:\n * if a parameter is specified, returns the webviewObject, otherwise returns the current value\n\nNotes:\n * This method is only supported by OS X 10.11 and newer\n\n * The default user string used by webview objects will be something like this (the exact version numbers will differ, depending upon your OS X version):\n  * \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/601.6.17 (KHTML, like Gecko)\"\n * By default, this method will return the empty string (\"\") when queried -- this indicates that the default, shown above, is used.  You can also return to this default by setting the user agent to \"\" with this method (e.g. `hs.webview:userAgent(\"\")`).\n\n * Some web sites tailor content based on the user string or use it for other internal purposes (tracking, statistics, page availability, layout, etc.).  Common user-agent strings can be found at http://www.useragentstring.com/pages/useragentstring.php.\n\n * If you have set the user agent application name with the `applicationName` parameter to the [hs.webview.new](#new) constructor, it will be ignored unless this value is \"\", i.e. the default user agent string.  If you wish to specify an application name after the user agent string and use a custom string, include the application name in your custom string."
    },
    "Set or clear a callback for updates to the webview window": {
        "prefix": "hs.webview:windowCallback(fn) -> webviewObject",
        "body": "hs.webview:windowCallback(${1:fn})",
        "description": "Set or clear a callback for updates to the webview window\n\nParameters:\n * `fn` - the function to be called when the webview window is moved or closed. Specify an explicit nil to clear the current callback.  The function should expect 2 or 3 arguments and return none.  The arguments will be one of the following:\n\n   * \"closing\", webview - specifies that the webview window is being closed, either by the user or with the [hs.webview:delete](#delete) method.\n     * `action`  - in this case \"closing\", specifying that the webview window is being closed\n     * `webview` - the webview that is being closed\n\n   * \"focusChange\", webview, state - indicates that the webview window has either become or stopped being the focused window\n     * `action`  - in this case \"focusChange\", specifying that the webview window is being closed\n     * `webview` - the webview that is being closed\n     * `state`   - a boolean, true if the webview has become the focused window, or false if it has lost focus\n\n   * \"frameChange\", webview, frame - indicates that the webview window has been moved or resized\n     * `action`  - in this case \"focusChange\", specifying that the webview window is being closed\n     * `webview` - the webview that is being closed\n     * `frame`   - a rect-table containing the new co-ordinates and size of the webview window\n\nReturns:\n * The webview object"
    },
    "A table containing valid masks for the webview window.": {
        "prefix": "hs.webview.windowMasks[]",
        "body": "hs.webview.windowMasks",
        "description": "A table containing valid masks for the webview window.\n\nTable Keys:\n * `borderless`             - The window has no border decorations (default)\n * `titled`                 - The window title bar is displayed\n * `closable`               - The window has a close button\n * `miniaturizable`         - The window has a minimize button\n * `resizable`              - The window is resizable\n * `texturedBackground`     - The window has a texturized background\n * `fullSizeContentView`    - If titled, the titlebar is within the frame size specified at creation, not above it.  Shrinks actual content area by the size of the titlebar, if present.\n * `utility`                - If titled, the window shows a utility panel titlebar (thinner than normal)\n * `nonactivating`          - If the window is activated, it won't bring other Hammerspoon windows forward as well\n * `HUD`                    - Requires utility; the window titlebar is shown dark and can only show the close button and title (if they are set)\n\nNotes:\n * The Maximize button in the window title is enabled when Resizable is set.\n * The Close, Minimize, and Maximize buttons are only visible when the Window is also Titled."
    },
    "Get or set the window display style": {
        "prefix": "hs.webview:windowStyle(mask) -> webviewObject | currentMask",
        "body": "hs.webview:windowStyle(${1:mask})",
        "description": "Get or set the window display style\n\nParameters:\n * mask - if present, this mask should be a combination of values found in `hs.webview.windowMasks` describing the window style.  The mask should be provided as one of the following:\n   * integer - a number representing the style which can be created by combining values found in `hs.webview.windowMasks` with the logical or operator.\n   * string  - a single key from `hs.webview.windowMasks` which will be toggled in the current window style.\n   * table   - a list of keys from `hs.webview.windowMasks` which will be combined to make the final style by combining their values with the logical or operator.\n\nReturns:\n * if a mask is provided, then the webviewObject is returned; otherwise the current mask value is returned."
    },
    "Sets the title for the webview window.": {
        "prefix": "hs.webview:windowTitle([title]) -> webviewObject",
        "body": "hs.webview:windowTitle(${1:[title]})",
        "description": "Sets the title for the webview window.\n\nParameters:\n * `title` - if specified and not nil, the title to set for the webview window.  If this parameter is not present or is nil, the title will follow the title of the webview's content.\n\nReturns:\n * The webview Object\n\nNotes:\n * The title will be hidden unless the window style includes the \"titled\" style (see `hs.webview.windowStyle` and `hs.webview.windowMasks`)"
    },
    "Returns an object representing the default datastore for Hammerspoon `hs.webview` instances.": {
        "prefix": "hs.webview.datastore.default() -> datastoreObject",
        "body": "hs.webview.datastore.default()",
        "description": "Returns an object representing the default datastore for Hammerspoon `hs.webview` instances.\n\nParameters:\n * None\n\nReturns:\n * a datastoreObject\n\nNotes:\n * this is the datastore used unless otherwise specified when creating an `hs.webview` instance."
    },
    "Generates a list of the datastore records of the specified type, and invokes the callback function with the list.": {
        "prefix": "hs.webview.datastore:fetchRecords([dataTypes], callback) -> datastoreObject",
        "body": "hs.webview.datastore:fetchRecords(${1:[dataTypes]}, ${2:callback})",
        "description": "Generates a list of the datastore records of the specified type, and invokes the callback function with the list.\n\nParameters:\n * `dataTypes` - an optional string or table specifying the data types to fetch from the datastore.  If this parameter is not specified, it defaults to the list returned by [hs.webview.datastore.websiteDataTypes](#websiteDataTypes).\n * `callback`  - a function which accepts as it's argument an array-table containing tables with the following key-value pairs:\n   * `displayName` - a string containing the site's display name.  Typically, the display name is the domain name with suffix taken from the resource\u2019s security origin (website name).\n   * `dataTypes`   - a table containing strings representing the types of data stored for the website specified by `displayName`.\n\nReturns:\n * the datastore object\n\nNotes:\n * only those sites with one or more of the specified data types are returned\n * for the sites returned, only those data types that were present in the query will be included in the list, even if the site has data of another type in the datastore."
    },
    "Returns an object representing the datastore for the specified `hs.webview` instance.": {
        "prefix": "hs.webview.datastore.fromWebview(webview) -> datastoreObject",
        "body": "hs.${1:webview}.datastore.fromWebview(webview)",
        "description": "Returns an object representing the datastore for the specified `hs.webview` instance.\n\nParameters:\n * `webview` - an `hs.webview` instance (webviewObject)\n\nReturns:\n * a datastoreObject\n\nNotes:\n * When running on a system with OS X 10.11 or later, this method will also be added to the metatable for `hs.webview` objects so that you can retrieve a webview's datastore with `hs.webview:datastore()`.\n\n * This method can be used to identify the datastore in use for a webview if you wish to create a new instance using the same datastore."
    },
    "Returns an object representing a newly created non-persistent (private) datastore for use with a Hammerspoon `hs.webview` instance.": {
        "prefix": "hs.webview.datastore.newPrivate() -> datastoreObject",
        "body": "hs.webview.datastore.newPrivate()",
        "description": "Returns an object representing a newly created non-persistent (private) datastore for use with a Hammerspoon `hs.webview` instance.\n\nParameters:\n * None\n\nReturns:\n * a datastoreObject\n\nNotes:\n * The datastore represented by this object will be initially empty.  You can use this function to create a non-persistent datastore that you wish to share among multiple `hs.webview` instances.  Once a datastore is created, you assign it to a `hs.webview` instance by including the `datastore` key in the `hs.webvew.new` constructor's preferences table and setting it equal to this key.  All webview instances created with this datastore object will share web caches, cookies, etc. but will still be isolated from the default datastore and it will be purged from memory when the webviews are deleted, or Hammerspoon is restarted.\n\n * Using the `datastore` key in the webview's constructor differs from the `private` key -- use of the `private` key will override the `datastore` key and will create a separate non-persistent datastore for the webview instance.  See `hs.webview.new` for more information."
    },
    "Returns whether or not the datastore is persistent.": {
        "prefix": "hs.webview.datastore:persistent() -> bool",
        "body": "hs.webview.datastore:persistent()",
        "description": "Returns whether or not the datastore is persistent.\n\nParameters:\n * None\n\nReturns:\n * a boolean value indicating whether or not the datastore is persistent (true) or private (false)\n\nNotes:\n * Note that this value is the inverse of `hs.webview:privateBrowsing()`, since private browsing uses a non-persistent datastore."
    },
    "Removes the specified types of data from the datastore if the data was added or changed since the given date.": {
        "prefix": "hs.webview.datastore:removeRecordsAfter(date, dataTypes, [callback]) -> datastoreObject",
        "body": "hs.webview.datastore:removeRecordsAfter(${1:date}, ${2:dataTypes}, ${3:[callback]})",
        "description": "Removes the specified types of data from the datastore if the data was added or changed since the given date.\n\nParameters:\n * `date`         - an integer representing seconds since `1970-01-01 00:00:00 +0000` (e.g. `os.time()`), or a string containing a date in RFC3339 format (`YYYY-MM-DD[T]HH:MM:SS[Z]`).\n * `dataTypes`    - a string or array of strings specifying the types of data to remove from the datastore for the specified sites.\n * `callback`     - an optional function, which should expect no arguments, that will be called when the specified items have been removed from the datastore.\n\nReturns:\n * the datastore object\n\nNotes:\n * Yes, you read the description correctly -- removes data *newer* then the date specified.  I've not yet found a way to remove data *older* then the date specified (to expire old data, for example) but updates or suggestions are welcome in the Hammerspoon Google group or Github web site.\n\n * to specify that all data types that qualify should be removed, specify the function  [hs.webview.datastore.websiteDataTypes()](#websiteDataTypes). as the second argument.\n\n * For example, to purge the Hammerspoon default datastore of all data, you can do the following:\n~~~\nhs.webview.datastore.default():removeRecordsAfter(0, hs.webview.datastore.websiteDataTypes())\n~~~"
    },
    "Remove data from the datastore of the specified type(s) for the specified site(s).": {
        "prefix": "hs.webview.datastore:removeRecordsFor(displayNames, dataTypes, [callback]) -> datastoreObject",
        "body": "hs.webview.datastore:removeRecordsFor(${1:displayNames}, ${2:dataTypes}, ${3:[callback]})",
        "description": "Remove data from the datastore of the specified type(s) for the specified site(s).\n\nParameters:\n * `displayNames` - a string or array of strings specifying the display names (sites) to remove records for.\n * `dataTypes`    - a string or array of strings specifying the types of data to remove from the datastore for the specified sites.\n * `callback`     - an optional function, which should expect no arguments, that will be called when the specified items have been removed from the datastore.\n\nReturns:\n * the datastore object\n\nNotes:\n * to specify that all data types that qualify should be removed, specify the function  [hs.webview.datastore.websiteDataTypes()](#websiteDataTypes). as the second argument."
    },
    "Returns a list of the currently available data types within a datastore.": {
        "prefix": "hs.webview.datastore.websiteDataTypes() -> table",
        "body": "hs.webview.datastore.websiteDataTypes()",
        "description": "Returns a list of the currently available data types within a datastore.\n\nParameters:\n * None\n\nReturns:\n * a list of strings where each string is a specific data type stored in a datastore.\n\nNotes:\n * As of the writing of this module, the following data types are defined and returned by this function:\n   * `WKWebsiteDataTypeDiskCache`                  - On-disk caches.\n   * `WKWebsiteDataTypeOfflineWebApplicationCache` - HTML offline web application caches.\n   * `WKWebsiteDataTypeMemoryCache`                - In-memory caches.\n   * `WKWebsiteDataTypeLocalStorage`               - HTML local storage.\n   * `WKWebsiteDataTypeCookies`                    - Cookies.\n   * `WKWebsiteDataTypeSessionStorage`             - HTML session storage.\n   * `WKWebsiteDataTypeIndexedDBDatabases`         - WebSQL databases.\n   * `WKWebsiteDataTypeWebSQLDatabases`            - IndexedDB databases."
    },
    "Add one or more toolbar items to the toolbar": {
        "prefix": "hs.webview.toolbar:addItems(toolbarTable) -> toolbarObject",
        "body": "hs.webview.toolbar:addItems(${1:toolbarTable})",
        "description": "Add one or more toolbar items to the toolbar\n\nParameters:\n * `toolbarTable` - a table describing a single toolbar item, or an array of tables, each describing a separate toolbar item, to be added to the toolbar.\n\nReturns:\n * the toolbarObject\n\nNotes:\n* Each toolbar item is defined as a table of key-value pairs.  The following list describes the valid keys used when describing a toolbar item for this method, the constructor [hs.webview.toolbar.new](#new), and the [hs.webview.toolbar:modifyItem](#modifyItem) method.  Note that the `id` field is **required** for all three uses.\n  * `id`           - A unique string identifier required for each toolbar item and group.  This key cannot be changed after an item has been created.\n  * `allowedAlone` - a boolean value, default true, specifying whether or not the toolbar item can be added to the toolbar, programmatically or through the customization panel, (true) or whether it can only be added as a member of a group (false).\n  * `default`      - a boolean value, default matching the value of `allowedAlone` for this item, indicating whether or not this toolbar item or group should be displayed in the toolbar by default, unless overridden by user customization or a saved configuration (when such options are enabled).\n  * `enable`       - a boolean value, default true, indicating whether or not the toolbar item is active (and can be clicked on) or inactive and greyed out.  This field is ignored when applied to a toolbar group; apply it to the group members instead.\n  * `fn`           - a callback function, or false to remove, specific to the toolbar item. This property is ignored if assigned to the button group. This function will override the toolbar callback defined with [hs.webview.toolbar:setCallback](#setCallback) for this specific item. The function should expect three (four, if the item is a `searchfield`) arguments and return none.  See [hs.webview.toolbar:setCallback](#setCallback) for information about the callback's arguments.\n  * `groupMembers` - an array (table) of strings specifying the toolbar item ids that are members of this toolbar item group.  If set to false, this field is removed and the item is reset back to being a regular toolbar item.  Note that you cannot change a currently visible toolbar item to or from being a group; it must first be removed from active toolbar with [hs.webview.toolbar:removeItem](#removeItem).\n  * `image`        - an `hs.image` object, or false to remove, specifying the image to use as the toolbar item's icon when icon's are displayed in the toolbar or customization panel. This key is ignored for a toolbar item group, but not for it's individual members.\n  * `label`        - a string label, or false to remove, for the toolbar item or group when text is displayed in the toolbar or in the customization panel. For a toolbar item, the default is the `id` string; for a group, the default is `false`. If a group has a label assigned to it, the group label will be displayed for the group of items it contains. If a group does not have a label, the individual items which make up the group will each display their individual labels.\n  * `priority`     - an integer value used to determine toolbar item order and which items are displayed or put into the overflow menu when the number of items in the toolbar exceed the width of the window in which the toolbar is attached. Some example values are provided in the [hs.webview.toolbar.itemPriorities](#itemPriorities) table. If a toolbar item is in a group, it's priority is ignored and the item group is ordered by the item group's priority.\n  * `searchfield`  - a boolean (default false) specifying whether or not this toolbar item is a search field. If true, the following additional keys are allowed:\n    * `searchHistory`                - an array (table) of strings, specifying previous searches to automatically include in the search field menu, if `searchPredefinedMenuTitle` is not false\n    * `searchHistoryAutosaveName`    - a string specifying the key name to save search history with in the application deafults (accessible through `hs.settings`). If this value is set, search history will be maintained through restarts of Hammerspoon.\n    * `searchHistoryLimit`           - the maximum number of items to store in the search field history.\n    * `searchPredefinedMenuTitle`    - a string or boolean specifying how a predefined list of search field \"response\" should be included in the search field menu. If this item is `true`, this list of items specified for `searchPredefinedSearches` will be displayed in a submenu with the title \"Predefined Searches\". If this item is a string, the list of items will be displayed in a submenu with the title specified by this string value. If this item is `false`, then the search field menu will only contain the items specified in `searchPredefinedSearches` and no search history will be included in the menu.\n    * `searchPredefinedSearches`     - an array (table) of strings specifying the items to be listed in the predefined search submenu. If set to false, any existing menu will be removed and the search field menu will be reset to the default.\n    * `searchReleaseFocusOnCallback` - a boolean, default false, specifying whether or not focus leaves the search field text box when the callback is invoked. Setting this to true can be useful if you want subsequent keypresses to be caught by the webview after reacting to the value entered into the search field by the user.\n    * `searchText`                   - a string specifying the text to display in the search field.\n    * `searchWidth`                  - the width of the search field text entry box.\n  * `selectable`   - a boolean value, default false, indicating whether or not this toolbar item is selectable (i.e. highlights, like a selected tab) when clicked on. Only one selectable toolbar item can be highlighted at a time, and you can get or set/reset the selected item with [hs.webview.toolbar:selectedItem](#selectedItem).\n  * `tag`          - an integer value which can be used for own purposes; has no affect on the visual aspect of the item or its behavior.\n  * `tooltip`      - a string label, or false to remove, which is displayed as a tool tip when the user hovers the mouse over the button or button group. If a button is in a group, it's tooltip is ignored in favor of the group tooltip."
    },
    "Returns an array of all toolbar item identifiers defined for this toolbar.": {
        "prefix": "hs.webview.toolbar:allowedItems() -> array",
        "body": "hs.webview.toolbar:allowedItems()",
        "description": "Returns an array of all toolbar item identifiers defined for this toolbar.\n\nParameters:\n * None\n\nReturns:\n * a table as an array of all toolbar item identifiers defined for this toolbar.  See also [hs.webview.toolbar:items](#items) and [hs.webview.toolbar:visibleItems](#visibleItems)."
    },
    "Get or attach/detach a toolbar to the webview, chooser, or console.": {
        "prefix": "hs.webview.toolbar.attachToolbar([obj1], [obj2]) -> obj1",
        "body": "hs.webview.toolbar.attachToolbar(${1:[obj1]}, ${2:[obj2]})",
        "description": "Get or attach/detach a toolbar to the webview, chooser, or console.\n\nParameters:\n * if no arguments are present, this function returns the current toolbarObject for the Hammerspoon console, or nil if one is not attached.\n * if one argument is provided and it is a toolbarObject or nil, this function will attach or detach a toolbarObject to/from the Hammerspoon console.\n * if one argument is provided and it is an hs.webview or hs.chooser object, this function will return the current toolbarObject for the object, or nil if one is not attached.\n * if two arguments are provided and the first is an hs.webview or hs.chooser object and the second is a toolbarObject or nil, this function will attach or detach a toolbarObject to/from the object.\n\nReturns:\n * if the function is used to attach/detach a toolbar, then the first object provided (the target) will be returned ; if this function is used to get the current toolbar object for a webview, chooser, or console, then the toolbarObject or nil will be returned.\n\nNotes:\n * This function is not expected to be used directly (though it can be) -- it is added to the `hs.webview` and `hs.chooser` object metatables so that it may be invoked as `hs.webview:attachedToolbar([toolbarObject | nil])`/`hs.chooser:attachedToolbar([toolbarObject | nil])` and to the `hs.console` module so that it may be invoked as `hs.console.toolbar([toolbarObject | nil])`.\n\n * If the toolbar is currently attached to another window when this function is called, it will be detached from the original window and attached to the new one specified by this function."
    },
    "Get or set whether or not the toolbar autosaves changes made to the toolbar.": {
        "prefix": "hs.webview.toolbar:autosaves([bool]) -> toolbarObject | bool",
        "body": "hs.webview.toolbar:autosaves(${1:[bool]})",
        "description": "Get or set whether or not the toolbar autosaves changes made to the toolbar.\n\nParameters:\n * an optional boolean value indicating whether or not changes made to the visible toolbar items or their order is automatically saved.\n\nReturns:\n * if an argument is provided, returns the toolbar object; otherwise returns the current value\n\nNotes:\n * If the toolbar is set to autosave, then a user-defaults entry is created in org.hammerspoon.Hammerspoon domain with the key \"NSToolbar Configuration XXX\" where XXX is the toolbar identifier specified when the toolbar was created.\n * The information saved for the toolbar consists of the following:\n   * the default item identifiers that are displayed when the toolbar is first created or when the user drags the default set from the customization panel.\n   * the current display mode (icon, text, both)\n   * the current size mode (regular, small)\n   * whether or not the toolbar is currently visible\n   * the currently shown identifiers and their order\n* Note that the labels, icons, callback functions, etc. are not saved -- these are determined at toolbar creation time, by the [hs.webview.toolbar:addItems](#addItems), or by the [hs.webview.toolbar:modifyItem](#modifyItem) method and can differ between invocations of toolbars with the same identifier and button identifiers."
    },
    "Get or set whether or not the user is allowed to customize the toolbar with the Customization Panel.": {
        "prefix": "hs.webview.toolbar:canCustomize([bool]) -> toolbarObject | bool",
        "body": "hs.webview.toolbar:canCustomize(${1:[bool]})",
        "description": "Get or set whether or not the user is allowed to customize the toolbar with the Customization Panel.\n\nParameters:\n * an optional boolean value indicating whether or not the user is allowed to customize the toolbar.\n\nReturns:\n * if an argument is provided, returns the toolbar object; otherwise returns the current value\n\nNotes:\n * the customization panel can be pulled up by right-clicking on the toolbar or by invoking [hs.webview.toolbar:customizePanel](#customizePanel)."
    },
    "Returns a copy of the toolbar object.": {
        "prefix": "hs.webview.toolbar:copy() -> toolbarObject",
        "body": "hs.webview.toolbar:copy()",
        "description": "Returns a copy of the toolbar object.\n\nParameters:\n * None\n\nReturns:\n * a copy of the toolbar which can be attached to another window (webview, chooser, or console)."
    },
    "Opens the toolbar customization panel.": {
        "prefix": "hs.webview.toolbar:customizePanel() -> toolbarObject",
        "body": "hs.webview.toolbar:customizePanel()",
        "description": "Opens the toolbar customization panel.\n\nParameters:\n * None\n\nReturns:\n * the toolbar object"
    },
    "Deletes the toolbar, removing it from its window if it is currently attached.": {
        "prefix": "hs.webview.toolbar:delete() -> none",
        "body": "hs.webview.toolbar:delete()",
        "description": "Deletes the toolbar, removing it from its window if it is currently attached.\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Deletes the toolbar item specified completely from the toolbar, removing it first, if the toolbar item is currently active.": {
        "prefix": "hs.webview.toolbar:deleteItem(identifier) -> toolbarObject",
        "body": "hs.webview.toolbar:deleteItem(${1:identifier})",
        "description": "Deletes the toolbar item specified completely from the toolbar, removing it first, if the toolbar item is currently active.\n\nParameters:\n * `identifier` - the toolbar item's identifier\n\nReturns:\n * the toolbar object\n\nNotes:\n * This method completely removes the toolbar item from the toolbar's definition dictionary, thus removing it from active use in the toolbar as well as removing it from the customization panel, if supported.  If you only want to remove a toolbar item from the active toolbar, consider [hs.webview.toolbar:removeItem](#removeItem)."
    },
    "Get or set the toolbar's display mode.": {
        "prefix": "hs.webview.toolbar:displayMode([mode]) -> toolbarObject",
        "body": "hs.webview.toolbar:displayMode(${1:[mode]})",
        "description": "Get or set the toolbar's display mode.\n\nParameters:\n * mode - an optional string to set the size of the toolbar to \"default\", \"label\", \"icon\", or \"both\".\n\nReturns:\n * if an argument is provided, returns the toolbar object; otherwise returns the current value"
    },
    "The identifier for this toolbar.": {
        "prefix": "hs.webview.toolbar:identifier() -> identifier",
        "body": "hs.webview.toolbar:identifier()",
        "description": "The identifier for this toolbar.\n\nParameters:\n * None\n\nReturns:\n * The identifier for this toolbar."
    },
    "Insert or move the toolbar item to the index position specified": {
        "prefix": "hs.webview.toolbar:insertItem(id, index) -> toolbarObject",
        "body": "hs.webview.toolbar:insertItem(${1:id}, ${2:index})",
        "description": "Insert or move the toolbar item to the index position specified\n\nParameters:\n * id    - the string identifier of the toolbar item\n * index - the numerical position where the toolbar item should be inserted/moved to.\n\nReturns:\n * the toolbar object\n\nNotes:\n * the toolbar position must be between 1 and the number of currently active toolbar items."
    },
    "Get or set whether or not the toolbar appears in the containing window's titlebar, similar to Safari.": {
        "prefix": "hs.webview.toolbar:inTitleBar([state]) -> toolbarObject | boolean",
        "body": "hs.webview.toolbar:inTitleBar(${1:[state]})",
        "description": "Get or set whether or not the toolbar appears in the containing window's titlebar, similar to Safari.\n\nParameters:\n * `state` - an optional boolean specifying whether or not the toolbar should appear in the window's titlebar.\n\nReturns:\n * if a parameter is specified, returns the toolbar object, otherwise the current value.\n\nNotes:\n * When this value is true, the toolbar, when visible, will appear in the window's title bar similar to the toolbar as seen in applications like Safari.  In this state, the toolbar will set the display of the toolbar items to icons without labels, ignoring changes made with [hs.webview.toolbar:displayMode](#displayMode).\n\n* This method is only valid when the toolbar is attached to a webview, chooser, or the console."
    },
    "Returns a boolean indicating whether or not the toolbar is currently attached to a window.": {
        "prefix": "hs.webview.toolbar:isAttached() -> boolean",
        "body": "hs.webview.toolbar:isAttached()",
        "description": "Returns a boolean indicating whether or not the toolbar is currently attached to a window.\n\nParameters:\n * None\n\nReturns:\n * a boolean indicating whether or not the toolbar is currently attached to a window."
    },
    "Indicates whether or not the customization panel is currently open for the toolbar.": {
        "prefix": "hs.webview.toolbar:isCustomizing() -> bool",
        "body": "hs.webview.toolbar:isCustomizing()",
        "description": "Indicates whether or not the customization panel is currently open for the toolbar.\n\nParameters:\n * None\n\nReturns:\n * true or false indicating whether or not the customization panel is open for the toolbar"
    },
    "Returns a table containing details about the specified toolbar item": {
        "prefix": "hs.webview.toolbar:itemDetails(id) -> table",
        "body": "hs.webview.toolbar:itemDetails(${1:id})",
        "description": "Returns a table containing details about the specified toolbar item\n\nParameters:\n * id - a string identifier specifying the toolbar item\n\nReturns:\n * a table containing the toolbar item definition\n\nNotes:\n * For a list of the most of the possible toolbar item attribute keys, see [hs.webview.toolbar:addItems](#addItems).\n * The table will also include `privateCallback` which will be a boolean indicating whether or not this toolbar item has a private callback function assigned (true) or uses the toolbar's general callback function (false).\n * The returned table may also contain the following keys, if the item is currently assigned to a toolbar:\n   * `toolbar`  - the toolbar object the item belongs to\n   * `subItems` - if the toolbar item is actually a group, this will contain a table with basic information about the members of the group.  If you wish to get the full details for each sub-member, you may iterate on the identifiers provided in `groupMembers`."
    },
    "A table containing some pre-defined toolbar item priority values for use when determining item order in the toolbar.": {
        "prefix": "hs.webview.toolbar.itemPriorities",
        "body": "hs.webview.toolbar.itemPriorities",
        "description": "A table containing some pre-defined toolbar item priority values for use when determining item order in the toolbar.\n\nDefined keys are:\n * standard - the default priority for an item which does not set or change its priority\n * low      - a low priority value\n * high     - a high priority value\n * user     - the priority of an item which the user has added or moved with the customization panel"
    },
    "Returns an array of the toolbar item identifiers currently assigned to the toolbar.": {
        "prefix": "hs.webview.toolbar:items() -> array",
        "body": "hs.webview.toolbar:items()",
        "description": "Returns an array of the toolbar item identifiers currently assigned to the toolbar.\n\nParameters:\n * None\n\nReturns:\n * a table as an array of the currently active (assigned) toolbar item identifiers.  Toolbar items which are in the overflow menu *are* included in this array.  See also [hs.webview.toolbar:visibleItems](#visibleItems) and [hs.webview.toolbar:allowedItems](#allowedItems)."
    },
    "Modify the toolbar item specified by the \"id\" key in the table argument.": {
        "prefix": "hs.webview.toolbar:modifyItem(table) -> toolbarObject",
        "body": "hs.webview.toolbar:modifyItem(${1:table})",
        "description": "Modify the toolbar item specified by the \"id\" key in the table argument.\n\nParameters:\n * a table containing an \"id\" key and the attributes to change for the toolbar item.\n\nReturns:\n * the toolbarObject\n\nNotes:\n * You cannot change a toolbar item's `id`\n * For a list of the possible toolbar item attribute keys, see [hs.webview.toolbar:addItems](#addItems)."
    },
    "Creates a new toolbar for a webview, chooser, or the console.": {
        "prefix": "hs.webview.toolbar.new(toolbarName, [toolbarTable]) -> toolbarObject",
        "body": "hs.webview.toolbar.new(${1:toolbarName}, ${2:[toolbarTable]})",
        "description": "Creates a new toolbar for a webview, chooser, or the console.\n\nParameters:\n * toolbarName  - a string specifying the name for this toolbar\n * toolbarTable - an optional table describing possible items for the toolbar\n\nReturns:\n * a toolbarObject\n\nNotes:\n * Toolbar names must be unique, but a toolbar may be copied with [hs.webview.toolbar:copy](#copy) if you wish to attach it to multiple windows (webview, chooser, or console).\n * See [hs.webview.toolbar:addItems](#addItems) for a description of the format for `toolbarTable`"
    },
    "Get or set whether or not the global callback function is invoked when a toolbar item is added or removed from the toolbar.": {
        "prefix": "hs.webview.toolbar:notifyOnChange([bool]) -> toolbarObject | bool",
        "body": "hs.webview.toolbar:notifyOnChange(${1:[bool]})",
        "description": "Get or set whether or not the global callback function is invoked when a toolbar item is added or removed from the toolbar.\n\nParameters:\n * an optional boolean value to enable or disable invoking the global callback for toolbar changes.\n\nReturns:\n * if an argument is provided, returns the toolbar object; otherwise returns the current value"
    },
    "Remove the toolbar item at the index position specified, or with the specified identifier, if currently present in the toolbar.": {
        "prefix": "hs.webview.toolbar:removeItem(index | identifier) -> toolbarObject",
        "body": "hs.webview.toolbar:removeItem(${1:index | identifier})",
        "description": "Remove the toolbar item at the index position specified, or with the specified identifier, if currently present in the toolbar.\n\nParameters:\n * `index` - the numerical position of the toolbar item to remove.\n     or\n * `identifier` - the identifier of the toolbar item to remove, if currently active in the toolbar\n\nReturns:\n * the toolbar object\n\nNotes:\n * the toolbar position must be between 1 and the number of currently active toolbar items."
    },
    "Returns a table containing the settings which will be saved for the toolbar if [hs.webview.toolbar:autosaves](#autosaves) is true.": {
        "prefix": "hs.webview.toolbar:savedSettings() -> table",
        "body": "hs.webview.toolbar:savedSettings()",
        "description": "Returns a table containing the settings which will be saved for the toolbar if [hs.webview.toolbar:autosaves](#autosaves) is true.\n\nParameters:\n * None\n\nReturns:\n * a table containing the toolbar settings\n\nNotes:\n * If the toolbar is set to autosave, then a user-defaults entry is created in org.hammerspoon.Hammerspoon domain with the key \"NSToolbar Configuration XXX\" where XXX is the toolbar identifier specified when the toolbar was created.\n * This method is provided if you do not wish for changes to the toolbar to be autosaved for every change, but may wish to save it programmatically under specific conditions."
    },
    "Get or set the selected toolbar item": {
        "prefix": "hs.webview.toolbar:selectedItem([item]) -> toolbarObject | item",
        "body": "hs.webview.toolbar:selectedItem(${1:[item]})",
        "description": "Get or set the selected toolbar item\n\nParameters:\n * item - an optional id for the toolbar item to show as selected, or an explicit nil if you wish for no toolbar item to be selected.\n\nReturns:\n * if an argument is provided, returns the toolbar object; otherwise returns the current value\n\nNotes:\n * Only toolbar items which were defined as `selectable` when created with [hs.webview.toolbar.new](#new) can be selected with this method."
    },
    "Programmatically focus the search field for keyboard input.": {
        "prefix": "hs.webview.toolbar:selectSearchField([identifier]) -> toolbarObject | false",
        "body": "hs.webview.toolbar:selectSearchField(${1:[identifier]})",
        "description": "Programmatically focus the search field for keyboard input.\n\nParameters:\n * identifier - an optional string specifying the id of the specific search field to focus.  If this parameter is not provided, this method attempts to focus the first active searchfield found in the toolbar\n\nReturns:\n * if the searchfield can be found and is currently in the toolbar, returns the toolbarObject; otherwise returns false.\n\nNotes:\n * if there is current text in the searchfield, it will be selected so that any subsequent typing by the user will replace the current value in the searchfield."
    },
    "Get or set whether or not the toolbar shows a separator between the toolbar and the main window contents.": {
        "prefix": "hs.webview.toolbar:separator([bool]) -> toolbarObject | bool",
        "body": "hs.webview.toolbar:separator(${1:[bool]})",
        "description": "Get or set whether or not the toolbar shows a separator between the toolbar and the main window contents.\n\nParameters:\n * an optional boolean value to enable or disable the separator.\n\nReturns:\n * if an argument is provided, returns the toolbar object; otherwise returns the current value"
    },
    "Sets or removes the global callback function for the toolbar.": {
        "prefix": "hs.webview.toolbar:setCallback(fn | nil) -> toolbarObject",
        "body": "hs.webview.toolbar:setCallback(${1:fn | nil})",
        "description": "Sets or removes the global callback function for the toolbar.\n\nParameters:\n * fn - a function to set as the global callback for the toolbar, or nil to remove the global callback.\n\n The function should expect three (four, if the item is a `searchfield` or `notifyOnChange` is true) arguments and return none: the toolbar object, \"console\" or the webview/chooser object the toolbar is attached to, and the toolbar item identifier that was clicked.\nReturns:\n * the toolbar object.\n\nNotes:\n * the global callback function is invoked for a toolbar button item that does not have a specific function assigned directly to it.\n * if [hs.webview.toolbar:notifyOnChange](#notifyOnChange) is set to true, then this callback function will also be invoked when a toolbar item is added or removed from the toolbar either programmatically with [hs.webview.toolbar:insertItem](#insertItem) and [hs.webview.toolbar:removeItem](#removeItem) or under user control with [hs.webview.toolbar:customizePanel](#customizePanel) and the callback function will receive a string of \"add\" or \"remove\" as a fourth argument."
    },
    "Get or set the toolbar's size.": {
        "prefix": "hs.webview.toolbar:sizeMode([size]) -> toolbarObject",
        "body": "hs.webview.toolbar:sizeMode(${1:[size]})",
        "description": "Get or set the toolbar's size.\n\nParameters:\n * size - an optional string to set the size of the toolbar to \"default\", \"regular\", or \"small\".\n\nReturns:\n * if an argument is provided, returns the toolbar object; otherwise returns the current value"
    },
    "An array containing string identifiers for supported system defined toolbar items.": {
        "prefix": "hs.webview.toolbar.systemToolbarItems",
        "body": "hs.webview.toolbar.systemToolbarItems",
        "description": "An array containing string identifiers for supported system defined toolbar items.\n\nCurrently supported identifiers include:\n * NSToolbarSpaceItem         - represents a space approximately the size of a toolbar item\n * NSToolbarFlexibleSpaceItem - represents a space that stretches to fill available space in the toolbar"
    },
    "Checks to see is a toolbar name is already in use": {
        "prefix": "hs.webview.toolbar.uniqueName(toolbarName) -> boolean",
        "body": "hs.webview.toolbar.uniqueName(${1:toolbarName})",
        "description": "Checks to see is a toolbar name is already in use\n\nParameters:\n * toolbarName  - a string specifying the name of a toolbar\n\nReturns:\n * `true` if the name is unique otherwise `false`"
    },
    "Get or set whether or not the toolbar is currently visible in the window it is attached to.": {
        "prefix": "hs.webview.toolbar:visible([bool]) -> toolbarObject | bool",
        "body": "hs.webview.toolbar:visible(${1:[bool]})",
        "description": "Get or set whether or not the toolbar is currently visible in the window it is attached to.\n\nParameters:\n * an optional boolean value to show or hide the toolbar.\n\nReturns:\n * if an argument is provided, returns the toolbar object; otherwise returns the current value"
    },
    "Returns an array of the currently visible toolbar item identifiers.": {
        "prefix": "hs.webview.toolbar:visibleItems() -> array",
        "body": "hs.webview.toolbar:visibleItems()",
        "description": "Returns an array of the currently visible toolbar item identifiers.\n\nParameters:\n * None\n\nReturns:\n * a table as an array of the currently visible toolbar item identifiers.  Toolbar items which are in the overflow menu are *not* included in this array.  See also [hs.webview.toolbar:items](#items) and [hs.webview.toolbar:allowedItems](#allowedItems)."
    },
    "Add a script to be injected into webviews which use this user content controller.": {
        "prefix": "hs.webview.usercontent:injectScript(scriptTable) -> usercontentControllerObject",
        "body": "hs.webview.usercontent:injectScript(${1:scriptTable})",
        "description": "Add a script to be injected into webviews which use this user content controller.\n\nParameters:\n * scriptTable - a table containing the following keys which define the script and how it is to be injected:\n   * source        - the javascript which is injected (required)\n   * mainFrame     - a boolean value which indicates whether this script is only injected for the main webview frame (true) or for all frames within the webview (false).  Defaults to true.\n   * injectionTime - a string which indicates whether the script is injected at \"documentStart\" or \"documentEnd\". Defaults to \"documentStart\".\n\nReturns:\n * the usercontentControllerObject or nil if the script table was malformed in some way."
    },
    "Create a new user content controller for a webview and create the message port with the specified name for JavaScript message support.": {
        "prefix": "hs.webview.usercontent.new(name) -> usercontentControllerObject",
        "body": "hs.webview.usercontent.new(${1:name})",
        "description": "Create a new user content controller for a webview and create the message port with the specified name for JavaScript message support.\n\nParameters:\n * name - the name of the message port which JavaScript in the webview can use to post messages to Hammerspoon.\n\nReturns:\n * the usercontentControllerObject\n\nNotes:\n * This object should be provided as the final argument to the `hs.webview.new` constructor in order to tie the webview to this content controller.  All new windows which are created from this parent webview will also use this controller.\n * See `hs.webview.usercontent:setCallback` for more information about the message port."
    },
    "Removes all user scripts currently defined for this user content controller.": {
        "prefix": "hs.webview.usercontent:removeAllScripts() -> usercontentControllerObject",
        "body": "hs.webview.usercontent:removeAllScripts()",
        "description": "Removes all user scripts currently defined for this user content controller.\n\nParameters:\n * None\n\nReturns:\n * the usercontentControllerObject\nNotes:\n * The WKUserContentController class only allows for removing all scripts.  If you need finer control, make a copy of the current scripts with `hs.webview.usercontent.userScripts()` first so you can recreate the scripts you want to keep."
    },
    "Set or remove the callback function to handle message posted to this user content's message port.": {
        "prefix": "hs.webview.usercontent:setCallback(fn) -> usercontentControllerObject",
        "body": "hs.webview.usercontent:setCallback(${1:fn})",
        "description": "Set or remove the callback function to handle message posted to this user content's message port.\n\nParameters:\n * fn - The function which should receive messages posted to this user content's message port.  Specify an explicit nil to disable the callback.  The function should take one argument which will be the message posted and any returned value will be ignored.\n\nReturns:\n * the usercontentControllerObject\n\nNotes:\n * Within your (injected or served) JavaScript, you can post messages via the message port created with the constructor like this:\n\n     try {\n         webkit.messageHandlers.*name*>.postMessage(*message-object*);\n     } catch(err) {\n         console.log('The controller does not exist yet');\n     }\n\n * Where *name* matches the name specified in the constructor and *message-object* is the object to post to the function.  This object can be a number, string, date, array, dictionary(table), or nil."
    },
    "Get a table containing all of the currently defined injection scripts for this user content controller": {
        "prefix": "hs.webview.usercontent:userScripts() -> array",
        "body": "hs.webview.usercontent:userScripts()",
        "description": "Get a table containing all of the currently defined injection scripts for this user content controller\n\nParameters:\n * None\n\nReturns:\n * An array of injected user scripts.  Each entry in the array will be a table containing the following keys:\n   * source        - the javascript which is injected\n   * mainFrame     - a boolean value which indicates whether this script is only injected for the main webview frame (true) or for all frames within the webview (false)\n   * injectionTime - a string which indicates whether the script is injected at \"documentStart\" or \"documentEnd\".\n\nNotes:\n * Because the WKUserContentController class only allows for removing all scripts, you can use this method to generate a list of all scripts, modify it, and then use it in a loop to reapply the scripts if you need to remove just a few scripts."
    },
    "Connect the interface to a wireless network": {
        "prefix": "hs.wifi.associate(network, passphrase[, interface]) -> boolean",
        "body": "hs.wifi.associate(${1:network}, ${2:passphrase[}, ${3:interface]})",
        "description": "Connect the interface to a wireless network\n\nParameters:\n * network - A string containing the SSID of the network to associate to\n * passphrase - A string containing the passphrase of the network\n * interface - An optional string containing the name of an interface (see [hs.wifi.interfaces](#interfaces)). If not present, the default system WLAN device will be used\n\nReturns:\n * A boolean, true if the network was joined successfully, false if an error occurred\n\nNotes:\n * Enterprise WiFi networks are not currently supported. Please file an issue on GitHub if you need support for enterprise networks\n * This function blocks Hammerspoon until the operation is completed\n * If multiple access points are available with the same SSID, one will be chosen at random to connect to"
    },
    "Gets a list of available WiFi networks": {
        "prefix": "hs.wifi.availableNetworks([interface]) -> table",
        "body": "hs.wifi.availableNetworks(${1:[interface]})",
        "description": "Gets a list of available WiFi networks\n\nParameters:\n * interface - an optional interface name as listed in the results of [hs.wifi.interfaces](#interfaces).  If not present, the interface defaults to the systems default WLAN device.\n\nReturns:\n * A table containing the names of all visible WiFi networks\n\nNotes:\n * WARNING: This function will block all Lua execution until the scan has completed. It's probably not very sensible to use this function very much, if at all."
    },
    "Perform a scan for available wifi networks in the background (non-blocking)": {
        "prefix": "hs.wifi.backgroundScan(fn, [interface]) -> scanObject",
        "body": "hs.wifi.backgroundScan(${1:fn}, ${2:[interface]})",
        "description": "Perform a scan for available wifi networks in the background (non-blocking)\n\nParameters:\n * fn        - the function to callback when the scan is completed.\n * interface - an optional interface name as listed in the results of [hs.wifi.interfaces](#interfaces).  If not present, the interface defaults to the systems default WLAN device.\n\nReturns:\n * returns a scan object\n\nNotes:\n * If you pass in nil as the callback function, the scan occurs but no callback function is called.  This can be useful to update the `cachedScanResults` entry returned by [hs.wifi.interfaceDetails](#interfaceDetails).\n\n* The callback function should expect one argument which will be a table if the scan was successful or a string containing an error message if it was not.  The table will be an array of available networks.  Each entry in the array will be a table containing the following keys:\n   * beaconInterval         - The beacon interval (ms) for the network.\n   * bssid                  - The basic service set identifier (BSSID) for the network.\n   * countryCode            - The country code (ISO/IEC 3166-1:1997) for the network.\n   * ibss                   - Whether or not the network is an IBSS (ad-hoc) network.\n   * informationElementData - Information element data included in beacon or probe response frames as an array of integers.\n   * noise                  - The aggregate noise measurement (dBm) for the network.\n   * PHYModes               - A table containing the PHY Modes supported by the network.\n   * rssi                   - The aggregate received signal strength indication (RSSI) measurement (dBm) for the network.\n   * security               - A table containing the security types supported by the network.\n   * ssid                   - The service set identifier (SSID) for the network, encoded as a string.\n   * ssidData               - The service set identifier (SSID) for the network, returned as data (1-32 octets).\n   * wlanChannel            - A table containing details about the channel the network is on. The table will contain the following keys:\n     * band   - The channel band.\n     * number - The channel number.\n     * width  - The channel width.\n\nNotes:\n * The contents of the `informationElementData` field is returned as an array of integers, each array item representing a byte in the block of data for the element.\n   * You can convert this data into a Lua string by passing the array as an argument to `string.char(table.unpack(results.informationElementData))`, but note that this field contains arbitrary binary data and should **not** be treated or considered as a *displayable* string. It requires additional parsing, depending upon the specific information you need from the probe or beacon response.\n   * For debugging purposes, if you wish to view the contents of this field as a string, make sure to wrap `string.char(table.unpack(results.informationElementData))` with `hs.utf8.asciiOnly` or `hs.utf8.hexDump`, rather than just print the result directly.\n   * As an example using [hs.wifi.interfaceDetails](#interfaceDetails) whose `cachedScanResults` key is an array of entries identical to the argument passed to this constructor's callback function:\n\n   ~~~\n   function dumpIED(interface)\n       local interface = interface or \"en0\"\n       local cleanupFunction = hs.utf8.hexDump -- or hs.utf8.asciiOnly if you prefer\n\n       local cachedScanResults = hs.wifi.interfaceDetails(interface).cachedScanResults\n       if not cachedScanResults then\n           hs.wifi.availableNetworks() -- blocking, so only do if necessary\n           cachedScanResults = hs.wifi.interfaceDetails(interface).cachedScanResults\n       end\n\n       for i, v in ipairs(cachedScanResults) do\n           print(v.ssid .. \" on channel \" .. v.wlanChannel.number .. \" beacon data:\")\n           print(cleanupFunction(string.char(table.unpack(v.informationElementData))))\n       end\n   end\n   ~~~\n\n   * These precautions are in response to Hammerspoon Github Issue #859.  As binary data, even when cleaned up with the Console's UTF8 wrapper code, some valid UTF8 sequences have been found to cause crashes in the OSX CoreText API during rendering.  While some specific sequences have made the rounds on the Internet, the specific code analysis at http://www.theregister.co.uk/2015/05/27/text_message_unicode_ios_osx_vulnerability/ suggests a possible cause of the problem which may be triggered by other currently unknown sequences as well.  As the sequences aren't at present predictable, we can't add to the UTF8 wrapper already in place for the Hammerspoon console."
    },
    "Gets the name of the current WiFi network": {
        "prefix": "hs.wifi.currentNetwork([interface]) -> string or nil",
        "body": "hs.wifi.currentNetwork(${1:[interface]})",
        "description": "Gets the name of the current WiFi network\n\nParameters:\n * interface - an optional interface name as listed in the results of [hs.wifi.interfaces](#interfaces).  If not present, the interface defaults to the systems default WLAN device.\n\nReturns:\n * A string containing the SSID of the WiFi network currently joined, or nil if no there is no WiFi connection"
    },
    "Disconnect the interface from its current network.": {
        "prefix": "hs.wifi.disassociate([interface]) -> nil",
        "body": "hs.wifi.disassociate(${1:[interface]})",
        "description": "Disconnect the interface from its current network.\n\nParameters:\n * interface - an optional interface name as listed in the results of [hs.wifi.interfaces](#interfaces).  If not present, the interface defaults to the systems default WLAN device.\n\nReturns:\n * None"
    },
    "Returns a table containing details about the wireless interface.": {
        "prefix": "hs.wifi.interfaceDetails([interface]) -> table",
        "body": "hs.wifi.interfaceDetails(${1:[interface]})",
        "description": "Returns a table containing details about the wireless interface.\n\nParameters:\n * interface - an optional interface name as listed in the results of [hs.wifi.interfaces](#interfaces).  If not present, the interface defaults to the systems default WLAN device.\n\nReturns:\n * A table containing details about the interface.  The table will contain the following keys:\n   * active            - The interface has its corresponding network service enabled.\n   * activePHYMode     - The current active PHY mode for the interface.\n   * bssid             - The current basic service set identifier (BSSID) for the interface.\n   * cachedScanResults - A table containing the networks currently in the scan cache for the WLAN interface.  See [hs.wifi.backgroundScan](#backgroundScan) for details on the table format.\n   * configuration     - A table containing the current configuration for the given WLAN interface.  This table will contain the following keys:\n     * networkProfiles                    - A table containing an array of known networks for the interface.  Entries in the array will each contain the following keys:\n       * ssid     - The service set identifier (SSID) for the network profile.\n       * ssidData - The service set identifier (SSID) for the network, returned as data (1-32 octets).\n       * security - The security mode for the network profile.\n     * rememberJoinedNetworks             - A boolean flag indicating whether or not the AirPort client will remember all joined networks.\n     * requireAdministratorForAssociation - A boolean flag indicating whether or not changing the wireless network requires an Administrator password.\n     * requireAdministratorForIBSSMode    - A boolean flag indicating whether or not creating an IBSS (Ad Hoc) network requires an Administrator password.\n     * requireAdministratorForPower       - A boolean flag indicating whether or not changing the wireless power state requires an Administrator password.\n   * countryCode       - The current country code (ISO/IEC 3166-1:1997) for the interface.\n   * hardwareAddress   - The hardware media access control (MAC) address for the interface.\n   * interface         - The BSD name of the interface.\n   * interfaceMode     - The current mode for the interface.\n   * noise             - The current aggregate noise measurement (dBm) for the interface.\n   * power             - Whether or not the interface is currently powered on.\n   * rssi              - The current aggregate received signal strength indication (RSSI) measurement (dBm) for the interface.\n   * security          - The current security mode for the interface.\n   * ssid              - The current service set identifier (SSID) for the interface.\n   * ssidData          - The service set identifier (SSID) for the interface, returned as data (1-32 octets).\n   * supportedChannels - An array of channels supported by the interface for the active country code.  The array will contain entries with the following keys:\n     * band   - The channel band.\n     * number - The channel number.\n     * width  - The channel width.\n   * transmitPower     - The current transmit power (mW) for the interface. Returns 0 in the case of an error.\n   * transmitRate      - The current transmit rate (Mbps) for the interface.\n   * wlanChannel       - A table containing details about the channel the interface is on. The table will contain the following keys:\n     * band   - The channel band.\n     * number - The channel number.\n     * width  - The channel width."
    },
    "Returns a list of interface names for WLAN devices attached to the system": {
        "prefix": "hs.wifi.interfaces() -> table",
        "body": "hs.wifi.interfaces()",
        "description": "Returns a list of interface names for WLAN devices attached to the system\n\nParameters:\n * None\n\nReturns:\n * a table containing the names of all WLAN interfaces for this system.\n\nNotes:\n * For most systems, this will be one interface, but the result is still returned as an array."
    },
    "Returns whether or not a scan object has completed its scan for wireless networks.": {
        "prefix": "hs.wifi:isDone() -> boolean",
        "body": "hs.wifi:isDone()",
        "description": "Returns whether or not a scan object has completed its scan for wireless networks.\n\nParameters:\n * None\n\nReturns:\n * a boolean value indicating whether or not the scan has been completed.\n\nNotes:\n * This will be set whether or not an actual callback function was invoked.  This method can be checked to see if the cached data for the `cachedScanResults` entry returned by [hs.wifi.interfaceDetails](#interfaceDetails) has been updated."
    },
    "Turns a wifi interface on or off": {
        "prefix": "hs.wifi.setPower(state, [interface]) -> boolean",
        "body": "hs.wifi.setPower(${1:state}, ${2:[interface]})",
        "description": "Turns a wifi interface on or off\n\nParameters:\n * state - a boolean value indicating if the Wifi device should be powered on (true) or off (false).\n * interface - an optional interface name as listed in the results of [hs.wifi.interfaces](#interfaces).  If not present, the interface defaults to the systems default WLAN device.\n\nReturns:\n * True if the power change was successful, or false and an error string if an error occurred attempting to set the power state.  Returns nil if there is a problem attaching to the interface."
    },
    "A table containing the possible event types that this watcher can monitor for.": {
        "prefix": "hs.wifi.watcher.eventTypes[]",
        "body": "hs.wifi.watcher.eventTypes",
        "description": "A table containing the possible event types that this watcher can monitor for.\n\nThe following events are available for monitoring:\n* \"SSIDChange\"                   - monitor when the associated network for the Wi-Fi interface changes\n* \"BSSIDChange\"                  - monitor when the base station the Wi-Fi interface is connected to changes\n* \"countryCodeChange\"            - monitor when the adopted country code of the Wi-Fi interface changes\n* \"linkChange\"                   - monitor when the link state for the Wi-Fi interface changes\n* \"linkQualityChange\"            - monitor when the RSSI or transmit rate for the Wi-Fi interface changes\n* \"modeChange\"                   - monitor when the operating mode of the Wi-Fi interface changes\n* \"powerChange\"                  - monitor when the power state of the Wi-Fi interface changes\n* \"scanCacheUpdated\"             - monitor when the scan cache of the Wi-Fi interface is updated with new information"
    },
    "Creates a new watcher for WiFi network events": {
        "prefix": "hs.wifi.watcher.new(fn) -> watcher",
        "body": "hs.wifi.watcher.new(${1:fn})",
        "description": "Creates a new watcher for WiFi network events\n\nParameters:\n * fn - A function that will be called when a WiFi event that is being monitored occurs. The function should expect 2 or 4 arguments as described in the notes below.\n\nReturns:\n * A `hs.wifi.watcher` object\n\nNotes:\n * For backwards compatibility, only \"SSIDChange\" is watched for by default, so existing code can continue to ignore the callback function arguments unless you add or change events with the [hs.wifi.watcher:watchingFor](#watchingFor).\n\n * The callback function should expect between 3 and 5 arguments, depending upon the events being watched.  The possible arguments are as follows:\n\n   * `watcher`, \"SSIDChange\", `interface` - occurs when the associated network for the Wi-Fi interface changes\n     * `watcher`   - the watcher object itself\n     * `message`   - the message specifying the event, in this case \"SSIDChange\"\n     * `interface` - the name of the interface for which the event occured\n   * Use `hs.wifi.currentNetwork([interface])` to identify the new network, which may be nil when you leave a network.\n\n   * `watcher`, \"BSSIDChange\", `interface` - occurs when the base station the Wi-Fi interface is connected to changes\n     * `watcher`   - the watcher object itself\n     * `message`   - the message specifying the event, in this case \"BSSIDChange\"\n     * `interface` - the name of the interface for which the event occured\n\n   * `watcher`, \"countryCodeChange\", `interface` - occurs when the adopted country code of the Wi-Fi interface changes\n     * `watcher`   - the watcher object itself\n     * `message`   - the message specifying the event, in this case \"countryCodeChange\"\n     * `interface` - the name of the interface for which the event occured\n\n   * `watcher`, \"linkChange\", `interface` - occurs when the link state for the Wi-Fi interface changes\n     * `watcher`   - the watcher object itself\n     * `message`   - the message specifying the event, in this case \"linkChange\"\n     * `interface` - the name of the interface for which the event occured\n\n   * `watcher`, \"linkQualityChange\", `interface` - occurs when the RSSI or transmit rate for the Wi-Fi interface changes\n     * `watcher`   - the watcher object itself\n     * `message`   - the message specifying the event, in this case \"linkQualityChange\"\n     * `interface` - the name of the interface for which the event occured\n     * `rssi`      - the RSSI value for the currently associated network on the Wi-Fi interface\n     * `rate`      - the transmit rate for the currently associated network on the Wi-Fi interface\n\n   * `watcher`, \"modeChange\", `interface` - occurs when the operating mode of the Wi-Fi interface changes\n     * `watcher`   - the watcher object itself\n     * `message`   - the message specifying the event, in this case \"modeChange\"\n     * `interface` - the name of the interface for which the event occured\n\n   * `watcher`, \"powerChange\", `interface` - occurs when the power state of the Wi-Fi interface changes\n     * `watcher`   - the watcher object itself\n     * `message`   - the message specifying the event, in this case \"powerChange\"\n     * `interface` - the name of the interface for which the event occured\n\n   * `watcher`, \"scanCacheUpdated\", `interface` - occurs when the scan cache of the Wi-Fi interface is updated with new information\n     * `watcher`   - the watcher object itself\n     * `message`   - the message specifying the event, in this case \"scanCacheUpdated\"\n     * `interface` - the name of the interface for which the event occured"
    },
    "Starts the SSID watcher": {
        "prefix": "hs.wifi.watcher:start() -> watcher",
        "body": "hs.wifi.watcher:start()",
        "description": "Starts the SSID watcher\n\nParameters:\n * None\n\nReturns:\n * The `hs.wifi.watcher` object"
    },
    "Stops the SSID watcher": {
        "prefix": "hs.wifi.watcher:stop() -> watcher",
        "body": "hs.wifi.watcher:stop()",
        "description": "Stops the SSID watcher\n\nParameters:\n * None\n\nReturns:\n * The `hs.wifi.watcher` object"
    },
    "Get or set the specific types of wifi events to generate a callback for with this watcher.": {
        "prefix": "hs.wifi.watcher:watchingFor([messages]) -> watcher | current-value",
        "body": "hs.wifi.watcher:watchingFor(${1:[messages]})",
        "description": "Get or set the specific types of wifi events to generate a callback for with this watcher.\n\nParameters:\n * `messages` - an optional table of or list of strings specifying the types of events this watcher should invoke a callback for.  You can specify multiple types of events to watch for. Defaults to `{ \"SSIDChange\" }`.\n\nReturns:\n * if a value is provided, returns the watcher object; otherwise returns the current values as a table of strings.\n\nNotes:\n * the possible values for this method are described in [hs.wifi.watcher.eventTypes](#eventTypes).\n * the special string \"all\" specifies that all event types should be watched for."
    },
    "Returns all windows": {
        "prefix": "hs.window.allWindows() -> list of hs.window objects",
        "body": "hs.window.allWindows()",
        "description": "Returns all windows\n\nParameters:\n * None\n\nReturns:\n * A list of `hs.window` objects representing all open windows\n\nNotes:\n * `visibleWindows()`, `orderedWindows()`, `get()`, `find()`, and several more functions and methods in this and other\n    modules make use of this function, so it is important to understand its limitations\n * This function queries all applications for their windows every time it is invoked; if you need to call it a lot and\n   performance is not acceptable consider using the `hs.window.filter` module\n * This function can only return windows in the current Mission Control Space; if you need to address windows across\n   different Spaces you can use the `hs.window.filter` module\n   - if `Displays have separate Spaces` is *on* (in System Preferences>Mission Control) the current Space is defined\n     as the union of all currently visible Spaces\n   - minimized windows and hidden windows (i.e. belonging to hidden apps, e.g. via cmd-h) are always considered\n     to be in the current Space\n * This function filters out the desktop \"window\"; use `hs.window.desktop()` to address it. (Note however that\n   `hs.application.get'Finder':allWindows()` *will* include the desktop in the returned list)\n * Beside the limitations discussed above, this function will return *all* windows as reported by OSX, including some\n   \"windows\" that one wouldn't expect: for example, every Google Chrome (actual) window has a companion window for its\n   status bar; therefore you might get unexpected results  - in the Chrome example, calling `hs.window.focusWindowSouth()`\n   from a Chrome window would end up \"focusing\" its status bar, and therefore the proper window itself, seemingly resulting\n   in a no-op. In order to avoid such surprises you can use the `hs.window.filter` module, and more specifically\n   the default windowfilter (`hs.window.filter.default`) which filters out known cases of not-actual-windows\n * Some windows will not be reported by OSX - e.g. things that are on different Spaces, or things that are Full Screen"
    },
    "The default duration for animations, in seconds. Initial value is 0.2; set to 0 to disable animations.": {
        "prefix": "hs.window.animationDuration (number)",
        "body": "hs.window.animationDuration (${1:number})",
        "description": "The default duration for animations, in seconds. Initial value is 0.2; set to 0 to disable animations.\n\nUsage:\n```\nhs.window.animationDuration = 0 -- disable animations\nhs.window.animationDuration = 3 -- if you have time on your hands\n```"
    },
    "Gets the `hs.application` object the window belongs to": {
        "prefix": "hs.window:application() -> app or nil",
        "body": "hs.window:application()",
        "description": "Gets the `hs.application` object the window belongs to\n\nParameters:\n * None\n\nReturns:\n * An `hs.application` object representing the application that owns the window, or nil if an error occurred"
    },
    "Makes the window the main window of its application": {
        "prefix": "hs.window:becomeMain() -> window",
        "body": "hs.window:becomeMain()",
        "description": "Makes the window the main window of its application\n\nParameters:\n * None\n\nReturns:\n * The `hs.window` object\n\nNotes:\n * Make a window become the main window does not transfer focus to the application. See `hs.window.focus()`"
    },
    "Centers the window on a screen": {
        "prefix": "hs.window:centerOnScreen([screen][, ensureInScreenBounds][, duration]) --> hs.window object",
        "body": "hs.window:centerOnScreen(${1:[screen][}, ${2:ensureInScreenBounds][}, ${3:duration]}) --> hs.window object",
        "description": "Centers the window on a screen\n\nParameters:\n * screen - (optional) An `hs.screen` object or argument for `hs.screen.find`; if nil, use the screen the window is currently on\n * ensureInScreenBounds - (optional) if `true`, use `setFrameInScreenBounds()` to ensure the resulting window frame is fully contained within\n   the window's screen\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object"
    },
    "Closes the window": {
        "prefix": "hs.window:close() -> bool",
        "body": "hs.window:close()",
        "description": "Closes the window\n\nParameters:\n * None\n\nReturns:\n * True if the operation succeeded, false if not"
    },
    "Returns the desktop \"window\"": {
        "prefix": "hs.window.desktop() -> hs.window object",
        "body": "hs.window.desktop()",
        "description": "Returns the desktop \"window\"\n\nParameters:\n * None\n\nReturns:\n * An `hs.window` object representing the desktop, or nil if Finder is not running\n\nNotes:\n * The desktop belongs to Finder.app: when Finder is the active application, you can focus the desktop by cycling\n   through windows via cmd-`\n * The desktop window has no id, a role of `AXScrollArea` and no subrole\n * The desktop is filtered out from `hs.window.allWindows()` (and downstream uses)"
    },
    "Finds windows": {
        "prefix": "hs.window.find(hint) -> hs.window object(s)",
        "body": "hs.window.find(${1:hint})",
        "description": "Finds windows\n\nParameters:\n * hint - search criterion for the desired window(s); it can be:\n   - an id number as per `hs.window:id()`\n   - a string pattern that matches (via `string.find`) the window title as per `hs.window:title()` (for convenience, the matching will be done on lowercased strings)\n\nReturns:\n * one or more hs.window objects that match the supplied search criterion, or `nil` if none found\n\nNotes:\n * for convenience you can call this as `hs.window(hint)`\n * see also `hs.window.get`\n * for more sophisticated use cases and/or for better performance if you call this a lot, consider using `hs.window.filter`\n\nUsage:\n```\n-- by id\nhs.window(8812):title() --> Hammerspoon Console\n-- by title\nhs.window'bash':application():name() --> Terminal\n```"
    },
    "Focuses the window": {
        "prefix": "hs.window:focus() -> hs.window object",
        "body": "hs.window:focus()",
        "description": "Focuses the window\n\nParameters:\n * None\n\nReturns:\n * The `hs.window` object"
    },
    "Returns the window that has keyboard/mouse focus": {
        "prefix": "hs.window.focusedWindow() -> window",
        "body": "hs.window.focusedWindow()",
        "description": "Returns the window that has keyboard/mouse focus\n\nParameters:\n * None\n\nReturns:\n * An `hs.window` object representing the currently focused window"
    },
    "Focuses the tab in the window's tab group at index, or the last tab if": {
        "prefix": "hs.window:focusTab(index) -> bool",
        "body": "hs.window:focusTab(${1:index})",
        "description": "Focuses the tab in the window's tab group at index, or the last tab if\nindex is out of bounds. Returns true if a tab was pressed.\nWorks with document tab groups and some app tabs, like Chrome and Safari.\n\nParameters:\n * index - A number, a 1-based index of a tab to focus\n\nReturns:\n * true if the tab was successfully pressed, or false if there was a problem"
    },
    "Focuses the nearest possible window to the east (i.e. right)": {
        "prefix": "hs.window:focusWindowEast([candidateWindows[, frontmost[, strict]]]) -> boolean",
        "body": "hs.window:focusWindowEast(${1:[candidateWindows[}, ${2:frontmost[}, ${3:strict]]]})",
        "description": "Focuses the nearest possible window to the east (i.e. right)\n\nParameters:\n * candidateWindows - (optional) a list of candidate windows to consider; if nil, all visible windows\n   to the east are candidates.\n * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window\n * strict - (optional) boolean, if true only consider windows at an angle between 45\u00b0 and -45\u00b0 on the\n   eastward axis\n\nReturns:\n * `true` if a window was found and focused, `false` otherwise; `nil` if the search couldn't take place\n\nNotes:\n * If you don't pass `candidateWindows`, Hammerspoon will query for the list of all visible windows\n   every time this method is called; this can be slow, and some undesired \"windows\" could be included\n   (see the notes for `hs.window.allWindows()`); consider using the equivalent methods in\n   `hs.window.filter` instead"
    },
    "Focuses the nearest possible window to the north (i.e. up)": {
        "prefix": "hs.window:focusWindowNorth([candidateWindows[, frontmost[, strict]]]) -> boolean",
        "body": "hs.window:focusWindowNorth(${1:[candidateWindows[}, ${2:frontmost[}, ${3:strict]]]})",
        "description": "Focuses the nearest possible window to the north (i.e. up)\n\n(See `hs.window:focusWindowEast()`)"
    },
    "Focuses the nearest possible window to the south (i.e. down)": {
        "prefix": "hs.window:focusWindowSouth([candidateWindows[, frontmost[, strict]]]) -> boolean",
        "body": "hs.window:focusWindowSouth(${1:[candidateWindows[}, ${2:frontmost[}, ${3:strict]]]})",
        "description": "Focuses the nearest possible window to the south (i.e. down)\n\n(See `hs.window:focusWindowEast()`)"
    },
    "Focuses the nearest possible window to the west (i.e. left)": {
        "prefix": "hs.window:focusWindowWest([candidateWindows[, frontmost[, strict]]]) -> boolean",
        "body": "hs.window:focusWindowWest(${1:[candidateWindows[}, ${2:frontmost[}, ${3:strict]]]})",
        "description": "Focuses the nearest possible window to the west (i.e. left)\n\n(See `hs.window:focusWindowEast()`)"
    },
    "Gets the frame of the window in absolute coordinates": {
        "prefix": "hs.window:frame() -> hs.geometry rect",
        "body": "hs.window:frame()",
        "description": "Gets the frame of the window in absolute coordinates\n\nParameters:\n * None\n\nReturns:\n * An hs.geometry rect containing the co-ordinates of the top left corner of the window and its width and height"
    },
    "Returns the focused window or, if no window has focus, the frontmost one": {
        "prefix": "hs.window.frontmostWindow() -> hs.window object",
        "body": "hs.window.frontmostWindow()",
        "description": "Returns the focused window or, if no window has focus, the frontmost one\n\nParameters:\n * None\n\nReturns:\n* An `hs.window` object representing the frontmost window, or `nil` if there are no visible windows"
    },
    "Gets a specific window": {
        "prefix": "hs.window.get(hint) -> hs.window object",
        "body": "hs.window.get(${1:hint})",
        "description": "Gets a specific window\n\nParameters:\n * hint - search criterion for the desired window; it can be:\n   - an id number as per `hs.window:id()`\n   - a window title string as per `hs.window:title()`\n\nReturns:\n * the first hs.window object that matches the supplied search criterion, or `nil` if not found\n\nNotes:\n * see also `hs.window.find` and `hs.application:getWindow()`"
    },
    "Gets the unique identifier of the window": {
        "prefix": "hs.window:id() -> number or nil",
        "body": "hs.window:id()",
        "description": "Gets the unique identifier of the window\n\nParameters:\n * None\n\nReturns:\n * A number containing the unique identifier of the window, or nil if an error occurred"
    },
    "Gets all invisible windows": {
        "prefix": "hs.window.invisibleWindows() -> list of hs.window objects",
        "body": "hs.window.invisibleWindows()",
        "description": "Gets all invisible windows\n\nParameters:\n * None\n\nReturns:\n * A list containing `hs.window` objects representing all windows that are not visible as per `hs.window:isVisible()`"
    },
    "Gets the fullscreen state of the window": {
        "prefix": "hs.window:isFullScreen() -> bool or nil",
        "body": "hs.window:isFullScreen()",
        "description": "Gets the fullscreen state of the window\n\nParameters:\n * None\n\nReturns:\n * True if the window is fullscreen, false if not. Nil if an error occurred"
    },
    "Determines if a window is maximizable": {
        "prefix": "hs.window:isMaximizable() -> bool or nil",
        "body": "hs.window:isMaximizable()",
        "description": "Determines if a window is maximizable\n\nParamters:\n * None\n\nReturns:\n * True if the window is maximizable, False if it isn't, or nil if an error occurred"
    },
    "Gets the minimized state of the window": {
        "prefix": "hs.window:isMinimized() -> bool",
        "body": "hs.window:isMinimized()",
        "description": "Gets the minimized state of the window\n\nParameters:\n * None\n\nReturns:\n * True if the window is minimized, otherwise false"
    },
    "Determines if the window is a standard window": {
        "prefix": "hs.window:isStandard() -> bool",
        "body": "hs.window:isStandard()",
        "description": "Determines if the window is a standard window\n\nParameters:\n * None\n\nReturns:\n * True if the window is standard, otherwise false\n\nNotes:\n * \"Standard window\" means that this is not an unusual popup window, a modal dialog, a floating window, etc."
    },
    "Determines if a window is visible (i.e. not hidden and not minimized)": {
        "prefix": "hs.window:isVisible() -> boolean",
        "body": "hs.window:isVisible()",
        "description": "Determines if a window is visible (i.e. not hidden and not minimized)\n\nParameters:\n * None\n\nReturns:\n * `true` if the window is visible, otherwise `false`\n\nNotes:\n * This does not mean the user can see the window - it may be obscured by other windows, or it may be off the edge of the screen"
    },
    "Gets a table containing all the window data retrieved from `CGWindowListCreate`.": {
        "prefix": "hs.window.list(allWindows) -> table",
        "body": "hs.window.list(${1:allWindows})",
        "description": "Gets a table containing all the window data retrieved from `CGWindowListCreate`.\n\nParameters:\n * allWindows - Get all the windows, even those \"below\" the Dock window.\n\nReturns:\n * `true` is succesful otherwise `false` if an error occured.\n\nNotes:\n * This allows you to get window information without Accessibility Permissions."
    },
    "Maximizes the window": {
        "prefix": "hs.window:maximize([duration]) -> hs.window object",
        "body": "hs.window:maximize(${1:[duration]})",
        "description": "Maximizes the window\n\nParameters:\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object\n\nNotes:\n * The window will be resized as large as possible, without obscuring the dock/menu"
    },
    "Minimizes the window": {
        "prefix": "hs.window:minimize() -> window",
        "body": "hs.window:minimize()",
        "description": "Minimizes the window\n\nParameters:\n * None\n\nReturns:\n * The `hs.window` object\n\nNotes:\n * This method will always animate per your system settings and is not affected by `hs.window.animationDuration`"
    },
    "Gets all minimized windows": {
        "prefix": "hs.window.minimizedWindows() -> list of hs.window objects",
        "body": "hs.window.minimizedWindows()",
        "description": "Gets all minimized windows\n\nParameters:\n * None\n\nReturns:\n * A list containing `hs.window` objects representing all windows that are minimized as per `hs.window:isMinimized()`"
    },
    "Moves the window": {
        "prefix": "hs.window:move(rect[, screen][, ensureInScreenBounds][, duration]) --> hs.window object",
        "body": "hs.window:move(${1:rect[}, ${2:screen][}, ${3:ensureInScreenBounds][}, ${4:duration]}) --> hs.window object",
        "description": "Moves the window\n\nParameters:\n * rect - It can be:\n   - an `hs.geometry` point, or argument to construct one; will move the screen by this delta, keeping its size constant; `screen` is ignored\n   - an `hs.geometry` rect, or argument to construct one; will set the window frame to this rect, in absolute coordinates; `screen` is ignored\n   - an `hs.geometry` unit rect, or argument to construct one; will set the window frame to this rect relative to the desired screen;\n     if `screen` is nil, use the screen the window is currently on\n * screen - (optional) An `hs.screen` object or argument for `hs.screen.find`; only valid if `rect` is a unit rect\n * ensureInScreenBounds - (optional) if `true`, use `setFrameInScreenBounds()` to ensure the resulting window frame is fully contained within\n   the window's screen\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object"
    },
    "Moves the window one screen east (i.e. right)": {
        "prefix": "hs.window:moveOneScreenEast([noResize, ensureInScreenBounds][, duration]) -> hs.window object",
        "body": "hs.window:moveOneScreenEast(${1:[noResize}, ${2:ensureInScreenBounds][}, ${3:duration]})",
        "description": "Moves the window one screen east (i.e. right)\n\nParameters:\n * noResize - (optional) if `true`, maintain the window's absolute size\n * ensureInScreenBounds - (optional) if `true`, use `setFrameInScreenBounds()` to ensure the resulting window frame is fully contained within\n   the window's screen\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object"
    },
    "Moves the window one screen north (i.e. up)": {
        "prefix": "hs.window:moveOneScreenNorth([noResize, ensureInScreenBounds][, duration]) -> hs.window object",
        "body": "hs.window:moveOneScreenNorth(${1:[noResize}, ${2:ensureInScreenBounds][}, ${3:duration]})",
        "description": "Moves the window one screen north (i.e. up)\n\n\n(See `hs.window:moveOneScreenEast()`)"
    },
    "Moves the window one screen south (i.e. down)": {
        "prefix": "hs.window:moveOneScreenSouth([noResize, ensureInScreenBounds][, duration]) -> hs.window object",
        "body": "hs.window:moveOneScreenSouth(${1:[noResize}, ${2:ensureInScreenBounds][}, ${3:duration]})",
        "description": "Moves the window one screen south (i.e. down)\n\n\n(See `hs.window:moveOneScreenEast()`)"
    },
    "Moves the window one screen west (i.e. left)": {
        "prefix": "hs.window:moveOneScreenWest([noResize, ensureInScreenBounds][, duration]) -> hs.window object",
        "body": "hs.window:moveOneScreenWest(${1:[noResize}, ${2:ensureInScreenBounds][}, ${3:duration]})",
        "description": "Moves the window one screen west (i.e. left)\n\n(See `hs.window:moveOneScreenEast()`)"
    },
    "Moves the window to a given screen, retaining its relative position and size": {
        "prefix": "hs.window:moveToScreen(screen[, noResize, ensureInScreenBounds][, duration]) -> hs.window object",
        "body": "hs.window:moveToScreen(${1:screen[}, ${2:noResize}, ${3:ensureInScreenBounds][}, ${4:duration]})",
        "description": "Moves the window to a given screen, retaining its relative position and size\n\nParameters:\n * screen - An `hs.screen` object, or an argument for `hs.screen.find()`, representing the screen to move the window to\n * noResize - (optional) if `true`, maintain the window's absolute size\n * ensureInScreenBounds - (optional) if `true`, use `setFrameInScreenBounds()` to ensure the resulting window frame is fully contained within\n   the window's screen\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object"
    },
    "Moves and resizes the window to occupy a given fraction of the screen": {
        "prefix": "hs.window:moveToUnit(unitrect[, duration]) -> hs.window object",
        "body": "hs.window:moveToUnit(${1:unitrect[}, ${2:duration]})",
        "description": "Moves and resizes the window to occupy a given fraction of the screen\n\nParameters:\n * unitrect - An `hs.geometry` unit rect, or constructor argument to create one\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object\n\nNotes:\n * An example, which would make a window fill the top-left quarter of the screen: `win:moveToUnit'[0,0,50,50]'`"
    },
    "Returns all visible windows, ordered from front to back": {
        "prefix": "hs.window.orderedWindows() -> list of hs.window objects",
        "body": "hs.window.orderedWindows()",
        "description": "Returns all visible windows, ordered from front to back\n\nParameters:\n * None\n\nReturns:\n * A list of `hs.window` objects representing all visible windows, ordered from front to back"
    },
    "Gets every window except this one": {
        "prefix": "hs.window:otherWindowsAllScreens() -> list of hs.window objects",
        "body": "hs.window:otherWindowsAllScreens()",
        "description": "Gets every window except this one\n\nParameters:\n * None\n\nReturns:\n * A table containing `hs.window` objects representing all visible windows other than this one"
    },
    "Gets other windows on the same screen": {
        "prefix": "hs.window:otherWindowsSameScreen() -> list of hs.window objects",
        "body": "hs.window:otherWindowsSameScreen()",
        "description": "Gets other windows on the same screen\n\nParameters:\n * None\n\nReturns:\n * A table of `hs.window` objects representing the visible windows other than this one that are on the same screen"
    },
    "Brings a window to the front of the screen without focussing it": {
        "prefix": "hs.window:raise() -> window",
        "body": "hs.window:raise()",
        "description": "Brings a window to the front of the screen without focussing it\n\nParameters:\n * None\n\nReturns:\n * The `hs.window` object"
    },
    "Gets the role of the window": {
        "prefix": "hs.window:role() -> string",
        "body": "hs.window:role()",
        "description": "Gets the role of the window\n\nParameters:\n * None\n\nReturns:\n * A string containing the role of the window"
    },
    "Gets the screen which the window is on": {
        "prefix": "hs.window:screen() -> hs.screen object",
        "body": "hs.window:screen()",
        "description": "Gets the screen which the window is on\n\nParameters:\n * None\n\nReturns:\n * An `hs.screen` object representing the screen which most contains the window (by area)"
    },
    "Sends the window to the back": {
        "prefix": "hs.window:sendToBack() -> hs.window object",
        "body": "hs.window:sendToBack()",
        "description": "Sends the window to the back\n\nThis method works by focusing all overlapping windows behind this one, front to back.\nIf called on the focused window, this method will switch focus to the topmost window under this one; otherwise, the\ncurrently focused window will regain focus after this window has been sent to the back.\n\nParameters:\n * None\n\nReturns:\n * The `hs.window` object\n\nNotes:\n * Due to the way this method works and OSX limitations, calling this method when you have a lot of randomly overlapping\n  (as opposed to neatly tiled) windows might be visually jarring, and take a fair amount of time to complete.\n  So if you don't use orderly layouts, or if you have a lot of windows in general, you're probably better off using\n  `hs.application:hide()` (or simply `cmd-h`)"
    },
    "Sets the frame of the window in absolute coordinates": {
        "prefix": "hs.window:setFrame(rect[, duration]) -> hs.window object",
        "body": "hs.window:setFrame(${1:rect[}, ${2:duration]})",
        "description": "Sets the frame of the window in absolute coordinates\n\nParameters:\n * rect - An hs.geometry rect, or constructor argument, describing the frame to be applied to the window\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object"
    },
    "Using `hs.window:setFrame()` in some cases does not work as expected: namely, the bottom (or Dock) edge, and edges between screens, might": {
        "prefix": "hs.window.setFrameCorrectness",
        "body": "hs.window.setFrameCorrectness",
        "description": "Using `hs.window:setFrame()` in some cases does not work as expected: namely, the bottom (or Dock) edge, and edges between screens, might\nexhibit some \"stickiness\"; consequently, trying to make a window abutting one of those edges just *slightly* smaller could\nresult in no change at all (you can verify this by trying to resize such a window with the mouse: at first it won't budge,\nand, as you drag further away, suddenly snap to the new size); and similarly in some cases windows along screen edges\nmight erroneously end up partially on the adjacent screen after a move/resize.  Additionally some windows (no matter\ntheir placement on screen) only allow being resized at \"discrete\" steps of several screen points; the typical example\nis Terminal windows, which only resize to whole rows and columns. Both these OSX issues can cause incorrect behavior\nwhen using `:setFrame()` directly or in downstream uses, such as `hs.window:move()` and the `hs.grid` and `hs.window.layout` modules.\n\nSetting this variable to `true` will make `:setFrame()` perform additional checks and workarounds for these potential\nissues. However, as a side effect the window might appear to jump around briefly before setting toward its destination\nframe, and, in some cases, the move/resize animation (if requested) might be skipped entirely - these tradeoffs are\nnecessary to ensure the desired result.\n\nThe default value is `false`, in order to avoid the possibly annoying or distracting window wiggling; set to `true` if you see\nincorrect results in `:setFrame()` or downstream modules and don't mind the the wiggling."
    },
    "Sets the frame of the window in absolute coordinates, possibly adjusted to ensure it is fully inside the screen": {
        "prefix": "hs.window:setFrameInScreenBounds([rect][, duration]) -> hs.window object",
        "body": "hs.window:setFrameInScreenBounds(${1:[rect][}, ${2:duration]})",
        "description": "Sets the frame of the window in absolute coordinates, possibly adjusted to ensure it is fully inside the screen\n\nParameters:\n * rect - An hs.geometry rect, or constructor argument, describing the frame to be applied to the window; if omitted,\n   the current window frame will be used\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object"
    },
    "Sets the frame of the window in absolute coordinates, using the additional workarounds described in `hs.window.setFrameCorrectness`": {
        "prefix": "hs.window:setFrameWithWorkarounds(rect[, duration]) -> hs.window object",
        "body": "hs.window:setFrameWithWorkarounds(${1:rect[}, ${2:duration]})",
        "description": "Sets the frame of the window in absolute coordinates, using the additional workarounds described in `hs.window.setFrameCorrectness`\n\nParameters:\n * rect - An hs.geometry rect, or constructor argument, describing the frame to be applied to the window\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object"
    },
    "Sets the fullscreen state of the window": {
        "prefix": "hs.window:setFullScreen(fullscreen) -> window",
        "body": "hs.window:setFullScreen(${1:fullscreen})",
        "description": "Sets the fullscreen state of the window\n\nParameters:\n * fullscreen - A boolean, true if the window should be set fullscreen, false if not\n\nReturns:\n * The `hs.window` object"
    },
    "Enables/Disables window shadows": {
        "prefix": "hs.window.setShadows(shadows)",
        "body": "hs.window.setShadows(${1:shadows})",
        "description": "Enables/Disables window shadows\n\nParameters:\n * shadows - A boolean, true to show window shadows, false to hide window shadows\n\nReturns:\n * None\n\nNotes:\n * This function uses a private, undocumented OS X API call, so it is not guaranteed to work in any future OS X release"
    },
    "Resizes the window": {
        "prefix": "hs.window:setSize(size) -> window",
        "body": "hs.window:setSize(${1:size})",
        "description": "Resizes the window\n\nParameters:\n * size - A size-table containing the width and height the window should be resized to\n\nReturns:\n * The `hs.window` object"
    },
    "Moves the window to a given point": {
        "prefix": "hs.window:setTopLeft(point) -> window",
        "body": "hs.window:setTopLeft(${1:point})",
        "description": "Moves the window to a given point\n\nParameters:\n * point - A point-table containing the absolute co-ordinates the window should be moved to\n\nReturns:\n * The `hs.window` object"
    },
    "Gets the size of the window": {
        "prefix": "hs.window:size() -> size",
        "body": "hs.window:size()",
        "description": "Gets the size of the window\n\nParameters:\n * None\n\nReturns:\n * A size-table containing the width and height of the window"
    },
    "Returns a snapshot of the window as an `hs.image` object": {
        "prefix": "hs.window:snapshot([keepTransparency]) -> hs.image-object",
        "body": "hs.window:snapshot(${1:[keepTransparency]})",
        "description": "Returns a snapshot of the window as an `hs.image` object\n\nParameters:\n * keepTransparency - optional boolean value indicating if the windows alpha value (transparency) should be maintained in the resulting image or if it should be fully opaque (default).\n\nReturns:\n * `hs.image` object of the window snapshot or nil if unable to create a snapshot\n\nNotes:\n * See also function `hs.window.snapshotForID()`"
    },
    "Returns a snapshot of the window specified by the ID as an `hs.image` object": {
        "prefix": "hs.window.snapshotForID(ID [, keepTransparency]) -> hs.image-object",
        "body": "hs.window.snapshotForID(${1:ID [}, ${2:keepTransparency]})",
        "description": "Returns a snapshot of the window specified by the ID as an `hs.image` object\n\nParameters:\n * ID - Window ID of the window to take a snapshot of.\n * keepTransparency - optional boolean value indicating if the windows alpha value (transparency) should be maintained in the resulting image or if it should be fully opaque (default).\n\nReturns:\n * `hs.image` object of the window snapshot or nil if unable to create a snapshot\n\nNotes:\n * See also method `hs.window:snapshot()`\n * Because the window ID cannot always be dynamically determined, this function will allow you to provide the ID of a window that was cached earlier."
    },
    "Gets the subrole of the window": {
        "prefix": "hs.window:subrole() -> string",
        "body": "hs.window:subrole()",
        "description": "Gets the subrole of the window\n\nParameters:\n * None\n\nReturns:\n * A string containing the subrole of the window\n\nNotes:\n * This typically helps to determine if a window is a special kind of window - such as a modal window, or a floating window"
    },
    "Gets the number of tabs in the window has, or nil if the window doesn't have tabs.": {
        "prefix": "hs.window:tabCount() -> number or nil",
        "body": "hs.window:tabCount()",
        "description": "Gets the number of tabs in the window has, or nil if the window doesn't have tabs.\nIntended for use with the focusTab method, if this returns a number, then focusTab\ncan switch between that many tabs.\n\nParameters:\n * None\n\nReturns:\n * A number containing the number of tabs, or nil if an error occurred"
    },
    "Sets the timeout value used in the accessibility API.": {
        "prefix": "hs.window.timeout(value) -> boolean",
        "body": "hs.window.timeout(${1:value})",
        "description": "Sets the timeout value used in the accessibility API.\n\nParameters:\n * value - The number of seconds for the new timeout value.\n\nReturns:\n * `true` is succesful otherwise `false` if an error occured."
    },
    "Gets the title of the window": {
        "prefix": "hs.window:title() -> string",
        "body": "hs.window:title()",
        "description": "Gets the title of the window\n\nParameters:\n * None\n\nReturns:\n * A string containing the title of the window"
    },
    "Toggles the fullscreen state of the window": {
        "prefix": "hs.window:toggleFullScreen() -> hs.window object",
        "body": "hs.window:toggleFullScreen()",
        "description": "Toggles the fullscreen state of the window\n\nParameters:\n * None\n\nReturns:\n * The `hs.window` object\n\nNotes:\n * Not all windows support being full-screened"
    },
    "Toggles the zoom state of the window (this is effectively equivalent to clicking the green maximize/fullscreen button at the top left of a window)": {
        "prefix": "hs.window:toggleZoom() -> window",
        "body": "hs.window:toggleZoom()",
        "description": "Toggles the zoom state of the window (this is effectively equivalent to clicking the green maximize/fullscreen button at the top left of a window)\n\nParameters:\n * None\n\nReturns:\n * The `hs.window` object"
    },
    "Gets the absolute co-ordinates of the top left of the window": {
        "prefix": "hs.window:topLeft() -> point",
        "body": "hs.window:topLeft()",
        "description": "Gets the absolute co-ordinates of the top left of the window\n\nParameters:\n * None\n\nReturns:\n * A point-table containing the absolute co-ordinates of the top left corner of the window"
    },
    "Un-minimizes the window": {
        "prefix": "hs.window:unminimize() -> window",
        "body": "hs.window:unminimize()",
        "description": "Un-minimizes the window\n\nParameters:\n * None\n\nReturns:\n * The `hs.window` object"
    },
    "Gets all visible windows": {
        "prefix": "hs.window.visibleWindows() -> list of hs.window objects",
        "body": "hs.window.visibleWindows()",
        "description": "Gets all visible windows\n\nParameters:\n * None\n\nReturns:\n * A list containing `hs.window` objects representing all windows that are visible as per `hs.window:isVisible()`"
    },
    "Gets all windows to the east of this window": {
        "prefix": "hs.window:windowsToEast([candidateWindows[, frontmost[, strict]]]) -> list of hs.window objects",
        "body": "hs.window:windowsToEast(${1:[candidateWindows[}, ${2:frontmost[}, ${3:strict]]]})",
        "description": "Gets all windows to the east of this window\n\nParameters:\n * candidateWindows - (optional) a list of candidate windows to consider; if nil, all visible windows\n   to the east are candidates.\n * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list\n * strict - (optional) boolean, if true only consider windows at an angle between 45\u00b0 and -45\u00b0 on the\n   eastward axis\n\nReturns:\n * A list of `hs.window` objects representing all windows positioned east (i.e. right) of the window, in ascending order of distance\n\nNotes:\n * If you don't pass `candidateWindows`, Hammerspoon will query for the list of all visible windows\n   every time this method is called; this can be slow, and some undesired \"windows\" could be included\n   (see the notes for `hs.window.allWindows()`); consider using the equivalent methods in\n   `hs.window.filter` instead"
    },
    "Gets all windows to the north of this window": {
        "prefix": "hs.window:windowsToNorth([candidateWindows[, frontmost[, strict]]]) -> list of hs.window objects",
        "body": "hs.window:windowsToNorth(${1:[candidateWindows[}, ${2:frontmost[}, ${3:strict]]]})",
        "description": "Gets all windows to the north of this window\n\n(See `hs.window:windowsToEast()`)"
    },
    "Gets all windows to the south of this window": {
        "prefix": "hs.window:windowsToSouth([candidateWindows[, frontmost[, strict]]]) -> list of hs.window objects",
        "body": "hs.window:windowsToSouth(${1:[candidateWindows[}, ${2:frontmost[}, ${3:strict]]]})",
        "description": "Gets all windows to the south of this window\n\n(See `hs.window:windowsToEast()`)"
    },
    "Gets all windows to the west of this window": {
        "prefix": "hs.window:windowsToWest([candidateWindows[, frontmost[, strict]]]) -> list of hs.window objects",
        "body": "hs.window:windowsToWest(${1:[candidateWindows[}, ${2:frontmost[}, ${3:strict]]]})",
        "description": "Gets all windows to the west of this window\n\n(See `hs.window:windowsToEast()`)"
    },
    "Gets a rect-table for the location of the zoom button (the green button typically found at the top left of a window)": {
        "prefix": "hs.window:zoomButtonRect() -> rect-table or nil",
        "body": "hs.window:zoomButtonRect()",
        "description": "Gets a rect-table for the location of the zoom button (the green button typically found at the top left of a window)\n\nParameters:\n * None\n\nReturns:\n * A rect-table containing the bounding frame of the zoom button, or nil if an error occured\n\nNotes:\n * The co-ordinates in the rect-table (i.e. the `x` and `y` values) are in absolute co-ordinates, not relative to the window the button is part of, or the screen the window is on\n * Although not perfect as such, this method can provide a useful way to find a region of the titlebar suitable for simulating mouse click events on, with `hs.eventtap`"
    },
    "Sets the windowfilter to allow all visible windows belonging to a specific app": {
        "prefix": "hs.window.filter:allowApp(appname) -> hs.window.filter object",
        "body": "hs.window.filter:allowApp(${1:appname})",
        "description": "Sets the windowfilter to allow all visible windows belonging to a specific app\n\nParameters:\n * appname - app name as per `hs.application:name()`\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * this is just a convenience wrapper for `windowfilter:setAppFilter(appname,{visible=true})`"
    },
    "A table for window roles (as per `hs.window:subrole()`) that are allowed by default.": {
        "prefix": "hs.window.filter.allowedWindowRoles",
        "body": "hs.window.filter.allowedWindowRoles",
        "description": "A table for window roles (as per `hs.window:subrole()`) that are allowed by default.\n\nSet the desired window roles as *keys* in this table, like this: `hs.window.filter.allowedWindowRoles = {AXStandardWindow=true,AXDialog=true}`\n\nNotes:\n * You can have fine grained control of allowed window roles via the `setAppFilter`, `setDefaultFilter`, `setOverrideFilter` methods.\n * If you know what you're doing you can override the allowed window roles globally by changing this variable, but this is discouraged."
    },
    "Returns a copy of an hs.window.filter object that you can further restrict or expand": {
        "prefix": "hs.window.filter.copy(windowfilter[,logname[,loglevel]]) -> hs.window.filter object",
        "body": "hs.window.filter.copy(${1:windowfilter[},${2:logname[},${3:loglevel]]})",
        "description": "Returns a copy of an hs.window.filter object that you can further restrict or expand\n\nParameters:\n * windowfilter - an `hs.window.filter` object to copy\n * logname - (optional) name of the `hs.logger` instance for the new windowfilter; if omitted, the class logger will be used\n * loglevel - (optional) log level for the `hs.logger` instance for the new windowfilter"
    },
    "The default windowfilter; it filters apps whose windows are transient in nature so that you're unlikely (and often": {
        "prefix": "hs.window.filter.default",
        "body": "hs.window.filter.default",
        "description": "The default windowfilter; it filters apps whose windows are transient in nature so that you're unlikely (and often\nunable) to do anything with them, such as launchers, menulets, preference pane apps, screensavers, etc. It also\nfilters nonstandard and invisible windows.\n\nNotes:\n * While you can customize the default windowfilter, it's usually advisable to make your customizations on a local copy via `mywf=hs.window.filter.new()`;\n   the default windowfilter can potentially be used in several Hammerspoon modules and changing it might have unintended consequences.\n   Common customizations:\n   * to exclude fullscreen windows: `nofs_wf=hs.window.filter.new():setOverrideFilter{fullscreen=false}`\n   * to include invisible windows: `inv_wf=windowfilter.new():setDefaultFilter{}`\n * If you still want to alter the default windowfilter:\n   * you should probably apply your customizations at the top of your `init.lua`, or at any rate before instantiating any other windowfilter; this\n     way copies created via `hs.window.filter.new(nil,...)` will inherit your modifications\n   * to list the known exclusions: `hs.inspect(hs.window.filter.default:getFilters())` from the console\n   * to add an exclusion: `hs.window.filter.default:rejectApp'Cool New Launcher'`\n   * to add an app-specific rule: `hs.window.filter.default:setAppFilter('My IDE',1)`; ignore tooltips/code completion (empty title) in My IDE\n   * to remove an exclusion (e.g. if you want to have access to Spotlight windows): `hs.window.filter.default:allowApp'Spotlight'`;\n     for specialized uses you can make a specific windowfilter with `myfilter=hs.window.filter.new'Spotlight'`"
    },
    "A copy of the default windowfilter (see `hs.window.filter.default`) that only allows windows in the current": {
        "prefix": "hs.window.filter.defaultCurrentSpace",
        "body": "hs.window.filter.defaultCurrentSpace",
        "description": "A copy of the default windowfilter (see `hs.window.filter.default`) that only allows windows in the current\nMission Control Space\n\nNotes:\n * This windowfilter will inherit customizations to the default windowfilter if they're performed *before* referencing this"
    },
    "Convenience function to focus the nearest window to the east": {
        "prefix": "hs.window.filter.focusEast()",
        "body": "hs.window.filter.focusEast()",
        "description": "Convenience function to focus the nearest window to the east\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This is a convenience wrapper that performs `hs.window.filter.defaultCurrentSpace:focusWindowEast(nil,nil,true)`"
    },
    "Convenience function to focus the nearest window to the north": {
        "prefix": "hs.window.filter.focusNorth()",
        "body": "hs.window.filter.focusNorth()",
        "description": "Convenience function to focus the nearest window to the north\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This is a convenience wrapper that performs `hs.window.filter.defaultCurrentSpace:focusWindowNorth(nil,nil,true)`"
    },
    "Convenience function to focus the nearest window to the south": {
        "prefix": "hs.window.filter.focusSouth()",
        "body": "hs.window.filter.focusSouth()",
        "description": "Convenience function to focus the nearest window to the south\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This is a convenience wrapper that performs `hs.window.filter.defaultCurrentSpace:focusWindowSouth(nil,nil,true)`"
    },
    "Convenience function to focus the nearest window to the west": {
        "prefix": "hs.window.filter.focusWest()",
        "body": "hs.window.filter.focusWest()",
        "description": "Convenience function to focus the nearest window to the west\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This is a convenience wrapper that performs `hs.window.filter.defaultCurrentSpace:focusWindowWest(nil,nil,true)`"
    },
    "Focuses the nearest window to the east of a given window": {
        "prefix": "hs.window.filter:focusWindowEast(window, frontmost, strict)",
        "body": "hs.${1:window}.filter:focusWindowEast(window, ${2:frontmost}, ${3:strict})",
        "description": "Focuses the nearest window to the east of a given window\n\nParameters:\n * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used\n * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window in this windowfilter\n * strict - (optional) boolean, if true only consider windows at an angle between 45\u00b0 and -45\u00b0 on the\n   eastward axis\n\nReturns:\n * None\n\nNotes:\n * This is a convenience wrapper that performs `hs.window.focusWindowEast(window,self:getWindows(),...)`\n * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call"
    },
    "Focuses the nearest window to the south of a given window": {
        "prefix": "hs.window.filter:focusWindowNorth(window, frontmost, strict)",
        "body": "hs.${1:window}.filter:focusWindowNorth(window, ${2:frontmost}, ${3:strict})",
        "description": "Focuses the nearest window to the south of a given window\n\nParameters:\n * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used\n * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window in this windowfilter\n * strict - (optional) boolean, if true only consider windows at an angle between 45\u00b0 and -45\u00b0 on the\n   southward axis\n\nReturns:\n * None\n\nNotes:\n * This is a convenience wrapper that performs `hs.window.focusWindowNorth(window,self:getWindows(),...)`\n * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call"
    },
    "Focuses the nearest window to the north of a given window": {
        "prefix": "hs.window.filter:focusWindowSouth(window, frontmost, strict)",
        "body": "hs.${1:window}.filter:focusWindowSouth(window, ${2:frontmost}, ${3:strict})",
        "description": "Focuses the nearest window to the north of a given window\n\nParameters:\n * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used\n * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window in this windowfilter\n * strict - (optional) boolean, if true only consider windows at an angle between 45\u00b0 and -45\u00b0 on the\n   northward axis\n\nReturns:\n * None\n\nNotes:\n * This is a convenience wrapper that performs `hs.window.focusWindowSouth(window,self:getWindows(),...)`\n * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call"
    },
    "Focuses the nearest window to the west of a given window": {
        "prefix": "hs.window.filter:focusWindowWest(window, frontmost, strict)",
        "body": "hs.${1:window}.filter:focusWindowWest(window, ${2:frontmost}, ${3:strict})",
        "description": "Focuses the nearest window to the west of a given window\n\nParameters:\n * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used\n * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window in this windowfilter\n * strict - (optional) boolean, if true only consider windows at an angle between 45\u00b0 and -45\u00b0 on the westward axis\n\nReturns:\n * None\n\nNotes:\n * This is a convenience wrapper that performs `hs.window.focusWindowWest(window,self:getWindows(),...)`\n * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call"
    },
    "Tells all windowfilters whether to refresh all windows when the user switches to a different Mission Control Space.": {
        "prefix": "hs.window.filter.forceRefreshOnSpaceChange",
        "body": "hs.window.filter.forceRefreshOnSpaceChange",
        "description": "Tells all windowfilters whether to refresh all windows when the user switches to a different Mission Control Space.\n\nDue to OS X limitations Hammerspoon cannot directly query for windows in Spaces other than the current one;\ntherefore when a windowfilter is initially instantiated, it doesn't know about many of these windows.\n\nIf this variable is set to `true`, windowfilters will re-query applications for all their windows whenever a Space change\nby the user is detected, therefore any existing windows in that Space that were not yet being tracked will become known at that point;\nif `false` (the default) this won't happen, but the windowfilters will *eventually* learn about these windows\nanyway, as soon as they're interacted with.\n\nIf you need your windowfilters to become aware of windows across all Spaces as soon as possible, you can set this to `true`,\nbut you'll incur a modest performance penalty on every Space change. If possible, use the `hs.window.filter.switchedToSpace()`\ncallback instead.\n\nNotes:\n * If you defined one or more Spaces-aware windowfilters (i.e. when the `currentSpace` field of a filter is present), windows need refreshing at every space change anyway, so this variable is ignored"
    },
    "Return a table with all the filtering rules defined for this windowfilter": {
        "prefix": "hs.window.filter:getFilters() -> table",
        "body": "hs.window.filter:getFilters()",
        "description": "Return a table with all the filtering rules defined for this windowfilter\n\nParameters:\n * None\n\nReturns:\n * a table containing the filtering rules of this windowfilter; you can pass this table (optionally\n after performing valid manipulations) to `hs.window.filter:setFilters()` and `hs.window.filter.new()`"
    },
    "Gets the current windows allowed by this windowfilter": {
        "prefix": "hs.window.filter:getWindows([sortOrder]) -> list of hs.window objects",
        "body": "hs.window.filter:getWindows(${1:[sortOrder]})",
        "description": "Gets the current windows allowed by this windowfilter\n\nParameters:\n * sortOrder - (optional) one of the `hs.window.filter.sortBy...` constants to determine the sort order\n   of the returned list; if omitted, uses the windowfilter's sort order as per `hs.window.filter:setSortOrder()`\n  (defaults to `sortByFocusedLast`)\n\nReturns:\n * a list of `hs.window` objects"
    },
    "Pseudo-event for `hs.window.filter:subscribe()`: the windowfilter now rejects all windows": {
        "prefix": "hs.window.filter.hasNoWindows",
        "body": "hs.window.filter.hasNoWindows",
        "description": "Pseudo-event for `hs.window.filter:subscribe()`: the windowfilter now rejects all windows\n\nNotes:\n * callbacks for this event will receive (as the first argument) the last window that was allowed (and is now rejected)\n * this pseudo-event won't trigger again until after the windowfilter allows at least one window\n * this pseudo-event will be emitted *after* the *actual* event(s) (e.g. `windowDestroyed`) that caused the window to be rejected"
    },
    "Pseudo-event for `hs.window.filter:subscribe()`: the windowfilter now allows one window": {
        "prefix": "hs.window.filter.hasWindow",
        "body": "hs.window.filter.hasWindow",
        "description": "Pseudo-event for `hs.window.filter:subscribe()`: the windowfilter now allows one window\n\nNotes:\n * callbacks for this event will receive (as the first argument) the window that is now allowed\n * this pseudo-event won't trigger again until after the windowfilter reverts to rejecting all windows\n * this pseudo-event will be emitted *after* the *actual* event(s) (e.g. `windowCreated`) that caused a window to be allowed"
    },
    "A table of application names (as per `hs.application:name()`) that are always ignored by this module.": {
        "prefix": "hs.window.filter.ignoreAlways",
        "body": "hs.window.filter.ignoreAlways",
        "description": "A table of application names (as per `hs.application:name()`) that are always ignored by this module.\nThese are apps with no windows or any visible GUI, such as system services, background daemons and \"helper\" apps.\n\nYou can add an app to this table with `hs.window.filter.ignoreAlways['Background App Title'] = true`\n\nNotes:\n * As the name implies, even the empty, \"allow all\" windowfilter will ignore these apps.\n * You don't *need* to keep this table up to date, since non GUI apps will simply never show up anywhere; this table is just used as a \"root\" filter to gain a (very small) performance improvement."
    },
    "Checks if an app is allowed by the windowfilter": {
        "prefix": "hs.window.filter:isAppAllowed(appname) -> boolean",
        "body": "hs.window.filter:isAppAllowed(${1:appname})",
        "description": "Checks if an app is allowed by the windowfilter\n\nParameters:\n * appname - app name as per `hs.application:name()`\n\nReturns:\n * `false` if the app is rejected by the windowfilter; `true` otherwise"
    },
    "Checks whether an app is a known non-GUI app, as per `hs.window.filter.ignoreAlways`": {
        "prefix": "hs.window.filter.isGuiApp(appname) -> boolean",
        "body": "hs.window.filter.isGuiApp(${1:appname})",
        "description": "Checks whether an app is a known non-GUI app, as per `hs.window.filter.ignoreAlways`\n\nParameters:\n * appname - name of the app to check as per `hs.application:name()`\n\nReturns:\n * `false` if the app is a known non-GUI (or not accessible) app; `true` otherwise"
    },
    "Checks if a window is allowed by the windowfilter": {
        "prefix": "hs.window.filter:isWindowAllowed(window) -> boolean",
        "body": "hs.${1:window}.filter:isWindowAllowed(window)",
        "description": "Checks if a window is allowed by the windowfilter\n\nParameters:\n * window - an `hs.window` object to check\n\nReturns:\n * `true` if the window is allowed by the windowfilter, `false` otherwise; `nil` if an invalid object was passed"
    },
    "Creates a new hs.window.filter instance": {
        "prefix": "hs.window.filter.new(fn[,logname[,loglevel]]) -> hs.window.filter object",
        "body": "hs.window.filter.new(${1:fn[},${2:logname[},${3:loglevel]]})",
        "description": "Creates a new hs.window.filter instance\n\nParameters:\n * fn\n   * if `nil`, returns a copy of the default windowfilter, including any customizations you might have applied to it\n     so far; you can then further restrict or expand it\n   * if `true`, returns an empty windowfilter that allows every window\n   * if `false`, returns a windowfilter with a default rule to reject every window\n   * if a string or table of strings, returns a windowfilter that only allows visible windows of the specified apps\n     as per `hs.application:name()`\n   * if a table, you can fully define a windowfilter without having to call any methods after construction; the\n     table must be structured as per `hs.window.filter:setFilters()`; if not specified in the table, the\n     default filter in the new windowfilter will reject all windows\n   * otherwise it must be a function that accepts an `hs.window` object and returns `true` if the window is allowed\n     or `false` otherwise; this way you can define a fully custom windowfilter\n * logname - (optional) name of the `hs.logger` instance for the new windowfilter; if omitted, the class logger will be used\n * loglevel - (optional) log level for the `hs.logger` instance for the new windowfilter\n\nReturns:\n * a new windowfilter instance"
    },
    "Stops the windowfilter event subscriptions; no more event callbacks will be triggered, but the subscriptions remain intact for a subsequent call to `hs.window.filter:resume()`": {
        "prefix": "hs.window.filter:pause() -> hs.window.filter object",
        "body": "hs.window.filter:pause()",
        "description": "Stops the windowfilter event subscriptions; no more event callbacks will be triggered, but the subscriptions remain intact for a subsequent call to `hs.window.filter:resume()`\n\nParameters:\n * None\n\nReturns:\n * the `hs.window.filter` object for method chaining"
    },
    "Sets the windowfilter to outright reject any windows belonging to a specific app": {
        "prefix": "hs.window.filter:rejectApp(appname) -> hs.window.filter object",
        "body": "hs.window.filter:rejectApp(${1:appname})",
        "description": "Sets the windowfilter to outright reject any windows belonging to a specific app\n\nParameters:\n * appname - app name as per `hs.application:name()`\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * this is just a convenience wrapper for `windowfilter:setAppFilter(appname,false)`"
    },
    "Resumes the windowfilter event subscriptions": {
        "prefix": "hs.window.filter:resume() -> hs.window.filter object",
        "body": "hs.window.filter:resume()",
        "description": "Resumes the windowfilter event subscriptions\n\nParameters:\n * None\n\nReturns:\n * the `hs.window.filter` object for method chaining"
    },
    "Sets the detailed filtering rules for the windows of a specific app": {
        "prefix": "hs.window.filter:setAppFilter(appname, filter) -> hs.window.filter object",
        "body": "hs.window.${2:filter}:setAppFilter(${1:appname}, filter)",
        "description": "Sets the detailed filtering rules for the windows of a specific app\n\nParameters:\n * appname - app name as per `hs.application:name()`\n * filter - if `false`, reject the app; if `true`, `nil`, or omitted, allow all visible windows (in any Space) for the app; otherwise it must be a table describing the filtering rules for the app, via the following fields:\n   * visible - if `true`, only allow visible windows (in any Space); if `false`, reject visible windows; if omitted, this rule is ignored\n   * currentSpace - if `true`, only allow windows in the current Mission Control Space (minimized and hidden windows are included, as they're considered to belong to all Spaces); if `false`, reject windows in the current Space (including all minimized and hidden windows); if omitted, this rule is ignored\n   * fullscreen - if `true`, only allow fullscreen windows; if `false`, reject fullscreen windows; if omitted, this rule is ignored\n   * hasTitlebar - if `true`, only allow windows with titlebar; if `false`, reject window with titlebar; if omitted, this rule is ignored\n   * focused - if `true`, only allow a window while focused; if `false`, reject the focused window; if omitted, this rule is ignored\n   * activeApplication - only allow any of this app's windows while it is (if `true`) or it's not (if `false`) the active application; if omitted, this rule is ignored\n   * allowTitles\n     * if a number, only allow windows whose title is at least as many characters long; e.g. pass `1` to filter windows with an empty title\n     * if a string or table of strings, only allow windows whose title matches (one of) the pattern(s) as per `string.match`\n     * if omitted, this rule is ignored\n   * rejectTitles - if a string or table of strings, reject windows whose titles matches (one of) the pattern(s) as per `string.match`; if omitted, this rule is ignored\n   * allowRegions - an `hs.geometry` rect or constructor argument, or a list of them, designating (a) screen \"region(s)\" in absolute coordinates: only allow windows that \"cover\" at least 50% of (one of) the region(s), and/or windows that have at least 50% of their surface inside (one of) the region(s); if omitted, this rule is ignored\n   * rejectRegions - an `hs.geometry` rect or constructor argument, or a list of them, designating (a) screen \"region(s)\" in absolute coordinates: reject windows that \"cover\" at least 50% of (one of) the region(s), and/or windows that have at least 50% of their surface inside (one of) the region(s); if omitted, this rule is ignored\n   * allowScreens - a valid argument for `hs.screen.find()`, or a list of them, indicating one (or more) screen(s): only allow windows that (mostly) lie on (one of) the screen(s); if omitted, this rule is ignored\n   * rejectScreens - a valid argument for `hs.screen.find()`, or a list of them, indicating one (or more) screen(s): reject windows that (mostly) lie on (one of) the screen(s); if omitted, this rule is ignored\n   * allowRoles\n     * if a string or table of strings, only allow these window roles as per `hs.window:subrole()`\n     * if the special string `'*'`, this rule is ignored (i.e. all window roles, including empty ones, are allowed)\n     * if omitted, use the default allowed roles (defined in `hs.window.filter.allowedWindowRoles`)\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * Passing `focused=true` in `filter` will (naturally) result in the windowfilter ever allowing 1 window at most\n * If you want to allow *all* windows for an app, including invisible ones, pass an empty table for `filter`\n * Spaces-aware windowfilters might experience a (sometimes significant) delay after every Space switch, since (due to OS X limitations) they must re-query for the list of all windows in the current Space every time.\n * If System Preferences>Mission Control>Displays have separate Spaces is *on*, the *current Space* is defined as the union of all the Spaces that are currently visible\n * This table explains the effects of different combinations of `visible` and `currentSpace`, showing which windows will be allowed:\n```\n             |visible=         nil                      |             true             |     false    |\n|currentSpace|------------------------------------------|------------------------------|--------------|\n|     nil    |all                                       |visible in ANY space          |min and hidden|\n|    true    |visible in CURRENT space+min and hidden   |visible in CURRENT space      |min and hidden|\n|    false   |visible in OTHER space only+min and hidden|visible in OTHER space only   |none          |\n```"
    },
    "Sets whether the windowfilter should only allow (or reject) windows in the current Mission Control Space": {
        "prefix": "hs.window.filter:setCurrentSpace(val) -> hs.window.filter object",
        "body": "hs.window.filter:setCurrentSpace(${1:val})",
        "description": "Sets whether the windowfilter should only allow (or reject) windows in the current Mission Control Space\n\nParameters:\n * val - boolean; if `true`, only allow windows in the current Mission Control Space, plus minimized and hidden windows;\n   if `false`, reject them; if `nil`, ignore Mission Control Spaces\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * This is just a convenience wrapper for setting the `currentSpace` field in the `override` filter (other\n   fields will be left untouched); per-app filters will maintain their `currentSpace` field, if present, as is\n * Spaces-aware windowfilters might experience a (sometimes significant) delay after every Space switch, since\n   (due to OS X limitations) they must re-query for the list of all windows in the current Space every time."
    },
    "Set the default filtering rules to be used for apps without app-specific rules": {
        "prefix": "hs.window.filter:setDefaultFilter(filter) -> hs.window.filter object",
        "body": "hs.window.${1:filter}:setDefaultFilter(filter)",
        "description": "Set the default filtering rules to be used for apps without app-specific rules\n\nParameters:\n  * filter - see `hs.window.filter:setAppFilter`\n\nReturns:\n * the `hs.window.filter` object for method chaining"
    },
    "Sets multiple filtering rules": {
        "prefix": "hs.window.filter:setFilters(filters) -> hs.window.filter object",
        "body": "hs.window.filter:setFilters(${1:filters})",
        "description": "Sets multiple filtering rules\n\nParameters:\n * filters - table, every element will set an application filter; these elements must:\n   - have a *key* of type string, denoting an application name as per `hs.application:name()`\n   - if the *value* is a boolean, the app will be allowed or rejected accordingly - see `hs.window.filter:allowApp()`\n     and `hs.window.filter:rejectApp()`\n   - if the *value* is a table, it must contain the accept/reject rules for the app *as key/value pairs*; valid keys\n     and values are described in `hs.window.filter:setAppFilter()`\n   - the key can be one of the special strings `\"default\"` and `\"override\"`, which will will set the default and override\n     filter respectively\n   - the key can be the special string `\"sortOrder\"`; the value must be one of the `sortBy...` constants as per\n     `hs.window.filter:setSortOrder()`\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * every filter definition in `filters` will overwrite the pre-existing one for the relevant application, if present;\n   this also applies to the special default and override filters, if included"
    },
    "Set overriding filtering rules that will be applied for all apps before any app-specific rules": {
        "prefix": "hs.window.filter:setOverrideFilter(filter) -> hs.window.filter object",
        "body": "hs.window.${1:filter}:setOverrideFilter(filter)",
        "description": "Set overriding filtering rules that will be applied for all apps before any app-specific rules\n\nParameters:\n  * filter - see `hs.window.filter:setAppFilter`\n\nReturns:\n * the `hs.window.filter` object for method chaining"
    },
    "Sets the allowed screen regions for this windowfilter": {
        "prefix": "hs.window.filter:setRegions(regions) -> hs.window.filter object",
        "body": "hs.window.filter:setRegions(${1:regions})",
        "description": "Sets the allowed screen regions for this windowfilter\n\nParameters:\n * regions - an `hs.geometry` rect or constructor argument, or a list of them, indicating the allowed region(s) for this windowfilter\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * This is just a convenience wrapper for setting the `allowRegions` field in the `override` filter (other fields will be left untouched); per-app filters will maintain their `allowRegions` and `rejectRegions` fields, if present"
    },
    "Sets the allowed screens for this windowfilter": {
        "prefix": "hs.window.filter:setScreens(screens) -> hs.window.filter object",
        "body": "hs.window.filter:setScreens(${1:screens})",
        "description": "Sets the allowed screens for this windowfilter\n\nParameters:\n * regions - a valid argument for `hs.screen.find()`, or a list of them, indicating the allowed screen(s) for this windowfilter\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * This is just a convenience wrapper for setting the `allowScreens` field in the `override` filter (other\n   fields will be left untouched); per-app filters will maintain their `allowScreens` and `rejectScreens` fields, if present"
    },
    "Sets the sort order for this windowfilter's `:getWindows()` method": {
        "prefix": "hs.window.filter:setSortOrder(sortOrder) -> hs.window.filter object",
        "body": "hs.window.filter:setSortOrder(${1:sortOrder})",
        "description": "Sets the sort order for this windowfilter's `:getWindows()` method\n\nParameters:\n  * sortOrder - one of the `hs.window.filter.sortBy...` constants\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n  * The default sort order for all windowfilters (that is, until changed by this method) is `hs.window.filter.sortByFocusedLast`"
    },
    "Sort order for `hs.window.filter:getWindows()`: windows are sorted in order of creation, oldest first (see also `hs.window.filter:setSortOrder()`)": {
        "prefix": "hs.window.filter.sortByCreated",
        "body": "hs.window.filter.sortByCreated",
        "description": "Sort order for `hs.window.filter:getWindows()`: windows are sorted in order of creation, oldest first (see also `hs.window.filter:setSortOrder()`)"
    },
    "Sort order for `hs.window.filter:getWindows()`: windows are sorted in order of creation, newest first (see also `hs.window.filter:setSortOrder()`)": {
        "prefix": "hs.window.filter.sortByCreatedLast",
        "body": "hs.window.filter.sortByCreatedLast",
        "description": "Sort order for `hs.window.filter:getWindows()`: windows are sorted in order of creation, newest first (see also `hs.window.filter:setSortOrder()`)"
    },
    "Sort order for `hs.window.filter:getWindows()`: windows are sorted in order of focus received, least recently first (see also `hs.window.filter:setSortOrder()`)": {
        "prefix": "hs.window.filter.sortByFocused",
        "body": "hs.window.filter.sortByFocused",
        "description": "Sort order for `hs.window.filter:getWindows()`: windows are sorted in order of focus received, least recently first (see also `hs.window.filter:setSortOrder()`)"
    },
    "Sort order for `hs.window.filter:getWindows()`: windows are sorted in order of focus received, most recently first (see also `hs.window.filter:setSortOrder()`)": {
        "prefix": "hs.window.filter.sortByFocusedLast",
        "body": "hs.window.filter.sortByFocusedLast",
        "description": "Sort order for `hs.window.filter:getWindows()`: windows are sorted in order of focus received, most recently first (see also `hs.window.filter:setSortOrder()`)\n\nNotes:\n  * This is the default sort order for all windowfilters"
    },
    "Subscribe to one or more events on the allowed windows": {
        "prefix": "hs.window.filter:subscribe(event, fn[, immediate]) -> hs.window.filter object",
        "body": "hs.window.filter:subscribe(${1:event}, ${2:fn[}, ${3:immediate]})",
        "description": "Subscribe to one or more events on the allowed windows\n\nParameters:\n * event - string or list of strings, the event(s) to subscribe to (see the `hs.window.filter` constants); alternatively, this can be a map `{event1=fn1,event2=fn2,...}`: fnN will be subscribed to eventN, and the parameter `fn` will be ignored\n * fn - function or list of functions, the callback(s) to add for the event(s); each will be passed 3 parameters\n   * a `hs.window` object referring to the event's window\n   * a string containing the application name (`window:application():name()`) for convenience\n   * a string containing the event that caused the callback, i.e. (one of) the event(s) you subscribed to\n * immediate - (optional) if `true`, also call all the callbacks immediately for windows that satisfy the event(s) criteria\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * Passing lists means that *all* the `fn`s will be called when *any* of the `event`s fires, so it's *not* a shortcut for subscribing distinct callbacks to distinct events; use a map or chained `:subscribe` calls for that.\n * Use caution with `immediate`: if for example you're subscribing to `hs.window.filter.windowUnfocused`, `fn`(s) will be called for *all* the windows except the currently focused one.\n * If the windowfilter was paused with `hs.window.filter:pause()`, calling this will resume it."
    },
    "Callback to inform all windowfilters that the user initiated a switch to a (numbered) Mission Control Space.": {
        "prefix": "hs.window.filter.switchedToSpace(space)",
        "body": "hs.window.filter.switchedToSpace(${1:space})",
        "description": "Callback to inform all windowfilters that the user initiated a switch to a (numbered) Mission Control Space.\n\nSee `hs.window.filter.forceRefreshOnSpaceChange` for an overview of Spaces limitations in Hammerspoon. If you\noften (or always) change Space via the \"numbered\" Mission Control keyboard shortcuts (by default, `ctrl-1` etc.), you\ncan call this function from your `init.lua` when intercepting these shortcuts; for example:\n```\nhs.hotkey.bind('ctrl','1',nil,function()hs.window.filter.switchedToSpace(1)end)\nhs.hotkey.bind('ctrl','2',nil,function()hs.window.filter.switchedToSpace(2)end)\n-- etc.\n```\nUsing this callback results in slightly better performance than setting `forceRefreshOnSpaceChange` to `true`, since\nalready visited Spaces are remembered and no refreshing is necessary when switching back to those.\n\nParameters:\n * space - the Space number the user is switching to\n\nReturns:\n* None\n\nNotes:\n * Only use this function if \"Displays have separate Spaces\" and \"Automatically rearrange Spaces\" are OFF in System Preferences>Mission Control\n * Calling this function will set `hs.window.filter.forceRefreshOnSpaceChange` to `false`\n * If you defined one or more Spaces-aware windowfilters (i.e. when the `currentSpace` field of a filter is present), windows need refreshing at every space change anyway, so using this callback will not result in improved performance"
    },
    "Removes one or more event subscriptions": {
        "prefix": "hs.window.filter:unsubscribe([event][, fn]) -> hs.window.filter object",
        "body": "hs.window.filter:unsubscribe(${1:[event][}, ${2:fn]})",
        "description": "Removes one or more event subscriptions\n\nParameters:\n * event - string or list of strings, the event(s) to unsubscribe; if omitted, `fn`(s) will be unsubscribed from all events;\n   alternatively, this can be a map `{event1=fn1,event2=fn2,...}`: fnN will be unsubscribed from eventN, and the parameter `fn` will be ignored\n * fn - function or list of functions, the callback(s) to remove; if omitted, all callbacks will be unsubscribed from `event`(s)\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * You must pass at least one of `event` or `fn`\n * If calling this on the default (or any other shared use) windowfilter, do not pass events, as that would remove\n   *all* the callbacks for the events including ones subscribed elsewhere that you might not be aware of. You should\n   instead keep references to your functions and pass in those."
    },
    "Removes all event subscriptions": {
        "prefix": "hs.window.filter:unsubscribeAll() -> hs.window.filter object",
        "body": "hs.window.filter:unsubscribeAll()",
        "description": "Removes all event subscriptions\n\nParameters:\n * None\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * You should not use this on the default windowfilter or other shared-use windowfilters"
    },
    "Pseudo-event for `hs.window.filter:subscribe()`: a previously rejected window (or a newly created one) is now allowed": {
        "prefix": "hs.window.filter.windowAllowed",
        "body": "hs.window.filter.windowAllowed",
        "description": "Pseudo-event for `hs.window.filter:subscribe()`: a previously rejected window (or a newly created one) is now allowed\n\nNotes:\n * this pseudo-event will be emitted *before* the *actual* event(s) (e.g. `windowCreated`) that caused the window to be allowed"
    },
    "Event for `hs.window.filter:subscribe()`: a new window was created": {
        "prefix": "hs.window.filter.windowCreated",
        "body": "hs.window.filter.windowCreated",
        "description": "Event for `hs.window.filter:subscribe()`: a new window was created"
    },
    "Event for `hs.window.filter:subscribe()`: a window was destroyed": {
        "prefix": "hs.window.filter.windowDestroyed",
        "body": "hs.window.filter.windowDestroyed",
        "description": "Event for `hs.window.filter:subscribe()`: a window was destroyed"
    },
    "Event for `hs.window.filter:subscribe()`: a window received focus": {
        "prefix": "hs.window.filter.windowFocused",
        "body": "hs.window.filter.windowFocused",
        "description": "Event for `hs.window.filter:subscribe()`: a window received focus"
    },
    "Event for `hs.window.filter:subscribe()`: a window was expanded to fullscreen": {
        "prefix": "hs.window.filter.windowFullscreened",
        "body": "hs.window.filter.windowFullscreened",
        "description": "Event for `hs.window.filter:subscribe()`: a window was expanded to fullscreen"
    },
    "Event for `hs.window.filter:subscribe()`: a window was hidden (its app was hidden, e.g. via `cmd-h`)": {
        "prefix": "hs.window.filter.windowHidden",
        "body": "hs.window.filter.windowHidden",
        "description": "Event for `hs.window.filter:subscribe()`: a window was hidden (its app was hidden, e.g. via `cmd-h`)"
    },
    "Event for `hs.window.filter:subscribe()`: a window is now in the current Mission Control Space, due to": {
        "prefix": "hs.window.filter.windowInCurrentSpace",
        "body": "hs.window.filter.windowInCurrentSpace",
        "description": "Event for `hs.window.filter:subscribe()`: a window is now in the current Mission Control Space, due to\na Space switch or because it was hidden or minimized (hidden and minimized windows belong to all Spaces)"
    },
    "Event for `hs.window.filter:subscribe()`: a window was minimized": {
        "prefix": "hs.window.filter.windowMinimized",
        "body": "hs.window.filter.windowMinimized",
        "description": "Event for `hs.window.filter:subscribe()`: a window was minimized"
    },
    "Event for `hs.window.filter:subscribe()`: a window was moved or resized, including toggling fullscreen/maximize": {
        "prefix": "hs.window.filter.windowMoved",
        "body": "hs.window.filter.windowMoved",
        "description": "Event for `hs.window.filter:subscribe()`: a window was moved or resized, including toggling fullscreen/maximize"
    },
    "Event for `hs.window.filter:subscribe()`: a window that used to be in the current Mission Control Space isn't anymore,": {
        "prefix": "hs.window.filter.windowNotInCurrentSpace",
        "body": "hs.window.filter.windowNotInCurrentSpace",
        "description": "Event for `hs.window.filter:subscribe()`: a window that used to be in the current Mission Control Space isn't anymore,\ndue to a Space switch or because it was unhidden or unminimized onto another Space"
    },
    "Event for `hs.window.filter:subscribe()`: a window is no longer *actually* visible on any screen because it was minimized, closed,": {
        "prefix": "hs.window.filter.windowNotOnScreen",
        "body": "hs.window.filter.windowNotOnScreen",
        "description": "Event for `hs.window.filter:subscribe()`: a window is no longer *actually* visible on any screen because it was minimized, closed,\nits application was hidden (e.g. via cmd-h) or closed, or because it's not in the current Mission Control Space anymore"
    },
    "Event for `hs.window.filter:subscribe()`: a window is no longer \"visible\" (in *any* Mission Control Space, as per `hs.window:isVisible()`)": {
        "prefix": "hs.window.filter.windowNotVisible",
        "body": "hs.window.filter.windowNotVisible",
        "description": "Event for `hs.window.filter:subscribe()`: a window is no longer \"visible\" (in *any* Mission Control Space, as per `hs.window:isVisible()`)\nbecause it was minimized or closed, or its application was hidden (e.g. via `cmd-h`) or closed"
    },
    "Event for `hs.window.filter:subscribe()`: a window became *actually* visible on screen (i.e. it's \"visible\" as per `hs.window:isVisible()`": {
        "prefix": "hs.window.filter.windowOnScreen",
        "body": "hs.window.filter.windowOnScreen",
        "description": "Event for `hs.window.filter:subscribe()`: a window became *actually* visible on screen (i.e. it's \"visible\" as per `hs.window:isVisible()`\n*and* in the current Mission Control Space) after having been not visible, or when created"
    },
    "Pseudo-event for `hs.window.filter:subscribe()`: a previously allowed window (or a window that's been destroyed) is now rejected": {
        "prefix": "hs.window.filter.windowRejected",
        "body": "hs.window.filter.windowRejected",
        "description": "Pseudo-event for `hs.window.filter:subscribe()`: a previously allowed window (or a window that's been destroyed) is now rejected\n\nNotes:\n * this pseudo-event will be emitted *after* the *actual* event(s) (e.g. `windowDestroyed`) that caused the window to be rejected"
    },
    "Pseudo-event for `hs.window.filter:subscribe()`: the list of allowed windows (as per `windowfilter:getWindows()`) has changed": {
        "prefix": "hs.window.filter.windowsChanged",
        "body": "hs.window.filter.windowsChanged",
        "description": "Pseudo-event for `hs.window.filter:subscribe()`: the list of allowed windows (as per `windowfilter:getWindows()`) has changed\n\nNotes:\n * callbacks for this event will receive (as the first argument) either a random window among the currently allowed ones,\n   or nil if the windowfilter is rejecting all windows\n * similarly, the second argument passed to callbacks (window's app name) will be nil if the windowfilter is rejecting all windows\n * this pseudo-event will be emitted *after* the *actual* event(s) that caused the list of allowed windows to change"
    },
    "Gets all visible windows allowed by this windowfilter that lie to the east a given window": {
        "prefix": "hs.window.filter:windowsToEast(window, frontmost, strict) -> list of `hs.window` objects",
        "body": "hs.${1:window}.filter:windowsToEast(window, ${2:frontmost}, ${3:strict})",
        "description": "Gets all visible windows allowed by this windowfilter that lie to the east a given window\n\nParameters:\n * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used\n * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list\n * strict - (optional) boolean, if true only consider windows at an angle between 45\u00b0 and -45\u00b0 on the\n   eastward axis\n\nReturns:\n * A list of `hs.window` objects representing all windows positioned east (i.e. right) of the window, in ascending order of distance\n\nNotes:\n * This is a convenience wrapper that returns `hs.window.windowsToEast(window,self:getWindows(),...)`\n * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call (or just use\n   `hs.window.filter.defaultCurrentSpace`)"
    },
    "Gets all visible windows allowed by this windowfilter that lie to the north a given window": {
        "prefix": "hs.window.filter:windowsToNorth(window, frontmost, strict) -> list of `hs.window` objects",
        "body": "hs.${1:window}.filter:windowsToNorth(window, ${2:frontmost}, ${3:strict})",
        "description": "Gets all visible windows allowed by this windowfilter that lie to the north a given window\n\nParameters:\n * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used\n * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list\n * strict - (optional) boolean, if true only consider windows at an angle between 45\u00b0 and -45\u00b0 on the\n   northward axis\n\nReturns:\n * A list of `hs.window` objects representing all windows positioned north (i.e. up) of the window, in ascending order of distance\n\nNotes:\n * This is a convenience wrapper that returns `hs.window.windowsToNorth(window,self:getWindows(),...)`\n * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call (or just use\n   `hs.window.filter.defaultCurrentSpace`)"
    },
    "Gets all visible windows allowed by this windowfilter that lie to the south a given window": {
        "prefix": "hs.window.filter:windowsToSouth(window, frontmost, strict) -> list of `hs.window` objects",
        "body": "hs.${1:window}.filter:windowsToSouth(window, ${2:frontmost}, ${3:strict})",
        "description": "Gets all visible windows allowed by this windowfilter that lie to the south a given window\n\nParameters:\n * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used\n * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list\n * strict - (optional) boolean, if true only consider windows at an angle between 45\u00b0 and -45\u00b0 on the\n   southward axis\n\nReturns:\n * A list of `hs.window` objects representing all windows positioned south (i.e. down) of the window, in ascending order of distance\n\nNotes:\n * This is a convenience wrapper that returns `hs.window.windowsToSouth(window,self:getWindows(),...)`\n * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call (or just use\n   `hs.window.filter.defaultCurrentSpace`)"
    },
    "Gets all visible windows allowed by this windowfilter that lie to the west a given window": {
        "prefix": "hs.window.filter:windowsToWest(window, frontmost, strict) -> list of `hs.window` objects",
        "body": "hs.${1:window}.filter:windowsToWest(window, ${2:frontmost}, ${3:strict})",
        "description": "Gets all visible windows allowed by this windowfilter that lie to the west a given window\n\nParameters:\n * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used\n * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list\n * strict - (optional) boolean, if true only consider windows at an angle between 45\u00b0 and -45\u00b0 on the westward axis\n\nReturns:\n * A list of `hs.window` objects representing all windows positioned west (i.e. left) of the window, in ascending order of distance\n\nNotes:\n * This is a convenience wrapper that returns `hs.window.windowsToWest(window,self:getWindows(),...)`\n * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call (or just use `hs.window.filter.defaultCurrentSpace`)"
    },
    "Event for `hs.window.filter:subscribe()`: a window's title changed": {
        "prefix": "hs.window.filter.windowTitleChanged",
        "body": "hs.window.filter.windowTitleChanged",
        "description": "Event for `hs.window.filter:subscribe()`: a window's title changed"
    },
    "Event for `hs.window.filter:subscribe()`: a window lost focus": {
        "prefix": "hs.window.filter.windowUnfocused",
        "body": "hs.window.filter.windowUnfocused",
        "description": "Event for `hs.window.filter:subscribe()`: a window lost focus"
    },
    "Event for `hs.window.filter:subscribe()`: a window was reverted back from fullscreen": {
        "prefix": "hs.window.filter.windowUnfullscreened",
        "body": "hs.window.filter.windowUnfullscreened",
        "description": "Event for `hs.window.filter:subscribe()`: a window was reverted back from fullscreen"
    },
    "Event for `hs.window.filter:subscribe()`: a window was unhidden (its app was unhidden, e.g. via `cmd-h`)": {
        "prefix": "hs.window.filter.windowUnhidden",
        "body": "hs.window.filter.windowUnhidden",
        "description": "Event for `hs.window.filter:subscribe()`: a window was unhidden (its app was unhidden, e.g. via `cmd-h`)"
    },
    "Event for `hs.window.filter:subscribe()`: a window was unminimized": {
        "prefix": "hs.window.filter.windowUnminimized",
        "body": "hs.window.filter.windowUnminimized",
        "description": "Event for `hs.window.filter:subscribe()`: a window was unminimized"
    },
    "Event for `hs.window.filter:subscribe()`: a window became \"visible\" (in *any* Mission Control Space, as per `hs.window:isVisible()`)": {
        "prefix": "hs.window.filter.windowVisible",
        "body": "hs.window.filter.windowVisible",
        "description": "Event for `hs.window.filter:subscribe()`: a window became \"visible\" (in *any* Mission Control Space, as per `hs.window:isVisible()`)\nafter having been hidden or minimized, or if it was just created"
    },
    "Starts the module": {
        "prefix": "hs.window.highlight.start([windowfilterIsolate[, windowfilterOverlay]])",
        "body": "hs.window.highlight.start(${1:[windowfilterIsolate[}, ${2:windowfilterOverlay]]})",
        "description": "Starts the module\n\nParameters:\n * windowfilterIsolate - (optional) an `hs.window.filter` instance that automatically enable \"isolate\" mode\n   whenever one of the allowed windows is focused; alternatively, you can just provide a list of application\n   names and a windowfilter will be created for you that enables isolate mode whenever one of these apps is focused;\n   if omitted or nil, isolate mode won't be toggled automatically, but you can still toggle it manually via\n   `hs.window.higlight.toggleIsolate()`\n * windowfilterOverlay - (optional) an `hs.window.filter` instance that determines which windows to consider\n   for \"overlay\" mode when focused; if omitted or nil, the default windowfilter will be used\n\nReturns:\n * None\n\nNotes:\n * overlay mode is disabled by default - see `hs.window.highlight.ui.overlayColor`"
    },
    "Stops the module and disables focused window highlighting (both \"overlay\" and \"isolate\" mode)": {
        "prefix": "hs.window.highlight.stop()",
        "body": "hs.window.highlight.stop()",
        "description": "Stops the module and disables focused window highlighting (both \"overlay\" and \"isolate\" mode)\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Sets or clears the user override for \"isolate\" mode.": {
        "prefix": "hs.window.highlight.toggleIsolate([v])",
        "body": "hs.window.highlight.toggleIsolate(${1:[v]})",
        "description": "Sets or clears the user override for \"isolate\" mode.\n\nThis function should be bound to a hotkey, e.g.:\n`hs.hotkey.bind('ctrl-cmd','\\','Isolate',hs.window.highlight.toggleIsolate)`\n\nParameters:\n * v - (optional) a boolean; if true, enable isolate mode; if false, disable isolate mode,\n   even when `windowfilterIsolate` passed to `.start()` would otherwise enable it; if omitted or nil,\n   toggle the override, i.e. clear it if it's currently enforced, or set it to the opposite of the current\n   isolate mode status otherwise.\n\nReturns:\n * None"
    },
    "Allows customization of the highlight overlays and behaviour.": {
        "prefix": "hs.window.highlight.ui",
        "body": "hs.window.highlight.ui",
        "description": "Allows customization of the highlight overlays and behaviour.\n\nThe default values are shown in the right hand side of the assignements below.\n\nTo represent color values, you can use:\n * a table {red=redN, green=greenN, blue=blueN, alpha=alphaN}\n * a table {redN,greenN,blueN[,alphaN]} - if omitted alphaN defaults to 1.0\nwhere redN, greenN etc. are the desired value for the color component between 0.0 and 1.0\n\nColor inversion is governed by the module `hs.redshift`. See the relevant documentation for more information.\n\n * `hs.window.highlight.ui.overlay = false` - draw overlay over the area of the screen(s) that isn't occupied by the focused window\n * `hs.window.highlight.ui.overlayColor = {0.2,0.05,0,0.25}` - overlay color\n * `hs.window.highlight.ui.overlayColorInverted = {0.8,0.9,1,0.3}` - overlay color when colors are inverted\n * `hs.window.highlight.ui.isolateColor = {0,0,0,0.95}` - overlay color for isolate mode\n * `hs.window.highlight.ui.isolateColorInverted = {1,1,1,0.95}` - overlay color for isolate mode when colors are inverted\n * `hs.window.highlight.ui.frameWidth = 10` - draw a frame around the focused window in overlay mode; 0 to disable\n * `hs.window.highlight.ui.frameColor = {0,0.6,1,0.5}` - frame color\n * `hs.window.highlight.ui.frameColorInvert = {1,0.4,0,0.5}`\n * `hs.window.highlight.ui.flashDuration = 0` - duration in seconds of a brief flash over windows as they're shown/hidden;\n   disabled if 0; if desired, 0.3 is a good value\n * `hs.window.highlight.ui.windowShownFlashColor = {0,1,0,0.8}` - flash color when a window is shown (created or unhidden)\n * `hs.window.highlight.ui.windowHiddenFlashColor = {1,0,0,0.8}` - flash color when a window is hidden (destroyed or hidden)\n * `hs.window.highlight.ui.windowShownFlashColorInvert = {1,0,1,0.8}`\n * `hs.window.highlight.ui.windowHiddenFlashColorInvert = {0,1,1,0.8}`"
    },
    "Applies the layout": {
        "prefix": "hs.window.layout:apply()",
        "body": "hs.window.layout:apply()",
        "description": "Applies the layout\n\nParameters:\n * None\n\nReturns:\n * the `hs.window.layout` object\n\nNotes:\n * if a screen configuration is defined for this windowfilter, and currently not satisfied, this method will do nothing"
    },
    "When \"active mode\" windowlayouts apply a rule, they will pause briefly for this amount of time in seconds, to allow windows": {
        "prefix": "hs.window.layout.applyDelay",
        "body": "hs.window.layout.applyDelay",
        "description": "When \"active mode\" windowlayouts apply a rule, they will pause briefly for this amount of time in seconds, to allow windows\nto \"settle\" in their new configuration without triggering other rules (or the same rule), which could result in a\ncascade (or worse, a loop) or rules being applied. Defaults to 1; increase this if you experience unwanted repeated\ntriggering of rules due to sluggish performance."
    },
    "Applies a layout": {
        "prefix": "hs.window.layout.applyLayout(rules)",
        "body": "hs.window.layout.applyLayout(${1:rules})",
        "description": "Applies a layout\n\nParameters:\n * rules - see `hs.window.layout.new()`\n\nReturns:\n * None\n\nNotes:\n * this is a convenience wrapper for \"passive mode\" use that creates, applies, and deletes a windowlayout object;\n   do *not* use shared windowfilters in `rules`, as they'll be deleted; you can just use constructor argument maps instead"
    },
    "Return a table with all the rules (and the screen configuration, if present) defined for this windowlayout": {
        "prefix": "hs.window.layout:getRules() -> table",
        "body": "hs.window.layout:getRules()",
        "description": "Return a table with all the rules (and the screen configuration, if present) defined for this windowlayout\n\nParameters:\n * None\n\nReturns:\n * a table containing the rules of this windowlayout; you can pass this table (optionally\n   after performing valid manipulations) to `hs.window.layout.new()`"
    },
    "Creates a new hs.window.layout instance": {
        "prefix": "hs.window.layout.new(rules[,logname[,loglevel]]) -> hs.window.layout object",
        "body": "hs.window.layout.new(${1:rules[},${2:logname[},${3:loglevel]]})",
        "description": "Creates a new hs.window.layout instance\n\nParameters:\n * rules - a table containing the rules for this windowlayout (see the module description); additionally, if a special key `screens`\n   is present, its value must be a valid screen configuration as per `hs.window.layout:setScreenConfiguration()`\n * logname - (optional) name of the `hs.logger` instance for the new windowlayout; if omitted, the class logger will be used\n * loglevel - (optional) log level for the `hs.logger` instance for the new windowlayout\n\nReturns:\n * a new windowlayout instance"
    },
    "Pauses an active windowlayout instance; while paused no automatic window management will occur": {
        "prefix": "hs.window.layout:pause() -> hs.window.layout object",
        "body": "hs.window.layout:pause()",
        "description": "Pauses an active windowlayout instance; while paused no automatic window management will occur\n\nParameters:\n * None\n\nReturns:\n * the `hs.window.layout` object"
    },
    "Pauses all active windowlayout instances": {
        "prefix": "hs.window.layout.pauseAllInstances()",
        "body": "hs.window.layout.pauseAllInstances()",
        "description": "Pauses all active windowlayout instances\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "Resumes an active windowlayout instance after it was paused": {
        "prefix": "hs.window.layout:resume() -> hs.window.layout object",
        "body": "hs.window.layout:resume()",
        "description": "Resumes an active windowlayout instance after it was paused\n\nParameters:\n * None\n\nReturns:\n * the `hs.window.layout` object\n\nNotes:\n * if a screen configuration is defined for this windowfilter, and currently not satisfied, this method will do nothing"
    },
    "Resumes all active windowlayout instances": {
        "prefix": "hs.window.layout.resumeAllInstances()",
        "body": "hs.window.layout.resumeAllInstances()",
        "description": "Resumes all active windowlayout instances\n\nParameters:\n * None\n\nReturns:\n * None"
    },
    "The number of seconds to wait, after a screen configuration change has been detected, before": {
        "prefix": "hs.window.layout.screensChangedDelay",
        "body": "hs.window.layout.screensChangedDelay",
        "description": "The number of seconds to wait, after a screen configuration change has been detected, before\nresuming any active windowlayouts that are allowed in the new configuration; defaults\nto 10, to give sufficient time to OSX to do its own housekeeping"
    },
    "Determines the screen configuration that permits applying this windowlayout": {
        "prefix": "hs.window.layout:setScreenConfiguration(screens) -> hs.window.layout object",
        "body": "hs.window.layout:setScreenConfiguration(${1:screens})",
        "description": "Determines the screen configuration that permits applying this windowlayout\n\nWith this method you can define different windowlayouts for different screen configurations\n(as per System Preferences->Displays->Arrangement).\nFor example, suppose you define two \"graphics design work\" windowlayouts, one for \"desk with dual monitors\"\nand one for \"laptop only mode\":\n* \"passive mode\" use: you call `:apply()` on *both* on your chosen hotkey (via `hs.hotkey:bind()`), but\n  only the appropriate layout for the current arrangement will be applied\n* \"active mode\" use: you just call `:start()` on both windowlayouts; as you switch between workplaces\n  (by attaching or detaching external screens) the correct layout \"kicks in\"\n  automatically - this is in effect a convenience wrapper that calls `:pause()` on the no longer relevant\n  layout, and `:resume()` on the appropriate one, at every screen configuration change\n\nParameters:\n * screens - a map, where each *key* must be a valid \"hint\" for `hs.screen.find()`, and the corresponding\n   value can be:\n   * `true` - the screen must be currently present (attached and enabled)\n   * `false` - the screen must be currently absent\n   * an `hs.geometry` point (or constructor argument) - the screen must be present and in this specific\n     position in the current arragement (as per `hs.screen:position()`)\n\nReturns:\n * the `hs.window.layout` object\n\nNotes:\n * if `screens` is `nil`, any previous screen configuration is removed, and this windowlayout will be always allowed\n * for \"active\" windowlayouts, call this method *before* calling `hs.window.layout:start()`\n * by using `hs.geometry` size objects as hints you can define separate layouts for the same physical\n   screen at different resolutions\n\nUsage:\n```\nlocal laptop_layout,desk_layout=... -- define your layouts\n-- just the laptop screen:\nlaptop_layout:setScreenConfiguration{['Color LCD']='0,0',dell=false,['3840x2160']=false}:start()\n-- attached to a 4k primary + a Dell on the right:\ndesk_layout:setScreenConfiguration{['3840x2160']='0,0',['dell']='1,0',['Color LCD']='-1,0'}:start()\n-- as above, but in clamshell mode (laptop lid closed):\nclamshell_layout:setScreenConfiguration{['3840x2160']='0,0',['dell']='1,0',['Color LCD']=false}:start()\n```"
    },
    "Puts a windowlayout instance in \"active mode\"": {
        "prefix": "hs.window.layout:start() -> hs.window.layout object",
        "body": "hs.window.layout:start()",
        "description": "Puts a windowlayout instance in \"active mode\"\n\nWhen in active mode, a windowlayout instance will constantly monitor the windowfilters for its rules,\nby subscribing to all the relevant events. As soon as any change is detected (e.g. when you drag a window,\nswitch focus, open or close apps/windows, etc.) the relative rule will be automatically re-applied.\nIn other words, the rules you defined will remain enforced all the time, instead of waiting for manual\nintervention via `hs.window.layout:apply()`.\n\nParameters:\n * None\n\nReturns:\n * the `hs.window.layout` object\n\nNotes:\n * if a screen configuration is defined for this windowfilter, and currently not satisfied, this\n   windowfilter will be put in \"active mode\" but will remain paused until the screen configuration\n   requirements are met"
    },
    "Stops a windowlayout instance (i.e. not in \"active mode\" anymore)": {
        "prefix": "hs.window.layout:stop() -> hs.window.layout object",
        "body": "hs.window.layout:stop()",
        "description": "Stops a windowlayout instance (i.e. not in \"active mode\" anymore)\n\nParameters:\n * None\n\nReturns:\n * the `hs.window.layout` object"
    },
    "Creates a new switcher instance; it can use a windowfilter to determine which windows to show": {
        "prefix": "hs.window.switcher.new([windowfilter[, uiPrefs][, logname, [loglevel]]]) -> hs.window.switcher object",
        "body": "hs.window.switcher.new(${1:[windowfilter[}, ${2:uiPrefs][}, ${3:logname}, ${4:[loglevel]]]})",
        "description": "Creates a new switcher instance; it can use a windowfilter to determine which windows to show\n\nParameters:\n * windowfilter - (optional) if omitted or nil, use the default windowfilter; otherwise it must be a windowfilter\n   instance or constructor table\n * uiPrefs - (optional) a table to override UI preferences for this instance; its keys and values\n   must follow the conventions described in `hs.window.switcher.ui`; this parameter allows you to have multiple\n   switcher instances with different behaviour (for example, with and without thumbnails and/or titles)\n   using different hotkeys\n * logname - (optional) name of the `hs.logger` instance for the new switcher; if omitted, the class logger will be used\n * loglevel - (optional) log level for the `hs.logger` instance for the new switcher\n\nReturns:\n * the new instance"
    },
    "Shows the switcher instance (if not yet visible) and selects the next window": {
        "prefix": "hs.window.switcher:next()",
        "body": "hs.window.switcher:next()",
        "description": "Shows the switcher instance (if not yet visible) and selects the next window\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * the switcher will be dismissed (and the selected window focused) when all modifier keys are released"
    },
    "Shows the switcher (if not yet visible) and selects the next window": {
        "prefix": "hs.window.switcher.nextWindow()",
        "body": "hs.window.switcher.nextWindow()",
        "description": "Shows the switcher (if not yet visible) and selects the next window\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * the switcher will be dismissed (and the selected window focused) when all modifier keys are released"
    },
    "Shows the switcher instance (if not yet visible) and selects the previous window": {
        "prefix": "hs.window.switcher:previous()",
        "body": "hs.window.switcher:previous()",
        "description": "Shows the switcher instance (if not yet visible) and selects the previous window\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * the switcher will be dismissed (and the selected window focused) when all modifier keys are released"
    },
    "Shows the switcher (if not yet visible) and selects the previous window": {
        "prefix": "hs.window.switcher.previousWindow()",
        "body": "hs.window.switcher.previousWindow()",
        "description": "Shows the switcher (if not yet visible) and selects the previous window\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * the switcher will be dismissed (and the selected window focused) when all modifier keys are released"
    },
    "Allows customization of the switcher behaviour and user interface": {
        "prefix": "hs.window.switcher.ui",
        "body": "hs.window.switcher.ui",
        "description": "Allows customization of the switcher behaviour and user interface\n\nThis table contains variables that you can change to customize the behaviour of the switcher and the look of the UI.\nTo have multiple switcher instances with different behaviour/looks, use the `uiPrefs` parameter for the constructor;\nthe passed keys and values will override those in this table for that particular instance.\n\nThe default values are shown in the right hand side of the assignements below.\n\nTo represent color values, you can use:\n * a table {red=redN, green=greenN, blue=blueN, alpha=alphaN}\n * a table {redN,greenN,blueN[,alphaN]} - if omitted alphaN defaults to 1.0\nwhere redN, greenN etc. are the desired value for the color component between 0.0 and 1.0\n\n * `hs.window.switcher.ui.textColor = {0.9,0.9,0.9}`\n * `hs.window.switcher.ui.fontName = 'Lucida Grande'`\n * `hs.window.switcher.ui.textSize = 16` - in screen points\n * `hs.window.switcher.ui.highlightColor = {0.8,0.5,0,0.8}` - highlight color for the selected window\n * `hs.window.switcher.ui.backgroundColor = {0.3,0.3,0.3,1}`\n * `hs.window.switcher.ui.onlyActiveApplication = false` -- only show windows of the active application\n * `hs.window.switcher.ui.showTitles = true` - show window titles\n * `hs.window.switcher.ui.titleBackgroundColor = {0,0,0}`\n * `hs.window.switcher.ui.showThumbnails = true` - show window thumbnails\n * `hs.window.switcher.ui.thumbnailSize = 128` - size of window thumbnails in screen points\n * `hs.window.switcher.ui.showSelectedThumbnail = true` - show a larger thumbnail for the currently selected window\n * `hs.window.switcher.ui.selectedThumbnailSize = 384`\n * `hs.window.switcher.ui.showSelectedTitle = true` - show larger title for the currently selected window"
    },
    "Tile (or fit) windows into a rect": {
        "prefix": "hs.window.tiling.tileWindows(windows,rect[,desiredAspect[,processInOrder[,preserveRelativeArea[,animationDuration]]]])",
        "body": "hs.window.tiling.tileWindows(${1:windows},${2:rect[},${3:desiredAspect[},${4:processInOrder[},${5:preserveRelativeArea[},${6:animationDuration]]]]})",
        "description": "Tile (or fit) windows into a rect\n\nParameters:\n  * windows - a list of `hs.window` objects indicating the windows to tile or fit\n  * rect - an `hs.geometry` rect (or constructor argument), indicating the desired onscreen region that the windows will be tiled within\n  * desiredAspect - (optional) an `hs.geometry` size (or constructor argument) or a number, indicating the desired optimal aspect ratio (width/height) of the tiled\n    windows; the tiling engine will decide how to subdivide the rect among windows by trying to maintain every window's aspect ratio\n    as close as possible to this; if omitted, defaults to 1 (i.e. try to keep the windows as close to square as possible)\n  * processInOrder - (optional) if `true`, windows will be placed left-to-right and top-to-bottom following the list order in `windows`;\n    if `false` or omitted, the tiling engine will try to maintain the spatial distribution of windows, i.e. (roughly speaking) pick\n    the closest window for each destination \"tile\"; note that in some cases this isn't possible and the windows might get \"reshuffled\" around in unexpected ways\n  * preserveRelativeArea - (optional) if `true`, preserve the relative area among windows; that is, if window A is currently twice as large\n    as window B, the same will be true after both windows have been processed and placed into the rect; if `false` or omitted, all windows\n    will have the same area (= area of the rect / number of windows) after processing\n  * animationDuration - (optional) the number of seconds to animate the move/resize operations of the windows; if omitted, defaults to\n    the value of `hs.window.animationDuration`\n\nReturns:\n  * None\n\nNotes:\n  * To ensure all windows are placed in a row (side by side), use a very small aspect ratio (for \"tall and narrow\" windows) like 0.01;\n    similarly, to have all windows in a column, use a very large aspect ratio (for \"short and wide\") like 100\n  * Hidden and minimized windows will be processed as well: the rect will have \"gaps\" where the invisible windows\n    would lie, that will get filled as the windows get unhidden/unminimized"
    }
}